// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOC
import { Result, ok, err, DomainError, withContext } from 'src/shared/errors';
import { Log, Logger } from 'src/shared/logging';
import { EventMetadata } from 'src/shared/domain/events';
import { Clock } from 'src/shared/infrastructure/time';
import { ActorContextUtil } from 'src/shared/utilities/actor-context.util';
import { IUserToken } from 'src/shared/security';
import { SecurityMetadata } from 'src/shared/domain/events/event-metadata';
import { ActorContext } from 'src/shared/application/context';

type UserToken = IUserToken;

/**
 * Base interface that all use case commands must implement
 */
export interface BaseUseCaseCommand {
  correlationId: string;
  user: UserToken;
  securityContext: SecurityMetadata;
  timestamp: Date;
  props?: unknown; // Commands may have props
}

/**
 * Generic use case command type that extends the base interface
 * TProps: The type of the props property
 * TExtra: Additional properties specific to the command
 */
export type UseCaseCommand<
  TProps,
  TExtra = Record<string, never>,
> = BaseUseCaseCommand & {
  props: TProps;
} & TExtra;

type RepoLike<TAggregate> = {
  save: (
    actor: ActorContext,
    agg: TAggregate,
  ) => Promise<Result<void, DomainError>>;
};

type FkValidatorLike<TProps, TValidatedEntities = unknown> = {
  validateForeignKeys: (
    actor: ActorContext,
    props: TProps,
    validationContext: any,
    logger: Logger,
  ) => Promise<Result<TValidatedEntities, DomainError>>;
};

export type RunUseCaseArgs<
  TCommand extends BaseUseCaseCommand,
  TAggregate extends { id: { value: string | number } },
  TExisting,
  TValidatedEntities = unknown,
> = {
  /** Service name for logging and metadata, e.g. "currency-config" */
  serviceName: string;
  /** e.g. "CreateCurrencyUseCase" | "UpdateChannelUseCase" */
  component: string;
  /** e.g. "create_currency" | "update_channel" */
  operation: string;
  /** metadata.source, e.g. "currency-config.application.create-currency" */
  source: string;

  command: TCommand;
  logger: Logger;
  clock: Clock;

  repo: RepoLike<TAggregate>;
  fkValidator?: FkValidatorLike<any, TValidatedEntities>;

  /** Error to use when props missing (e.g. CurrencyErrors.INVALID_CURRENCY_DATA) */
  propsMissingError: DomainError;

  /**
   * Optional: load current snapshot or state needed by the domain factory.
   * If the target is not found, return err(EntityErrors.ENTITY_NOT_FOUND) with context.
   */
  loadExisting?: (
    actor: ActorContext,
    command: TCommand,
  ) => Promise<Result<TExisting, DomainError>>;

  /**
   * Domain factory. For create, ignore `existing`; for update, use it.
   * Must return a fully-valid aggregate or a domain error.
   */
  runDomain: (args: {
    metadata: EventMetadata;
    clock: Clock;
    command: TCommand;
    existing?: TExisting;
    validatedEntities?: TValidatedEntities;
  }) => Result<TAggregate, DomainError>;
};

export async function runUseCase<
  TCommand extends BaseUseCaseCommand,
  TAggregate extends { id: { value: string | number } },
  TExisting,
  TValidatedEntities = unknown,
>(
  args: RunUseCaseArgs<TCommand, TAggregate, TExisting, TValidatedEntities>,
): Promise<Result<TAggregate, DomainError>> {
  const {
    serviceName,
    component,
    operation,
    source,
    command,
    logger,
    clock,
    repo,
    fkValidator,
    propsMissingError,
    loadExisting,
    runDomain,
  } = args;

  // --- Start & pre-validation logs
  Log.info(logger, `Executing ${component}`, {
    application: serviceName,
    component,
    method: 'execute',
    correlationId: command.correlationId,
    userId: command.user.sub,
    propsKeys: Object.keys(command.props || {}),
    repositoryFeatures: {
      cachingEnabled: true,
      metricsEnabled: true,
      healthMonitoringEnabled: true,
    },
  });

  Log.debug(logger, 'Performing technical pre-validation', {
    application: serviceName,
    component,
    method: 'execute',
    correlationId: command.correlationId,
    userId: command.user.sub,
    operation: `${operation}_pre_validation`,
  });

  // --- Props guard
  if (command.props == null) {
    Log.warn(logger, 'Missing props structure', {
      application: serviceName,
      component,
      method: 'execute',
      correlationId: command.correlationId,
      userId: command.user.sub,
      reason: 'PROPS_MISSING',
    });
    return err(
      withContext(propsMissingError, {
        correlationId: command.correlationId,
        userId: command.user.sub,
        operation: `${operation}_technical_validation`,
        validationFailure: 'PROPS_STRUCTURE_MISSING',
        providedProps: command.props,
        expectedStructure: 'Props object with required fields',
        reason: 'Command props is null or undefined',
      }),
    );
  }
  const props = command.props as NonNullable<TCommand['props']>;

  // --- Actor
  const actorR = ActorContextUtil.fromUserTokenSafe(command.user);
  if (!actorR.ok) return err(actorR.error);
  const actor = actorR.value;

  // --- Metadata
  const metadata: EventMetadata = {
    actor: {
      userId: command.user.sub,
      tenant: command.user.tenant,
      username: command.user.email,
      tenant_userId: command.user.tenant_id || '',
      roles: command.user.roles ?? [],
    },
    correlationId: command.correlationId,
    causationId: command.correlationId, // Use correlation ID as causation for use case operations
    commandId: `${operation}-${Date.now()}-${Math.random().toString(36).substr(2, 8)}`, // Unique command ID
    service: serviceName,
    timestampIso: clock.nowIso(),
    source,
    eventVersion: '1.0.0',
    schemaVersion: '2025.1',
    dataClassification: 'internal',
  };

  // --- (Optional) Load existing state
  let existing: TExisting | undefined;
  if (loadExisting) {
    const existingR = await loadExisting(actor, command);
    if (!existingR.ok) return err(existingR.error);
    existing = existingR.value;
  }

  // --- FK validation
  // --- Foreign Key Validation (if validator provided)
  let validatedEntities: TValidatedEntities | undefined;
  if (fkValidator) {
    const validationContext = {
      correlationId: command.correlationId,
      userId: command.user.sub,
      operation: `${operation}_foreign_key_validation`,
      component,
    };
    const fkR = await fkValidator.validateForeignKeys(
      actor,
      props,
      validationContext,
      logger,
    );
    if (!fkR.ok) return err(fkR.error);
    validatedEntities = fkR.value;
  }

  // --- Domain factory
  const aggR = runDomain({
    metadata,
    clock,
    command,
    existing,
    validatedEntities,
  });
  if (!aggR.ok) {
    Log.error(logger, 'Domain factory failed', {
      application: serviceName,
      component,
      method: 'execute',
      correlationId: command.correlationId,
      userId: command.user.sub,
      operation,
      error: aggR.error,
    });
    return err(aggR.error);
  }
  const aggregate = aggR.value;

  // --- Persist
  const saveR = await repo.save(actor, aggregate);
  if (!saveR.ok) {
    return err(
      withContext(saveR.error, {
        correlationId: command.correlationId,
        userId: command.user.sub,
        operation,
        entityId: String(aggregate.id.value),
      }),
    );
  }

  // --- Success log
  Log.info(logger, `${component} executed successfully`, {
    application: serviceName,
    component,
    method: 'execute',
    correlationId: command.correlationId,
    userId: command.user.sub,
    operation,
    aggregateId: String(aggregate.id.value),
  });

  return ok(aggregate);
}

/**
 * Authorization modes for the secure use-case runner
 */
export type AuthorizationMode =
  | { type: 'create'; operation: 'create' }
  | {
      type: 'read';
      operation: 'read';
      resourceId?: string;
    }
  | {
      type: 'update';
      operation: 'update';
      resourceId: string;
      fields?: string[];
    }
  | { type: 'delete'; operation: 'delete'; resourceId: string }
  | {
      type: 'custom';
      operation: string;
      resourceId?: string;
      fields?: string[];
    };

/**
 * Authorization service interface for secure use-case operations
 */
export interface AuthorizationService<TAuthContext = any> {
  canCreateResource?: (
    userId: string,
    correlationId: string,
    context: TAuthContext,
  ) => Promise<Result<boolean, DomainError>>;

  canReadResource?: (
    userId: string,
    resourceId: string,
    correlationId: string,
    context: TAuthContext,
  ) => Promise<Result<boolean, DomainError>>;

  authorizeResourceOperation?: (
    userId: string,
    operation: string,
    correlationId: string,
    resourceId: string,
    fields?: string[],
    context?: TAuthContext,
  ) => Promise<
    Result<
      {
        authorized: boolean;
        allowedFields?: string[];
        deniedFields?: string[];
      },
      DomainError
    >
  >;
}

export type RunUseCaseWithSecurityArgs<
  TCommand extends BaseUseCaseCommand,
  TAggregate extends { id: { value: string | number } },
  TExisting,
  TValidatedEntities = unknown,
  TAuthContext = any,
> = RunUseCaseArgs<TCommand, TAggregate, TExisting, TValidatedEntities> & {
  /** Authorization service for performing security checks */
  authorizationService: AuthorizationService<TAuthContext>;

  /** Authorization mode and configuration */
  authorization: AuthorizationMode;

  /** Additional context for authorization */
  authContext?: TAuthContext;

  /** Function to extract fields from props for field-level authorization */
  extractFields?: (props: TCommand['props']) => string[];
};

/**
 * Secure version of runUseCase that includes built-in authorization checks
 */
export type OperationType = 'create' | 'read' | 'update' | 'delete';

export async function runUseCaseWithSecurity<
  TCommand extends BaseUseCaseCommand,
  TAggregate extends { id: { value: string | number } },
  TExisting,
  TValidatedEntities = unknown,
  TAuthContext = ActorContext & {
    operationType: OperationType;
  },
>(
  args: RunUseCaseWithSecurityArgs<
    TCommand,
    TAggregate,
    TExisting,
    TValidatedEntities,
    TAuthContext
  >,
): Promise<Result<TAggregate, DomainError>> {
  const {
    authorizationService,
    authorization,
    authContext,
    extractFields,
    command,
    logger,
    component,
    ...useCaseArgs
  } = args;

  // Build default auth context
  const defaultAuthContext = {
    tenant: command.user.tenant,
    userRoles: command.user.roles,
    operationType: authorization.operation,
    ...authContext,
  } as TAuthContext;

  // Perform authorization checks based on the mode
  Log.info(logger, `Performing authorization check: ${authorization.type}`, {
    component,
    method: 'execute',
    correlationId: command.correlationId,
    userId: command.user.sub,
    operation: authorization.operation,
    resourceId:
      'resourceId' in authorization ? authorization.resourceId : undefined,
  });

  switch (authorization.type) {
    case 'create': {
      if (!authorizationService.canCreateResource) {
        return err({
          code: 'AUTHORIZATION.UNSUPPORTED_OPERATION',
          title: 'Create authorization not supported by service',
          category: 'application',
          context: { operation: 'create' },
        });
      }

      const authResult = await authorizationService.canCreateResource(
        command.user.sub,
        command.correlationId,
        defaultAuthContext,
      );

      if (!authResult.ok) return err(authResult.error);

      if (!authResult.value) {
        return err({
          code: 'AUTHORIZATION.CREATE_NOT_AUTHORIZED',
          title: 'Not authorized to create resource',
          category: 'security',
          context: {
            userId: command.user.sub,
            operation: 'create',
          },
        });
      }
      break;
    }

    case 'read': {
      if (!authorizationService.canReadResource) {
        return err({
          code: 'AUTHORIZATION.UNSUPPORTED_OPERATION',
          title: 'Read authorization not supported by service',
          category: 'application',
          context: { operation: 'read' },
        });
      }

      if (!authorization.resourceId) {
        return err({
          code: 'AUTHORIZATION.MISSING_RESOURCE_ID',
          title: 'Resource ID required for read authorization',
          category: 'validation',
          context: { operation: 'read' },
        });
      }

      const authResult = await authorizationService.canReadResource(
        command.user.sub,
        authorization.resourceId,
        command.correlationId,
        defaultAuthContext,
      );

      if (!authResult.ok) return err(authResult.error);

      if (!authResult.value) {
        return err({
          code: 'AUTHORIZATION.READ_NOT_AUTHORIZED',
          title: 'Not authorized to read this resource',
          category: 'security',
          context: {
            userId: command.user.sub,
            resourceId: authorization.resourceId,
            operation: 'read',
          },
        });
      }
      break;
    }

    case 'update': {
      if (!authorizationService.authorizeResourceOperation) {
        return err({
          code: 'AUTHORIZATION.UNSUPPORTED_OPERATION',
          title: 'Update authorization not supported by service',
          category: 'application',
          context: { operation: 'update' },
        });
      }

      // Extract fields from props if extractor provided
      const fields =
        extractFields && command.props
          ? extractFields(command.props)
          : authorization.fields;

      const authResult = await authorizationService.authorizeResourceOperation(
        command.user.sub,
        authorization.operation,
        command.correlationId,
        authorization.resourceId,
        fields,
        defaultAuthContext,
      );

      if (!authResult.ok) return err(authResult.error);

      const { authorized, deniedFields } = authResult.value;

      if (!authorized) {
        return err({
          code: 'AUTHORIZATION.UPDATE_NOT_AUTHORIZED',
          title: 'Not authorized to update this resource',
          category: 'security',
          context: {
            userId: command.user.sub,
            resourceId: authorization.resourceId,
            operation: 'update',
            deniedFields,
          },
        });
      }

      // Check for partial denials
      if (deniedFields && deniedFields.length > 0) {
        Log.warn(logger, 'Some fields denied for resource update', {
          component,
          method: 'execute',
          correlationId: command.correlationId,
          userId: command.user.sub,
          resourceId: authorization.resourceId,
          deniedFields,
        });

        return err({
          code: 'AUTHORIZATION.PARTIAL_UPDATE_DENIED',
          title:
            'Some fields cannot be updated due to insufficient permissions',
          category: 'security',
          context: {
            userId: command.user.sub,
            resourceId: authorization.resourceId,
            deniedFields,
          },
        });
      }
      break;
    }

    case 'delete': {
      if (!authorizationService.authorizeResourceOperation) {
        return err({
          code: 'AUTHORIZATION.UNSUPPORTED_OPERATION',
          title: 'Delete authorization not supported by service',
          category: 'application',
          context: { operation: 'delete' },
        });
      }

      const authResult = await authorizationService.authorizeResourceOperation(
        command.user.sub,
        authorization.operation,
        command.correlationId,
        authorization.resourceId,
        undefined,
        defaultAuthContext,
      );

      if (!authResult.ok) return err(authResult.error);

      if (!authResult.value.authorized) {
        return err({
          code: 'AUTHORIZATION.DELETE_NOT_AUTHORIZED',
          title: 'Not authorized to delete this resource',
          category: 'security',
          context: {
            userId: command.user.sub,
            resourceId: authorization.resourceId,
            operation: 'delete',
          },
        });
      }
      break;
    }

    case 'custom': {
      if (!authorizationService.authorizeResourceOperation) {
        return err({
          code: 'AUTHORIZATION.UNSUPPORTED_OPERATION',
          title: 'Custom authorization not supported by service',
          category: 'application',
          context: { operation: authorization.operation },
        });
      }

      const fields =
        extractFields && command.props
          ? extractFields(command.props)
          : authorization.fields;

      const authResult = await authorizationService.authorizeResourceOperation(
        command.user.sub,
        authorization.operation,
        command.correlationId,
        authorization.resourceId || '',
        fields,
        defaultAuthContext,
      );

      if (!authResult.ok) return err(authResult.error);

      if (!authResult.value.authorized) {
        return err({
          code: 'AUTHORIZATION.OPERATION_NOT_AUTHORIZED',
          title: `Not authorized to ${authorization.operation} this resource`,
          category: 'security',
          context: {
            userId: command.user.sub,
            resourceId: authorization.resourceId,
            operation: authorization.operation,
          },
        });
      }
      break;
    }

    default:
      return err({
        code: 'AUTHORIZATION.INVALID_MODE',
        title: 'Invalid authorization mode',
        category: 'application',
        context: { mode: authorization },
      });
  }

  Log.info(logger, 'Authorization check passed', {
    component,
    method: 'execute',
    correlationId: command.correlationId,
    userId: command.user.sub,
    operation: authorization.operation,
    resourceId:
      'resourceId' in authorization ? authorization.resourceId : undefined,
  });

  // Now run the regular use-case logic
  return runUseCase({
    ...useCaseArgs,
    command,
    logger,
    component,
  });
}
