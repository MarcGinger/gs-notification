// Load environment variables first - before any imports that use configuration
// Only load .env if Doppler is not available (for local development fallback)
import * as dotenv from 'dotenv';

function isDopplerAvailable(): boolean {
  // Check if Doppler CLI is available and configured
  // More reliable than just checking DOPPLER_PROJECT/DOPPLER_TOKEN
  return !!(
    process.env.DOPPLER_PROJECT ||
    process.env.DOPPLER_TOKEN ||
    process.env.DOPPLER_ENVIRONMENT ||
    // Check if .env file is Doppler-generated (contains Doppler header)
    isDopplerGeneratedEnvFile()
  );
}

function isDopplerGeneratedEnvFile(): boolean {
  try {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const fs = require('fs') as {
      readFileSync: (path: string, encoding?: string) => string;
    };
    const envContent = fs.readFileSync('.env', 'utf8');
    return envContent.includes('automatically generated by [Doppler]');
  } catch {
    return false;
  }
}

if (!isDopplerAvailable()) {
  console.log(
    'üîß Doppler not detected, loading .env file for local development',
  );
  dotenv.config();
} else {
  console.log(
    'üîß Doppler detected, delegating to Doppler module for configuration loading',
  );
}

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Logger as NestPinoLogger } from 'nestjs-pino';
import { Logger as PinoLogger } from 'pino';
import { ClsService } from 'nestjs-cls';
import helmet from 'helmet';
import { AppConfigUtil } from './shared/config/app-config.util';
import { ConfigManager } from './shared/config/config.manager';
import { APP_LOGGER, Log } from './shared/logging'; // ‚úÖ Use barrel export
import { setupGlobalClsLogging } from './shared/logging/cls-logger.util';
import { ResultInterceptor } from './shared/errors/result.interceptor';
import { SecurityConfigService } from './shared/security/config/security-config.service';
import { INestApplication, VersioningType } from '@nestjs/common';
import { setupMultipleSwaggerDocs } from './docs';

async function bootstrap() {
  let baseLogger: PinoLogger | undefined;

  try {
    // Pre-validate configuration before creating the app
    console.log('üîß Validating application configuration...');
    const configValidation = AppConfigUtil.validateLoggingConfig();

    if (!configValidation.valid) {
      console.error(
        '‚ùå Configuration validation failed:',
        configValidation.errors,
      );
      process.exit(1);
    }

    if (configValidation.warnings.length > 0) {
      console.warn('‚ö†Ô∏è Configuration warnings:', configValidation.warnings);
    }

    // Create the NestJS application with buffered logs
    const app = await NestFactory.create(AppModule, {
      bufferLogs: true,
    });

    // CRITICAL ENHANCEMENT: Setup global CLS access for logging
    const clsService = app.get(ClsService);
    setupGlobalClsLogging(clsService);

    // CRITICAL FIX #1: Get the raw Pino logger (not the NestJS wrapper)
    baseLogger = app.get<PinoLogger>(APP_LOGGER);

    // CRITICAL FIX #2: Use the NestJS Pino logger wrapper for app.useLogger
    const nestPinoLogger = app.get(NestPinoLogger);
    app.useLogger(nestPinoLogger);

    // CRITICAL FIX #3: Initialize ConfigManager immediately after logger setup
    const configManager = ConfigManager.getInstance();

    // CRITICAL FIX #4: ConfigManager validation with safe error handling
    const validationResult = configManager.validateAndLogSafe(baseLogger);
    if (!validationResult.ok) {
      // INTENTIONAL THROW: Bootstrap must fail fast on configuration validation errors
      throw new Error(
        `Configuration validation error: ${validationResult.error.detail}`,
      );
    }
    const validation = validationResult.value;

    // Early bootstrap logging with base logger
    Log.info(baseLogger, 'Application bootstrap initiated', {
      method: 'bootstrap',
      phase: 'post-logger-init',
      validation: validation.valid,
    });

    // CRITICAL FIX #5: Ensure port is number type
    const port: number = AppConfigUtil.getPort(3010);
    const serverUrl = AppConfigUtil.buildUrl(port);

    // Enable graceful shutdown hooks
    app.enableShutdownHooks();

    // Register global Result Interceptor for automatic Result<T,E> ‚Üí HTTP conversion
    app.useGlobalInterceptors(new ResultInterceptor());

    Log.info(baseLogger, 'Result Interceptor registered globally', {
      method: 'bootstrap',
      feature: 'error_management',
      description: 'Automatic Result<T,E> to HTTP response conversion enabled',
    });

    // Configure security headers and CORS
    configureApplicationSecurity(app, baseLogger);

    // Enable URI versioning
    app.enableVersioning({
      type: VersioningType.URI,
      defaultVersion: '1',
    });

    // base routing
    const globalPrefix = 'api';
    app.setGlobalPrefix(globalPrefix);

    // swagger config
    // if (!AppConfigUtil.isProduction()) {
    // Setup multiple Swagger documents
    setupMultipleSwaggerDocs(app, port);
    // }

    await app.listen(port);

    // Log successful startup
    Log.info(baseLogger, 'Application started successfully', {
      method: 'bootstrap',
      port,
      serverUrl,
      environment: configManager.getEnvironment(),
      nodeEnv: AppConfigUtil.getEnvironment(),
      processId: process.pid,
    });

    // Log configuration summary for operations
    const configSummary = configManager.getConfigSummary();
    Log.info(baseLogger, 'Application configuration summary', {
      method: 'bootstrap',
      environment: configSummary.environment,
      isProduction: configSummary.isProduction,
      isContainerized: configSummary.isContainerized,
      logLevel: configSummary.logging.level,
      features: configSummary.features,
    });

    // Log server configurations for documentation/debugging
    const serverConfigs = configManager.getServerConfigurations(port);
    Log.info(baseLogger, 'Server endpoints available', {
      method: 'bootstrap',
      endpoints: serverConfigs,
    });

    // Set up graceful shutdown handlers
    setupGracefulShutdown(app, baseLogger);
  } catch (err) {
    // CRITICAL FIX #6: Enhanced error handling with proper fallbacks
    const error = err as Error;

    if (baseLogger) {
      // Use structured logging if logger is available
      try {
        const configManager = ConfigManager.getInstance();
        configManager.logError(error, 'Application failed to start', {
          method: 'bootstrap',
          environment: AppConfigUtil.getEnvironment(),
          nodeEnv: AppConfigUtil.getEnvironment(),
          errorStack: error.stack,
        });
      } catch {
        // Fallback to base logger
        Log.error(baseLogger, 'Application startup failed', {
          method: 'bootstrap',
          fallback: 'config-manager-unavailable',
          error: error.message,
          errorStack: error.stack,
        });
      }
    } else {
      // Fallback to console logging if no logger available
      console.error('‚ùå Application failed to start:', error.message);
      console.error('Stack trace:', error.stack);
    }

    process.exit(1);
  }
}

/**
 * Set up graceful shutdown handling for production deployment
 */
function setupGracefulShutdown(app: INestApplication, logger: PinoLogger) {
  const shutdown = async (signal: string) => {
    Log.info(logger, `Received ${signal}, shutting down gracefully`, {
      method: 'shutdown',
      signal,
      processId: process.pid,
    });

    try {
      await app.close();
      Log.info(logger, 'Application closed successfully', {
        method: 'shutdown',
        signal,
      });
      process.exit(0);
    } catch (error) {
      Log.error(logger, 'Error during shutdown', {
        method: 'shutdown',
        signal,
        error: (error as Error).message,
        errorStack: (error as Error).stack,
      });
      process.exit(1);
    }
  };

  // Handle common shutdown signals
  process.on('SIGTERM', () => void shutdown('SIGTERM'));
  process.on('SIGINT', () => void shutdown('SIGINT'));

  // Handle uncaught exceptions and rejections
  process.on('uncaughtException', (error) => {
    Log.error(logger, 'Uncaught exception', {
      method: 'error-handler',
      type: 'uncaughtException',
      error: error.message,
      errorStack: error.stack,
    });
    process.exit(1);
  });

  process.on('unhandledRejection', (reason) => {
    Log.error(logger, 'Unhandled rejection', {
      method: 'error-handler',
      type: 'unhandledRejection',
      promiseInfo: 'Promise details omitted for security',
      error: (reason as Error).message,
      errorStack: (reason as Error).stack,
    });
    process.exit(1);
  });
}

/**
 * Configure application security headers and CORS
 */
function configureApplicationSecurity(
  app: INestApplication,
  logger: PinoLogger,
): void {
  try {
    // Get security configuration
    const securityConfigService = app.get(SecurityConfigService);

    // Get CORS configuration safely
    const corsConfigResult = securityConfigService.getValidatedCorsConfigSafe();
    if (!corsConfigResult.ok) {
      // INTENTIONAL THROW: Bootstrap must fail fast on configuration errors - can't start server without valid CORS config
      throw new Error(
        `CORS configuration error: ${corsConfigResult.error.detail}`,
      );
    }
    const corsConfig = corsConfigResult.value;

    const environment = ConfigManager.getInstance().getEnvironment();
    const isProduction = environment === 'production';

    // Configure Helmet security headers
    app.use(
      helmet({
        // Content Security Policy - strict for production
        contentSecurityPolicy: isProduction
          ? {
              directives: {
                defaultSrc: ["'self'"],
                styleSrc: ["'self'", "'unsafe-inline'"],
                scriptSrc: ["'self'"],
                imgSrc: ["'self'", 'data:', 'https:'],
                connectSrc: ["'self'"],
                fontSrc: ["'self'"],
                objectSrc: ["'none'"],
                mediaSrc: ["'self'"],
                frameSrc: ["'none'"],
              },
            }
          : false, // Disable in development for easier debugging

        // Cross Origin Embedder Policy
        crossOriginEmbedderPolicy: isProduction,

        // Cross Origin Opener Policy
        crossOriginOpenerPolicy: { policy: 'same-origin' },

        // Cross Origin Resource Policy
        crossOriginResourcePolicy: { policy: 'cross-origin' },

        // DNS Prefetch Control
        dnsPrefetchControl: { allow: false },

        // Frame guard
        frameguard: { action: 'deny' },

        // Hide powered by header
        hidePoweredBy: true,

        // HSTS - only in production with HTTPS
        hsts: isProduction
          ? {
              maxAge: 31536000, // 1 year
              includeSubDomains: true,
              preload: true,
            }
          : false,

        // IE No Open
        ieNoOpen: true,

        // No Sniff
        noSniff: true,

        // Origin Agent Cluster
        originAgentCluster: true,

        // Permitted Cross Domain Policies
        permittedCrossDomainPolicies: false,

        // Referrer Policy
        referrerPolicy: { policy: 'no-referrer' },

        // X-XSS-Protection
        xssFilter: true,
      }),
    );

    // Configure CORS
    app.enableCors({
      origin: corsConfig.allowedOrigins,
      credentials: corsConfig.allowCredentials,
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'],
      allowedHeaders: [
        'Content-Type',
        'Authorization',
        'X-Requested-With',
        'X-Correlation-ID',
        'X-Tenant-ID',
      ],
      exposedHeaders: ['X-Correlation-ID', 'X-Rate-Limit-*'],
      maxAge: 86400, // 24 hours
    });

    Log.info(logger, 'Security configuration applied', {
      method: 'configureApplicationSecurity',
      corsOrigins: corsConfig.allowedOrigins.length,
      corsCredentials: corsConfig.allowCredentials,
      environment,
      isProduction,
      securityFeatures: {
        helmet: true,
        cors: true,
        csp: isProduction,
        hsts: isProduction,
      },
    });
  } catch (error) {
    Log.error(logger, 'Failed to configure application security', {
      method: 'configureApplicationSecurity',
      error: (error as Error).message,
      errorStack: (error as Error).stack,
    });
    throw error;
  }
}

void bootstrap();
