// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, ok, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { TemplateAggregate } from '../aggregates';
import { TemplateEntity } from '../entities';
import { TemplateSnapshotProps, UpdateTemplateProps } from '../props';
import { ValidatedTemplateUpdateFields } from '../types';
import {
  TemplateWorkspaceCode,
  TemplateName,
  TemplateDescription,
  TemplateContentBlocks,
  TemplateVariables,
  TemplateSamplePayload,
  TemplateEnabled,
} from '../value-objects';

/**
 * Update Template Aggregate Factory
 *
 * Handles the complete update flow for Template aggregates:
 * 1. Loads existing aggregate from snapshot
 * 2. Validates update properties and creates value objects
 * 3. Applies updates with proper business rule enforcement
 * 4. Returns updated aggregate ready for persistence
 *
 * This factory provides:
 * - Consistent update pattern matching create operations
 * - Centralized validation and business logic
 * - Efficient batch updates vs field-by-field
 * - Proper error context and logging integration
 */
export function updateTemplateAggregateFromSnapshot(
  existingSnapshot: TemplateSnapshotProps,
  updateProps: UpdateTemplateProps,
  metadata: EventMetadata,
  clock: Clock,
): Result<TemplateAggregate, DomainError> {
  // 1. Reconstitute existing aggregate
  const entityResult = TemplateEntity.fromSnapshot(existingSnapshot);
  if (!entityResult.ok) {
    return err(
      withContext(entityResult.error, {
        operation: 'update_template_reconstitute',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
      }),
    );
  }

  const existingAggregate = TemplateAggregate.reconstitute(
    entityResult.value,
    clock,
    metadata,
  );

  // 2. Validate and apply updates for each provided field
  const validatedFields: ValidatedTemplateUpdateFields = {};

  // Validate workspaceCode if provided
  if (updateProps.workspaceCode !== undefined) {
    const workspaceCodeResult = TemplateWorkspaceCode.from(
      updateProps.workspaceCode,
    );
    if (!workspaceCodeResult.ok) {
      return err(
        withContext(workspaceCodeResult.error, {
          operation: 'update_template_workspace_code_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedWorkspaceCode: updateProps.workspaceCode,
        }),
      );
    }
    validatedFields.workspaceCode = workspaceCodeResult.value;
  }

  // Validate name if provided
  if (updateProps.name !== undefined) {
    const nameResult = TemplateName.from(updateProps.name);
    if (!nameResult.ok) {
      return err(
        withContext(nameResult.error, {
          operation: 'update_template_name_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedName: updateProps.name,
        }),
      );
    }
    validatedFields.name = nameResult.value;
  }

  // Validate description if provided
  if (updateProps.description !== undefined) {
    const descriptionResult = TemplateDescription.from(updateProps.description);
    if (!descriptionResult.ok) {
      return err(
        withContext(descriptionResult.error, {
          operation: 'update_template_description_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedDescription: updateProps.description,
        }),
      );
    }
    validatedFields.description = descriptionResult.value;
  }

  // Validate contentBlocks if provided
  if (updateProps.contentBlocks !== undefined) {
    const contentBlocksResult = TemplateContentBlocks.from(
      updateProps.contentBlocks,
    );
    if (!contentBlocksResult.ok) {
      return err(
        withContext(contentBlocksResult.error, {
          operation: 'update_template_content_blocks_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedContentBlocks: updateProps.contentBlocks,
        }),
      );
    }
    validatedFields.contentBlocks = contentBlocksResult.value;
  }

  // Validate variables if provided
  if (updateProps.variables !== undefined) {
    const variablesResult = TemplateVariables.from(updateProps.variables);
    if (!variablesResult.ok) {
      return err(
        withContext(variablesResult.error, {
          operation: 'update_template_variables_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedVariables: updateProps.variables,
        }),
      );
    }
    validatedFields.variables = variablesResult.value;
  }

  // Validate samplePayload if provided
  if (updateProps.samplePayload !== undefined) {
    const samplePayloadResult = TemplateSamplePayload.from(
      updateProps.samplePayload,
    );
    if (!samplePayloadResult.ok) {
      return err(
        withContext(samplePayloadResult.error, {
          operation: 'update_template_sample_payload_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedSamplePayload: updateProps.samplePayload,
        }),
      );
    }
    validatedFields.samplePayload = samplePayloadResult.value;
  }

  // Validate enabled if provided
  if (updateProps.enabled !== undefined) {
    const enabledResult = TemplateEnabled.from(updateProps.enabled);
    if (!enabledResult.ok) {
      return err(
        withContext(enabledResult.error, {
          operation: 'update_template_enabled_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedEnabled: updateProps.enabled,
        }),
      );
    }
    validatedFields.enabled = enabledResult.value;
  }

  // 3. Apply all validated changes in single atomic operation
  const batchUpdateResult = existingAggregate.updateBatch(validatedFields);
  if (!batchUpdateResult.ok) {
    return err(
      withContext(batchUpdateResult.error, {
        operation: 'update_product_batch_application',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        fieldsUpdated: Object.keys(validatedFields),
      }),
    );
  }

  return ok(existingAggregate);
}
