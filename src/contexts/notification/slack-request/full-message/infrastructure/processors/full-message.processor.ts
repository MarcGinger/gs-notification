// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import {
  Injectable,
  OnModuleInit,
  OnModuleDestroy,
  Inject,
} from '@nestjs/common';
import { APP_LOGGER, Log, Logger, componentLogger } from 'src/shared/logging';
import { Worker, Job } from 'bullmq';
import { Redis } from 'ioredis';
import { FullMessageApplicationService } from '../../application/services';
import { CreateFullMessageRequest } from '../../application/dtos';
import { FullMessageErrors } from '../../domain/errors';
import { withContext } from 'src/shared/errors';
import { IUserToken } from 'src/shared/security';
import { AppConfigUtil } from 'src/shared/config/app-config.util';
import {
  SendFullMessageWorkerService,
  FullMessageTemplateAdapter,
  SendFullMessageJob,
} from '../services';
import { SlackApiService } from 'src/shared/infrastructure/slack/slack-api.service';
import { SLACK_REQUEST_DI_TOKENS } from '../../../slack-request.constants';
import {
  FULL_MESSAGE_QUERY_TOKEN,
  FULL_MESSAGE_WRITER_TOKEN,
} from '../../application/ports';
import { IFullMessageQuery, IFullMessageWriter } from '../../application/ports';
import {
  IFullMessageAppPort,
  FULL_MESSAGE_APP_PORT,
} from '../../application/ports/full-message-app.port';
import { DetailWorkspaceResponse } from 'src/contexts/notification/slack-request/workspace/application/dtos';
import { DetailTemplateResponse } from 'src/contexts/notification/slack-request/template/application/dtos';
import { DetailChannelResponse } from 'src/contexts/notification/slack-request/channel/application/dtos';
import { DetailAppConfigResponse } from 'src/contexts/notification/slack-request/app-config/application/dtos';
import { ActorContext } from 'src/shared/application/context';
import { Option } from 'src/shared/domain/types';

/**
 * FullMessage Queue Job Types
 */
export interface FullMessageJobs {
  'create-full-message': {
    user: IUserToken;
    request: CreateFullMessageRequest;
    options?: {
      idempotencyKey?: string;
    };
  };
  'send-full-message': {
    fullMessageId: string;
    tenant: string;
    threadTs?: string | null;
    tenantConfig?: {
      workspace: DetailWorkspaceResponse;
      template?: DetailTemplateResponse;
      channel?: DetailChannelResponse;
      appConfig?: DetailAppConfigResponse;
    };
  };
  'retry-failed-full-message': {
    fullMessageId: string;
    tenant: string;
    retryReason: string;
  };
}

/**
 * FullMessage Queue Processor
 *
 * Handles asynchronous processing of fullMessage operations:
 * - Creating fullMessages
 * - Sending messages via Slack API
 * - Retrying failed operations
 *
 * Uses BullMQ for reliable job processing with:
 * - Exponential backoff for retries
 * - Job persistence in Redis
 * - Comprehensive logging and monitoring
 */
@Injectable()
export class FullMessageProcessor implements OnModuleInit, OnModuleDestroy {
  private readonly logger: Logger;
  private worker: Worker | null = null;

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    private readonly fullMessageService: FullMessageApplicationService,
    private readonly slackApiService: SlackApiService,
    private readonly templateAdapter: FullMessageTemplateAdapter,
    @Inject(FULL_MESSAGE_QUERY_TOKEN)
    private readonly fullMessageQuery: IFullMessageQuery,
    @Inject(FULL_MESSAGE_WRITER_TOKEN)
    private readonly fullMessageWriter: IFullMessageWriter,
    @Inject(FULL_MESSAGE_APP_PORT)
    private readonly fullMessageAppPort: IFullMessageAppPort,
    @Inject(SLACK_REQUEST_DI_TOKENS.IO_REDIS)
    private readonly redis: Redis,
    private readonly sendFullMessageWorkerService: SendFullMessageWorkerService,
  ) {
    this.logger = componentLogger(baseLogger, 'FullMessageProcessor');
  }

  /**
   * Initialize the BullMQ worker to process jobs
   */
  onModuleInit(): void {
    const redisConfig = AppConfigUtil.getRedisConfig();
    const environment = AppConfigUtil.getEnvironment();

    // Create the worker with the same configuration as the queue
    this.worker = new Worker(
      'FullMessageQueue',
      async (job: Job) => {
        Log.info(this.logger, 'Processing job', {
          method: 'onModuleInit.worker',
          jobId: job.id,
          jobName: job.name,
          attempts: job.attemptsMade,
        });

        try {
          // Route to appropriate handler based on job name
          switch (job.name) {
            case 'create-full-message':
              return await this.handleCreateFullMessage(
                job as Job<FullMessageJobs['create-full-message']>,
              );
            case 'send-full-message':
              return await this.handleSendFullMessage(
                job as Job<FullMessageJobs['send-full-message']>,
              );
            case 'SendFullMessageJob':
              return await this.handleSendFullMessageJob(
                job as Job<SendFullMessageJob>,
              );
            case 'retry-failed-full-message':
              return await this.handleRetryFailedFullMessage(
                job as Job<FullMessageJobs['retry-failed-full-message']>,
              );
            default:
              throw new Error(
                withContext(FullMessageErrors.INVALID_DATA, {
                  operation: 'job_processing',
                  id: job.id || 'unknown',
                  reason: `Unknown job type: ${job.name}`,
                }).detail,
                { cause: new Error(`Unknown job type: ${job.name}`) },
              );
          }
        } catch (error) {
          const e = error as Error;
          Log.error(this.logger, 'Job processing failed', {
            method: 'onModuleInit.worker',
            jobId: job.id,
            jobName: job.name,
            error: e.message,
            stack: e.stack,
          });
          throw error; // Re-throw to trigger BullMQ retry logic
        }
      },
      {
        connection: {
          host: redisConfig.host,
          port: redisConfig.port,
          db: redisConfig.database,
        },
        prefix: `${environment}:full-message:`,
        concurrency: 4, // Process up to 4 jobs concurrently (optimal for Slack API)
        limiter: {
          max: 10,
          duration: 60000, // 10 jobs per minute rate limiting
        },
      },
    );

    // Add event listeners for monitoring
    this.worker.on('completed', (job) => {
      Log.info(this.logger, 'Job completed successfully', {
        method: 'worker.completed',
        jobId: job.id,
        jobName: job.name,
        processingTime: job.finishedOn
          ? job.finishedOn - job.processedOn!
          : 'unknown',
      });
    });

    this.worker.on('failed', (job, err) => {
      Log.error(this.logger, 'Job failed', {
        method: 'worker.failed',
        jobId: job?.id,
        jobName: job?.name,
        attempts: job?.attemptsMade,
        error: err.message,
      });
    });

    this.worker.on('error', (err) => {
      Log.error(this.logger, 'Worker error', {
        method: 'worker.error',
        error: err.message,
        stack: err.stack,
      });
    });

    Log.info(this.logger, 'FullMessageProcessor worker started', {
      method: 'onModuleInit',
      queueName: 'FullMessageQueue',
      concurrency: 5,
      prefix: `${environment}:full-message:`,
    });
  }

  /**
   * Clean up the worker on module destroy
   */
  async onModuleDestroy(): Promise<void> {
    if (this.worker) {
      Log.info(this.logger, 'Stopping FullMessageProcessor worker', {
        method: 'onModuleDestroy',
      });

      await this.worker.close();
      this.worker = null;

      Log.info(this.logger, 'FullMessageProcessor worker stopped', {
        method: 'onModuleDestroy',
      });
    }
  }

  /**
   * Process fullMessage creation jobs
   */
  async handleCreateFullMessage(
    job: Job<FullMessageJobs['create-full-message']>,
  ): Promise<void> {
    const { user, request, options } = job.data;
    const jobId = job.id;

    Log.info(this.logger, 'Processing create fullMessage job', {
      method: 'handleCreateFullMessage',
      jobId,
      tenant: user.tenant,
      workspaceCode: request.workspaceCode,
      templateCode: request.templateCode,
      channelCode: request.channelCode,
      idempotencyKey: options?.idempotencyKey,
    });

    try {
      const result = await this.fullMessageService.createFullMessage(
        user,
        request,
        options,
      );

      if (!result.ok) {
        Log.error(this.logger, 'Failed to create fullMessage in job', {
          method: 'handleCreateFullMessage',
          jobId,
          error: result.error.detail,
          context: result.error.context,
        });
        throw new Error(result.error.detail);
      }

      Log.info(this.logger, 'Successfully created fullMessage in job', {
        method: 'handleCreateFullMessage',
        jobId,
        fullMessageId: result.value.id,
        status: result.value.status,
      });

      // Optionally trigger next job in the pipeline (send message)
      if (result.value.status === 'validated') {
        // Could add job to send the message
        Log.debug(this.logger, 'FullMessage ready for sending', {
          method: 'handleCreateFullMessage',
          jobId,
          fullMessageId: result.value.id,
          nextStep: 'send-full-message',
        });
      }
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing create fullMessage job', {
        method: 'handleCreateFullMessage',
        jobId,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }

  /**
   * Process message sending jobs with tenant configuration and Slack API integration
   * Implements idempotency guards and internal retry logic with status updates
   */
  async handleSendFullMessage(
    job: Job<FullMessageJobs['send-full-message']>,
  ): Promise<void> {
    const { fullMessageId, tenant, tenantConfig } = job.data;
    const jobId = job.id;
    const actor: ActorContext = {
      tenant,
      userId: 'system',
      tenant_userId: 'system',
    };

    Log.info(this.logger, 'Processing send fullMessage job', {
      method: 'handleSendFullMessage',
      jobId,
      fullMessageId,
      tenant,
      hasConfig: !!tenantConfig,
    });

    // 1. Idempotency guard - prevent duplicate processing
    const isFirstTime = await this.checkIdempotency(tenant, fullMessageId);
    if (!isFirstTime) {
      Log.info(this.logger, 'Skipping duplicate send (idempotency)', {
        method: 'handleSendFullMessage',
        fullMessageId,
        tenant,
        jobId,
      });
      return;
    }

    try {
      // 2. Fetch fullMessage details
      const requestResult = await this.fullMessageQuery.findById(
        actor,
        fullMessageId,
      );
      if (!requestResult.ok || !requestResult.value) {
        return await this.fail(fullMessageId, tenant, 'request_not_found');
      }

      const request = requestResult.value;

      // Safely extract data from the request (handle Option type)
      const requestData = Option.isSome(request)
        ? (request.value.data ?? {})
        : {};
      const recipient = Option.isSome(request)
        ? request.value.recipient
        : undefined;

      // 3. Extract tenant configuration
      const { workspace, template, channel, appConfig } = tenantConfig || {};
      if (!workspace?.botToken) {
        return await this.fail(fullMessageId, tenant, 'bot_token_missing');
      }

      // Use channel code (assuming it's the Slack channel ID) or fallback to recipient
      const channelId =
        channel?.code || recipient || workspace.defaultChannelId;
      if (!channelId) {
        return await this.fail(fullMessageId, tenant, 'channel_missing');
      }

      // 4. Render message template
      let renderedBlocks: unknown[];
      if (template) {
        Log.debug(this.logger, 'Rendering template', {
          method: 'handleSendFullMessage',
          fullMessageId,
          tenant,
          templateCode: template.code,
          templateName: template.name,
          hasContentBlocks: Array.isArray(template.contentBlocks),
          contentBlocksCount: template.contentBlocks?.length ?? 0,
          requiredVariables: template.variables ?? [],
          providedVariables: Object.keys(requestData),
        });

        const renderRes = this.templateAdapter.renderTemplate({
          template,
          variables: requestData,
        });
        if (!renderRes.ok) {
          Log.error(this.logger, 'Template rendering failed', {
            method: 'handleSendFullMessage',
            fullMessageId,
            tenant,
            templateCode: template.code,
            renderError: renderRes.error,
            contentBlocks: template.contentBlocks,
            variables: requestData,
          });

          // Fallback to default message instead of failing completely
          Log.info(
            this.logger,
            'Using fallback message due to template error',
            {
              method: 'handleSendFullMessage',
              fullMessageId,
              tenant,
            },
          );

          renderedBlocks = [
            {
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: `⚠️ Message from ${workspace.name} (template error: ${renderRes.error})`,
              },
            },
          ];
        } else {
          renderedBlocks = Array.isArray(renderRes.value)
            ? renderRes.value
            : [renderRes.value];

          Log.debug(this.logger, 'Template rendered successfully', {
            method: 'handleSendFullMessage',
            fullMessageId,
            tenant,
            renderedBlocksCount: Array.isArray(renderedBlocks)
              ? renderedBlocks.length
              : 1,
          });
        }
      } else {
        // Default message block if no template
        renderedBlocks = [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `Message from ${workspace.name}`,
            },
          },
        ];

        Log.debug(this.logger, 'Using default message (no template)', {
          method: 'handleSendFullMessage',
          fullMessageId,
          tenant,
        });
      }

      // 5. Send via Slack API with internal retry logic (no BullMQ retries)
      const maxAttempts = appConfig?.maxRetryAttempts ?? 3;
      const baseBackoff = appConfig?.retryBackoffSeconds ?? 2;

      let attempt = 0;
      let lastErr: string | undefined;

      while (attempt < maxAttempts) {
        attempt++;

        Log.debug(this.logger, 'Attempting Slack API send', {
          method: 'handleSendFullMessage',
          fullMessageId,
          tenant,
          workspaceCode: workspace.code,
          workspaceName: workspace.name,
          channelId,
          templateCode: template?.code,
          attempt,
          maxAttempts,
          jobId,
        });

        const res = await this.slackApiService.sendMessage({
          botToken: workspace.botToken,
          channel: channelId,
          blocks: renderedBlocks,
          text: `Message from ${workspace.name}`,
          thread_ts: job.data.threadTs || null,
        });

        if (res.ok) {
          // Success - record delivery through application port
          await this.fullMessageAppPort.recordSent({
            id: fullMessageId,
            attempts: attempt,
            // Note: correlationId, causationId, and actor not available in send-full-message job data
            // Future: Could be passed through from create-full-message job
          });

          Log.info(this.logger, 'FullMessage sent successfully', {
            method: 'handleSendFullMessage',
            jobId,
            fullMessageId,
            tenant,
            slackTs: res.value.ts,
            slackChannel: res.value.channel,
            attempts: attempt,
          });
          return;
        }

        lastErr = res.error;
        if (!res.retryable) break; // Don't retry non-retryable errors

        // Wait with exponential backoff (honor Slack's Retry-After if present)
        const delay =
          (res.retryAfterSec ?? baseBackoff * Math.pow(2, attempt)) * 1000;
        await this.sleepWithJitter(delay);
      }

      // Final failure after all internal attempts (no BullMQ retry)
      // Record failure through application port
      await this.fullMessageAppPort.recordFailed({
        id: fullMessageId,
        reason: 'max_attempts_exceeded',
        attempts: attempt,
        retryable: false,
        lastError: lastErr || 'Unknown error after max attempts',
      });

      Log.error(this.logger, 'FullMessage failed after attempts', {
        method: 'handleSendFullMessage',
        jobId,
        fullMessageId,
        tenant,
        lastError: lastErr,
        attempts: attempt,
      });

      return; // Don't throw - avoid BullMQ retry
    } catch (error) {
      const e = error as Error;

      // Record failure through application port
      await this.fullMessageAppPort.recordFailed({
        id: fullMessageId,
        reason: 'unexpected_error',
        attempts: 1, // This is an unexpected error, not a retry
        retryable: false,
        lastError: e.message,
      });

      Log.error(this.logger, 'Error processing send fullMessage job', {
        method: 'handleSendFullMessage',
        jobId,
        fullMessageId,
        tenant,
        error: e.message,
        stack: e.stack,
      });

      return; // Don't throw - avoid BullMQ retry
    }
  }

  /**
   * Sleep with jitter to avoid thundering herd problems
   */
  private async sleepWithJitter(ms: number): Promise<void> {
    await new Promise((r) =>
      setTimeout(r, Math.floor(ms * (0.8 + Math.random() * 0.4))),
    );
  }

  /**
   * Check idempotency guard to prevent duplicate processing
   * @param tenant - The tenant ID
   * @param fullMessageId - The fullMessage ID
   * @returns Promise<boolean> - true if this is the first time processing, false if already processed
   */
  private async checkIdempotency(
    tenant: string,
    fullMessageId: string,
  ): Promise<boolean> {
    const idemKey = `idem:slack:send:${tenant}:${fullMessageId}`;
    try {
      const result = await this.redis.set(idemKey, '1', 'EX', 900, 'NX'); // 15 minutes, only if not exists
      return result === 'OK';
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Failed to check idempotency', {
        method: 'checkIdempotency',
        fullMessageId,
        tenant,
        error: e.message,
      });
      // On Redis error, allow processing (fail-open approach)
      return true;
    }
  }

  private async fail(
    fullMessageId: string,
    tenant: string,
    code: string,
  ): Promise<void> {
    // Record failure through application port
    await this.fullMessageAppPort.recordFailed({
      id: fullMessageId,
      reason: code,
      attempts: 1,
      retryable: false,
      lastError: `Validation failure: ${code}`,
    });

    Log.error(this.logger, 'FullMessage failed', {
      method: 'handleSendFullMessage',
      fullMessageId,
      reason: code,
    });

    // Don't throw to avoid BullMQ retries - internal retry logic handles retries
  }

  /**
   * Process retry jobs for failed fullMessages
   */
  async handleRetryFailedFullMessage(
    job: Job<FullMessageJobs['retry-failed-full-message']>,
  ): Promise<void> {
    const { fullMessageId, tenant, retryReason } = job.data;
    const jobId = job.id;

    Log.info(this.logger, 'Processing retry failed fullMessage job', {
      method: 'handleRetryFailedFullMessage',
      jobId,
      fullMessageId,
      tenant,
      retryReason,
    });

    try {
      // This would implement retry logic for failed fullMessages
      await new Promise((resolve) => setTimeout(resolve, 100)); // Simulate async work

      Log.info(this.logger, 'Retried failed fullMessage successfully', {
        method: 'handleRetryFailedFullMessage',
        jobId,
        fullMessageId,
        retryReason,
        status: 'retried',
      });

      // In a real implementation:
      // 1. Fetch failed fullMessage
      // 2. Determine retry strategy based on failure reason
      // 3. Re-queue for sending or mark as permanently failed
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing retry fullMessage job', {
        method: 'handleRetryFailedFullMessage',
        jobId,
        fullMessageId,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }

  /**
   * Process SendFullMessageJob using the dedicated worker service
   */
  async handleSendFullMessageJob(job: Job<SendFullMessageJob>): Promise<void> {
    Log.info(this.logger, 'Processing SendFullMessageJob', {
      method: 'handleSendFullMessageJob',
      jobId: job.id,
      fullMessageId: job.data.fullMessageId,
      tenant: job.data.tenant,
    });

    try {
      // Delegate to the specialized SendFullMessageWorkerService
      await this.sendFullMessageWorkerService.processJob(job);

      Log.info(this.logger, 'Successfully processed SendFullMessageJob', {
        method: 'handleSendFullMessageJob',
        jobId: job.id,
        fullMessageId: job.data.fullMessageId,
      });
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing SendFullMessageJob', {
        method: 'handleSendFullMessageJob',
        jobId: job.id,
        fullMessageId: job.data.fullMessageId,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }
}
