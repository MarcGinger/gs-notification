// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

/**
 * FullMessage Application Service
 *
 * Application-layer service that coordinates authorization with business operations.
 */

// Framework imports
import { Inject, Injectable } from '@nestjs/common';

// Shared utilities and infrastructure
import { APP_LOGGER, Log, componentLogger, Logger } from 'src/shared/logging';
import { Result, DomainError, err, ok, withContext } from 'src/shared/errors';
import type { IUserToken } from 'src/shared/security';
import { createSystemUserToken } from 'src/shared/security';
import { CorrelationUtil } from 'src/shared/utilities/correlation.util';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';

// Service configuration
import { SlackRequestServiceConstants } from '../../../service-constants';

// Domain types and errors
import { FullMessageErrors } from '../../domain/errors/full-message.errors';
import type { CreateFullMessageProps } from '../../domain/props';
import {
  DetailFullMessageResponse,
  ListFullMessageFilterRequest,
  FullMessagePageResponse,
} from '../dtos';

// Application layer
import { FullMessageAuthorizationService } from './full-message-authorization.service';
import { FullMessageAuthContext } from '../types/full-message-auth-context';

// Use case contracts
import {
  ICreateFullMessageUseCase,
  IGetFullMessageUseCase,
  IListFullMessageUseCase,
  ISentFullMessageUseCase,
  IFailedFullMessageUseCase,
} from '../use-cases/contracts';
import { IFullMessageAppPort } from '../ports/full-message-app.port';

/**
 * Application Service for FullMessage operations with integrated authorization
 * Also implements IFullMessageAppPort for infrastructure compatibility
 */
@Injectable()
export class FullMessageApplicationService implements IFullMessageAppPort {
  private readonly logger: Logger;

  constructor(
    private readonly fullMessageAuthorizationService: FullMessageAuthorizationService,
    private readonly createFullMessageUseCase: ICreateFullMessageUseCase,
    private readonly getFullMessageUseCase: IGetFullMessageUseCase,
    private readonly listFullMessageUseCase: IListFullMessageUseCase,
    private readonly recordSentUseCase: ISentFullMessageUseCase,
    private readonly recordFailedUseCase: IFailedFullMessageUseCase,
    @Inject(CLOCK) private readonly clock: Clock,
    @Inject(APP_LOGGER) moduleLogger: Logger,
  ) {
    this.logger = componentLogger(
      moduleLogger,
      'FullMessageApplicationService',
    );
  }

  /**
   * Helper to create FullMessageAuthContext from user token
   */
  private createAuthContext(
    user: IUserToken,
    operation: string,
  ): FullMessageAuthContext {
    return {
      tenant: user.tenant,
      tenant_userId: user.tenant_id || '',
      roles: user.roles || [],
      operationType: operation,
      metadata: {
        userId: user.sub,
        timestamp: this.clock.nowIso(),
      },
    };
  }

  /**
   * Helper to create consistent logging context
   */
  private createLogContext(
    operation: string,
    correlationId: string,
    userId: string,
    additionalContext?: Record<string, unknown>,
  ): Record<string, unknown> {
    return {
      serviceName: SlackRequestServiceConstants.SERVICE_NAME,
      component: 'FullMessageApplicationService',
      operation,
      correlationId,
      userId,
      ...additionalContext,
    };
  }

  /**
   * Helper to validate required id input
   */
  private validateId(
    id: string,
    operation: string,
    correlationId?: string,
  ): Result<string, DomainError> {
    if (!id?.trim()) {
      return err(
        withContext(FullMessageErrors.INVALID_FULL_MESSAGE_DATA, {
          operation,
          correlationId:
            correlationId ||
            CorrelationUtil.generateForOperation(`full-message-${operation}`),
        }),
      );
    }
    return ok(id.trim());
  }

  /**
   * Centralized auth → log → execute → catch pattern
   */
  private async authorizeThenExecute<T>(args: {
    operation: 'create' | 'update' | 'read';
    user: IUserToken;
    id?: string;
    correlationIdPrefix: string;
    doAuthorize: () => Promise<Result<boolean, DomainError>>;
    doExecute: () => Promise<Result<T, DomainError>>;
    logContext?: Record<string, unknown>;
  }): Promise<Result<T, DomainError>> {
    const corrId = CorrelationUtil.generateForOperation(
      args.correlationIdPrefix,
    );
    const ctx = {
      ...this.createLogContext(
        `${args.operation}_full_message`,
        corrId,
        args.user.sub,
        args.logContext,
      ),
    };

    const auth = await args.doAuthorize();
    if (!auth.ok) {
      Log.warn(this.logger, `${args.operation} authorization failed`, {
        ...ctx,
        authDecision: 'deny',
      });
      return err(auth.error);
    }
    if (!auth.value) {
      Log.warn(this.logger, `${args.operation} permission denied`, {
        ...ctx,
        authDecision: 'deny',
      });
      return err(
        withContext(FullMessageErrors.PERMISSION_DENIED, {
          correlationId: corrId,
          userId: args.user.sub,
          operation: args.operation,
          id: args.id,
          category: 'security',
        }),
      );
    }

    Log.info(this.logger, `FullMessage ${args.operation} authorized`, {
      ...ctx,
      authDecision: 'allow',
    });

    try {
      return await args.doExecute();
    } catch (error) {
      Log.error(this.logger, `FullMessage ${args.operation} use case failed`, {
        ...ctx,
        error: error instanceof Error ? error.message : String(error),
      });
      return err({
        code: `DOMAIN.FULL_MESSAGE.${args.operation.toUpperCase()}_FAILED`,
        title: `FullMessage ${args.operation} failed`,
        detail: error instanceof Error ? error.message : 'Unknown error',
        category: 'application',
        context: {
          correlationId: corrId,
          id: args.id,
          operation: `${args.operation}_full_message`,
        },
      });
    }
  }

  /**
   * Create a new fullMessage with authorization
   */
  async createFullMessage(
    user: IUserToken,
    props: CreateFullMessageProps,
    options?: { idempotencyKey?: string; correlationId?: string },
  ): Promise<Result<DetailFullMessageResponse, DomainError>> {
    const authContext = this.createAuthContext(user, 'create');
    const correlationId =
      options?.correlationId ||
      CorrelationUtil.generateForOperation('full-message-create');

    return this.authorizeThenExecute<DetailFullMessageResponse>({
      operation: 'create',
      user,
      correlationIdPrefix: 'full-message-create',
      doAuthorize: () =>
        this.fullMessageAuthorizationService.canCreateFullMessage(
          user.sub,
          correlationId,
          authContext,
        ),
      doExecute: () =>
        this.createFullMessageUseCase.execute({
          user,
          props,
          correlationId,
          authorizationReason: 'create_full_message',
          ...(options?.idempotencyKey && {
            idempotencyKey: options.idempotencyKey,
          }),
        }),
    });
  }

  /**
   * Get a fullMessage by ID with authorization
   */
  async getFullMessageById(
    user: IUserToken,
    id: string,
  ): Promise<Result<DetailFullMessageResponse, DomainError>> {
    // Early input validation
    const idValidation = this.validateId(id, 'read');
    if (!idValidation.ok) {
      return err(idValidation.error);
    }

    const validatedid = idValidation.value;
    const authContext = this.createAuthContext(user, 'read');

    return this.authorizeThenExecute<DetailFullMessageResponse>({
      operation: 'read',
      user,
      id: validatedid,
      correlationIdPrefix: 'full-message-read',
      doAuthorize: () =>
        this.fullMessageAuthorizationService.canReadFullMessage(
          user.sub,
          validatedid,
          CorrelationUtil.generateForOperation('full-message-read'),
          authContext,
        ),
      doExecute: () =>
        this.getFullMessageUseCase.execute({
          user,
          id: validatedid,
          correlationId:
            CorrelationUtil.generateForOperation('full-message-read'),
        }),
      logContext: { id: validatedid },
    });
  }

  /**
   * List fullMessages with authorization and pagination
   */
  async listFullMessages(
    user: IUserToken,
    filter?: ListFullMessageFilterRequest,
  ): Promise<Result<FullMessagePageResponse, DomainError>> {
    const authContext = this.createAuthContext(user, 'list');
    const correlationId =
      CorrelationUtil.generateForOperation('full-message-list');

    // Ensure we always have a proper filter object
    const safeFilter = filter || new ListFullMessageFilterRequest();

    return this.authorizeThenExecute<FullMessagePageResponse>({
      operation: 'read', // List is a form of read operation
      user,
      correlationIdPrefix: 'full-message-list',
      doAuthorize: () =>
        this.fullMessageAuthorizationService.canReadFullMessage(
          user.sub,
          'list', // Use 'list' as a special id for list operations
          correlationId,
          authContext,
        ),
      doExecute: () =>
        this.listFullMessageUseCase.execute({
          user,
          filter: safeFilter,
          correlationId,
        }),
      logContext: {
        operation: 'list_full_messages',
        pageSize: safeFilter.size,
        page: safeFilter.page,
      },
    });
  }
  /**
   * Record successful message delivery (System operation)
   */
  async FullMessageSent(input: {
    id: string;
    attempts: number;
    tenant?: string;
    correlationId?: string;
    causationId?: string;
  }): Promise<Result<DetailFullMessageResponse, DomainError>> {
    const correlationId =
      input.correlationId ||
      CorrelationUtil.generateForOperation('full-message-record-sent');

    const ctx = this.createLogContext(
      'record_full_message_sent',
      correlationId,
      'system',
      {
        fullMessageId: input.id,
        attempts: input.attempts,
      },
    );

    Log.info(this.logger, 'Recording successful message delivery', ctx);

    try {
      const systemUserToken = createSystemUserToken(input.tenant || 'system');

      const result = await this.recordSentUseCase.execute({
        user: systemUserToken,
        props: {
          id: input.id,
          attempts: input.attempts,
          correlationId: input.correlationId,
          causationId: input.causationId,
        },
        correlationId,
        authorizationReason: 'System recording message delivery outcome',
      });

      if (result.ok) {
        Log.info(this.logger, 'Successfully recorded message delivery', {
          ...ctx,
          fullMessageId: result.value.id,
          phase: 'CleanArchitecture-UseCase',
        });
      }

      return result;
    } catch (error) {
      Log.error(this.logger, 'Failed to record message delivery', {
        ...ctx,
        error: error instanceof Error ? error.message : 'Unknown error',
      });

      return err({
        code: 'DOMAIN.FULL_MESSAGE.RECORD_SENT_FAILED',
        title: 'Failed to record message delivery',
        detail: error instanceof Error ? error.message : 'Unknown error',
        category: 'application',
        context: {
          correlationId,
          fullMessageId: input.id,
          operation: 'record_full_message_sent',
        },
      });
    }
  }

  /**
   * Record failed message delivery (System operation)
   */
  async FullMessageFailed(input: {
    id: string;
    reason: string;
    attempts: number;
    retryable?: boolean;
    lastError?: string;
    tenant?: string;
    correlationId?: string;
    causationId?: string;
  }): Promise<Result<DetailFullMessageResponse, DomainError>> {
    const correlationId =
      input.correlationId ||
      CorrelationUtil.generateForOperation('full-message-record-failed');

    const ctx = this.createLogContext(
      'record_full_message_failed',
      correlationId,
      'system',
      {
        fullMessageId: input.id,
        reason: input.reason,
        attempts: input.attempts,
        retryable: input.retryable,
      },
    );

    Log.info(this.logger, 'Recording failed message delivery', ctx);

    try {
      const systemUserToken = createSystemUserToken(input.tenant || 'system');

      const result = await this.recordFailedUseCase.execute({
        user: systemUserToken,
        props: {
          id: input.id,
          reason: input.reason,
          attempts: input.attempts,
          retryable: input.retryable,
          lastError: input.lastError,
          correlationId: input.correlationId,
          causationId: input.causationId,
        },
        correlationId,
        authorizationReason: 'System recording message delivery failure',
      });

      if (result.ok) {
        Log.info(this.logger, 'Successfully recorded message failure', {
          ...ctx,
          fullMessageId: result.value.id,
          phase: 'CleanArchitecture-UseCase',
        });
      }

      return result;
    } catch (error) {
      Log.error(this.logger, 'Failed to record message failure', {
        ...ctx,
        error: error instanceof Error ? error.message : 'Unknown error',
      });

      return err({
        code: 'DOMAIN.FULL_MESSAGE.RECORD_FAILED_FAILED',
        title: 'Failed to record message failure',
        detail: error instanceof Error ? error.message : 'Unknown error',
        category: 'application',
        context: {
          correlationId,
          fullMessageId: input.id,
          operation: 'record_full_message_failed',
        },
      });
    }
  }

  // IFullMessageAppPort implementation (infrastructure compatibility)

  /**
   * Record successful message delivery (Infrastructure interface)
   * Throws on failure for infrastructure compatibility
   */
  async recordSent(input: {
    id: string;
    attempts: number;
    tenant?: string;
    correlationId?: string;
    causationId?: string;
  }): Promise<void> {
    const result = await this.FullMessageSent(input);
    if (!result.ok) {
      throw new Error(`Failed to record message sent: ${result.error.detail}`);
    }
  }

  /**
   * Record failed message delivery (Infrastructure interface)
   * Throws on failure for infrastructure compatibility
   */
  async recordFailed(input: {
    id: string;
    reason: string;
    attempts: number;
    retryable?: boolean;
    lastError?: string;
    tenant?: string;
    correlationId?: string;
    causationId?: string;
  }): Promise<void> {
    const result = await this.FullMessageFailed(input);
    if (!result.ok) {
      throw new Error(
        `Failed to record message failed: ${result.error.detail}`,
      );
    }
  }
}
