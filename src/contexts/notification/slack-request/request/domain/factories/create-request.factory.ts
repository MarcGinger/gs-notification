// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, withContext, ok } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { RequestAggregate } from '../aggregates';
import { CreateRequestProps } from '../props';
import { RequestDomainState } from '../state';
import {
  RequestCreatedAt,
  RequestUpdatedAt,
  RequestVersion,
  RequestCode,
  RequestRecipient,
  RequestData,
  createRequestStatus,
  RequestWorkspaceCode,
  RequestTemplateCode,
  RequestChannelCode,
} from '../value-objects';

/**
 * Enhanced request entity factory with comprehensive validation and security context
 * Moved from application layer to properly separate business concerns
 */
export function createRequestAggregateFromProps(
  props: CreateRequestProps,
  metadata: EventMetadata,
  clock: Clock,
  // validatedEntities?: {
  //  channels?: ChannelReference[];
  // },
): Result<RequestAggregate, DomainError> {
  // Validate each property by creating value objects
  // Generate a validate identity column UUID
  const codeResult = RequestCode.generate();
  if (!codeResult.ok) {
    return err(
      withContext(codeResult.error, {
        ...codeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_request',
      }),
    );
  }

  const recipientResult = RequestRecipient.from(props.recipient);
  if (!recipientResult.ok) {
    return err(
      withContext(recipientResult.error, {
        ...recipientResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_request',
        recipient: props.recipient,
      }),
    );
  }

  const dataResult = RequestData.from(props.data);
  if (!dataResult.ok) {
    return err(
      withContext(dataResult.error, {
        ...dataResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_request',
        data: props.data,
      }),
    );
  }

  const statusResult = createRequestStatus('requested');
  if (!statusResult.ok) {
    return err(
      withContext(statusResult.error, {
        ...statusResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_request',
        status: 'requested',
      }),
    );
  }

  const workspaceCodeResult = RequestWorkspaceCode.from(props.workspaceCode);
  if (!workspaceCodeResult.ok) {
    return err(
      withContext(workspaceCodeResult.error, {
        ...workspaceCodeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_request',
        workspaceCode: props.workspaceCode,
      }),
    );
  }

  const templateCodeResult = RequestTemplateCode.from(props.templateCode);
  if (!templateCodeResult.ok) {
    return err(
      withContext(templateCodeResult.error, {
        ...templateCodeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_request',
        templateCode: props.templateCode,
      }),
    );
  }

  const channelCodeResult = RequestChannelCode.from(props.channelCode);
  if (!channelCodeResult.ok) {
    return err(
      withContext(channelCodeResult.error, {
        ...channelCodeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_request',
        channelCode: props.channelCode,
      }),
    );
  }

  const createdAtResult = RequestCreatedAt.create(clock.now());
  if (!createdAtResult.ok) {
    return err(createdAtResult.error);
  }

  const updatedAtResult = RequestUpdatedAt.create(clock.now());
  if (!updatedAtResult.ok) {
    return err(updatedAtResult.error);
  }

  const versionResult = RequestVersion.create(1); // Initial version is 1
  if (!versionResult.ok) {
    return err(versionResult.error);
  }

  // Create the entity properties with validated value objects
  const entityProps: RequestDomainState = {
    code: codeResult.value,
    recipient: recipientResult.value,
    data: dataResult.value,
    status: statusResult.value,
    workspaceCode: workspaceCodeResult.value,
    templateCode: templateCodeResult.value,
    channelCode: channelCodeResult.value,
    createdAt: createdAtResult.value,
    updatedAt: updatedAtResult.value,
    version: versionResult.value,
  };

  // Create the entity using the constructor
  return RequestAggregate.create(entityProps, clock, metadata);
}
