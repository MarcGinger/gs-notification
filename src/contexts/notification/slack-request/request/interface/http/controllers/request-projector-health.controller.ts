// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Request Projector Health Controller
// Provides health check endpoints for the Request Projector

import { Controller, Get, Inject } from '@nestjs/common';
import { APP_LOGGER, Log, componentLogger, Logger } from 'src/shared/logging';
import { RequestProjector } from '../../../infrastructure/projectors';
import { RequestProjectionKeys } from '../../../request-projection-keys';

@Controller('health/projectors')
export class RequestProjectorHealthController {
  private readonly logger: Logger;

  constructor(
    private readonly requestProjector: RequestProjector,
    @Inject(APP_LOGGER) baseLogger: Logger,
  ) {
    this.logger = componentLogger(
      baseLogger,
      'RequestProjectorHealthController',
    );
  }

  @Get('request')
  async getRequestProjectorHealth() {
    try {
      const health = this.requestProjector.getHealthStatus();
      const checkpoint = await this.requestProjector.getCurrentCheckpoint();

      Log.debug(this.logger, 'Request projector health check', {
        isHealthy: health.isHealthy,
        isRunning: health.isRunning,
        projectorName: health.projectorName,
        hasCheckpoint: !!checkpoint,
      });

      return {
        isHealthy: health.isHealthy,
        isRunning: health.isRunning,
        projectorName: health.projectorName,
        subscriptionGroup: health.subscriptionGroup,
        eventsProcessed: health.eventsProcessed,
        lastProcessedAt: health.lastProcessedAt?.toISOString() || null,
        lastError: health.lastError,
        checkpointPosition: checkpoint,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      const e = error as Error;

      Log.error(this.logger, 'Request projector health check failed', {
        error: e.message,
        stack: e.stack,
      });

      return {
        isHealthy: false,
        isRunning: false,
        projectorName: RequestProjectionKeys.PROJECTOR_NAME,
        subscriptionGroup: RequestProjectionKeys.SUBSCRIPTION_GROUP,
        eventsProcessed: 0,
        lastProcessedAt: null,
        lastError: e.message,
        checkpointPosition: null,
        timestamp: new Date().toISOString(),
      };
    }
  }

  @Get('request/metrics')
  async getRequestProjectorMetrics() {
    try {
      const health = this.requestProjector.getHealthStatus();
      const checkpoint = await this.requestProjector.getCurrentCheckpoint();

      // This would typically integrate with your metrics system
      // For now, return basic health metrics
      return {
        projector_status: health.isHealthy ? 1 : 0,
        projector_running: health.isRunning ? 1 : 0,
        events_processed: health.eventsProcessed,
        checkpoint_position: checkpoint || '0:0',
        last_processed_at: health.lastProcessedAt?.toISOString() || null,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      const e = error as Error;

      Log.error(this.logger, 'Request projector metrics failed', {
        error: e.message,
      });

      return {
        projector_status: 0,
        projector_running: 0,
        events_processed: 0,
        checkpoint_position: '0:0',
        last_processed_at: null,
        timestamp: new Date().toISOString(),
        error: e.message,
      };
    }
  }
}
