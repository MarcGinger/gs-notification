// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Inject } from '@nestjs/common';
import { Result, DomainError, ok, err } from 'src/shared/errors';
import { ActorContext } from 'src/shared/application/context';

// Shared utilities and infrastructure
import { APP_LOGGER, componentLogger, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import {
  UseCaseLoggingUtil,
  UseCaseLoggingConfig,
} from 'src/shared/application/utils/use-case-logging.util';
import { IUserToken } from 'src/shared/security';

// Service configuration
import { SlackRequestServiceConstants } from '../../../service-constants';

// Domain types and errors
import { RequestAggregate } from '../../domain/aggregates';
import { RequestEntity } from '../../domain/entities/request.entity';
import { createRequestCode } from '../../domain/value-objects/code.vo';
import { RequestErrors } from '../../domain/errors';
import { Option } from 'src/shared/domain/types/option';
import { EventMetadata } from 'src/shared/domain/events';
import { SystemClock } from 'src/shared/infrastructure/time';

// Application layer
import {
  IRequestReader,
  IRequestWriter,
  REQUEST_READER_TOKEN,
  REQUEST_WRITER_TOKEN,
} from '../ports';
import {
  RequestForeignKeyValidatorService,
  RequestAuthorizationAdapter,
} from '../services';
import { DetailRequestResponse } from '../dtos';
import { RequestDtoAssembler } from '../assemblers';
import { IFailedRequestUseCase } from './contracts';
import { FailedRequestProps } from '../../domain/props';

// Shared compliance services
import {
  PIIClassificationService,
  PIIProtectionService,
  DataRetentionService,
} from 'src/shared/services/compliance';

@Injectable()
export class FailedRequestUseCase implements IFailedRequestUseCase {
  private readonly logger: Logger;
  private readonly loggingConfig: UseCaseLoggingConfig;

  constructor(
    @Inject(REQUEST_READER_TOKEN)
    private readonly requestReader: IRequestReader,
    @Inject(REQUEST_WRITER_TOKEN)
    private readonly requestWriter: IRequestWriter,
    private readonly foreignKeyValidator: RequestForeignKeyValidatorService,
    private readonly authorizationService: RequestAuthorizationAdapter,
    @Inject(APP_LOGGER)
    readonly moduleLogger: Logger,
    @Inject(CLOCK)
    private readonly clock: Clock,
    private readonly piiClassificationService: PIIClassificationService,
    private readonly piiProtectionService: PIIProtectionService,
    private readonly dataRetentionService: DataRetentionService,
  ) {
    this.loggingConfig = {
      serviceName: SlackRequestServiceConstants.SERVICE_NAME,
      component: 'FailedRequestUseCase',
      domain: 'slack-request',
      entityType: 'request',
    };
    this.logger = componentLogger(moduleLogger, this.loggingConfig.component);
  }
  async execute(params: {
    user: IUserToken;
    props: FailedRequestProps;
    correlationId: string;
    authorizationReason: string;
  }): Promise<Result<DetailRequestResponse, DomainError>> {
    const operation = 'record_request_failed';
    const startTime = this.clock.nowMs();

    // Create a command-like object for internal use
    const command = {
      user: params.user,
      props: params.props,
      correlationId: params.correlationId,
      authorizationReason: params.authorizationReason,
      securityContext: {
        tenant: params.user.tenant,
        userId: params.user.sub,
        roles: params.user.roles,
      },
      timestamp: this.clock.now(),
    };

    // Step 1: Validate command (before creating any log context to avoid PII logging)
    const validation = UseCaseLoggingUtil.validateCommand(
      this.logger,
      command,
      {}, // Empty context to avoid PII logging during validation
    );
    if (!validation.ok) {
      return err(validation.error);
    }

    // Step 2: Check PII compliance for input data with domain context
    const classification = this.piiClassificationService.classifyData(
      {},
      {
        domain: 'slack-request',
        tenant: command.user.tenant,
        // entityType: 'Request' // Future: for entity-level rules
      },
    );

    // Step 3: Create safe log context (no raw command that might contain PII)
    const safeLogContext = UseCaseLoggingUtil.createLogContext(
      this.loggingConfig,
      this.clock,
      operation,
      {
        correlationId: command.correlationId,
        user: command.user,
        securityContext: command.securityContext,
        timestamp: command.timestamp,
      },
      {
        operationRisk: UseCaseLoggingUtil.assessOperationRisk(operation),
        requestId: params.props.code,
        attempts: params.props.attempts,
        retryable: params.props.retryable,
      },
    );

    // Log compliance check with detailed audit trail
    UseCaseLoggingUtil.logComplianceCheck(
      this.logger,
      operation,
      safeLogContext,
      classification,
    );

    // Step 4: Execute the update operation (following adapter pattern but with better structure)
    let updateResult: Result<RequestAggregate, DomainError>;

    try {
      // Create request code value object
      const requestIdResult = createRequestCode(params.props.code);
      if (!requestIdResult.ok) {
        return err(RequestErrors.INVALID_CODE);
      }

      // Create actor context
      const actor: ActorContext = {
        tenant: params.user.tenant,
        userId: params.user.sub,
        tenant_userId: params.user.tenant_id ?? params.user.sub,
        roles: params.user.roles || [],
      };

      // Load aggregate snapshot
      const snapshotResult = await this.requestReader.findById(
        actor,
        requestIdResult.value,
      );
      if (!snapshotResult.ok) {
        return err(snapshotResult.error);
      }

      if (!snapshotResult.value || Option.isNone(snapshotResult.value)) {
        return err(RequestErrors.INVALID_CODE);
      }

      // Reconstitute entity from snapshot
      const entityResult = RequestEntity.fromSnapshot(
        snapshotResult.value.value,
      );
      if (!entityResult.ok) {
        return err(entityResult.error);
      }

      // Create event metadata
      const eventMetadata: EventMetadata = {
        correlationId: params.correlationId,
        causationId: params.props.causationId,
        actor: {
          ...actor,
          sessionId: 'record-request-failed-use-case',
        },
        service: 'notification-service',
        timestampIso: new SystemClock().nowIso(),
        eventVersion: '1.0.0',
        schemaVersion: '2023.1',
      };

      // Reconstitute aggregate from entity
      const aggregate = RequestAggregate.reconstitute(
        entityResult.value,
        new SystemClock(),
        eventMetadata,
      );

      // Apply domain operation
      const failedResult = aggregate.markFailed({
        reason: params.props.reason,
        attempts: params.props.attempts,
        retryable: params.props.retryable,
        lastError: params.props.lastError,
      });

      if (!failedResult.ok) {
        return err(failedResult.error);
      }

      // Save the updated aggregate
      const saveResult = await this.requestWriter.save(actor, aggregate);
      if (!saveResult.ok) {
        return err(saveResult.error);
      }

      updateResult = ok(aggregate);
    } catch (error) {
      return err({
        ...RequestErrors.INVALID_REQUEST_DATA,
        detail: error instanceof Error ? error.message : 'Unknown error',
      });
    }

    // Step 5: Handle errors
    if (!updateResult.ok) {
      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        updateResult.error,
        'HIGH',
      );
      return updateResult;
    }

    const aggregate = updateResult.value;

    // Step 6: Get domain state directly from aggregate (clean architecture)
    const domainState = aggregate.toDomainState();
    const dto = RequestDtoAssembler.toDetailResponse(domainState);

    // Log operation success with comprehensive metrics
    const executionTime = this.clock.nowMs() - startTime;
    UseCaseLoggingUtil.logOperationSuccess(
      this.logger,
      operation,
      safeLogContext,
      {
        executionTimeMs: executionTime,
        aggregateVersion: aggregate.version,
        eventCount: aggregate.uncommittedEvents?.length ?? 0,
        businessData: {
          requestCode: dto.code,
          reason: params.props.reason,
          failureRecorded: true,
        },
      },
    );

    return ok(dto);
  }
}
