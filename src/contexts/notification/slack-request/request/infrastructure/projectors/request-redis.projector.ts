// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Request Projector - ESDB to Redis Projection
// Refactored to use shared projection infrastructure with Redis backend

import {
  Injectable,
  Inject,
  OnModuleInit,
  OnModuleDestroy,
} from '@nestjs/common';
import Redis from 'ioredis';
import {
  CatchUpRunner,
  ProjectionEvent,
  RunOptions,
} from 'src/shared/infrastructure/projections/catchup.runner';
import { CheckpointStore } from 'src/shared/infrastructure/projections/checkpoint.store';
import { BaseProjector } from 'src/shared/infrastructure/projections/base.projector';
import {
  CommonProjectorErrorDefinitions,
  createProjectorErrorCatalog,
  TenantExtractor,
} from 'src/shared/infrastructure/projections/projection.utils';
// ✅ Import requestion-ready shared utilities
import { registerRedisScripts } from 'src/shared/infrastructure/projections/redis-scripts';
import {
  CacheOptimizationUtils,
  CacheMetricsCollector,
} from 'src/shared/infrastructure/projections/cache-optimization';
import { RedisPipelineBuilder } from 'src/shared/infrastructure/projections/redis-pipeline-builder';
import { RedisClusterUtils } from 'src/shared/infrastructure/projections/redis-scripts';
import { ProjectionOutcome } from 'src/shared/infrastructure/projections/event-pipeline-processor';
import { APP_LOGGER, Log, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import { withContext } from 'src/shared/errors';
import { CacheService } from 'src/shared/application/caching/cache.service';
import { SLACK_REQUEST_DI_TOKENS } from '../../../slack-request.constants';
import { NotificationSlackProjectorConfig } from '../../../projector.config';
import { RequestProjectionKeys } from '../../request-projection-keys';
import { RequestFieldValidatorUtil } from '../utilities/request-field-validator.util';
import { DetailRequestResponse } from '../../application/dtos';
import { RequestQueueService, SendRequestJob } from '../services';
import { IRedisIdempotencyService } from 'src/shared/infrastructure';
/**
 * Request projector error catalog using shared error definitions
 */
const RequestProjectorErrors = createProjectorErrorCatalog(
  'REQUEST_PROJECTOR',
  CommonProjectorErrorDefinitions,
);

/**
 * Request row parameters for Redis projection operations
 *
 * Extends DetailRequestResponse DTO with projection-specific fields needed for event sourcing.
 *
 * Key Additions to DetailRequestResponse:
 * - tenant: Multi-tenant support for Redis key generation
 * - deletedAt: Soft delete timestamp for TTL-based cleanup
 * - lastStreamRevision: Event sourcing revision tracking
 */
interface RequestProjectionParams extends DetailRequestResponse {
  // Projection-specific fields for Redis storage
  tenant: string;
  version: number;
  updatedAt: Date;
  deletedAt?: Date | null;
  lastStreamRevision?: string | null;
}

/**
 * Request Projector using Redis-based Shared Projection Infrastructure
 *
 * Leverages CatchUpRunner for event subscription and processing
 * Uses RedisCheckpointStore for distributed checkpoint management
 * Implements projection function pattern for event handling with Redis backend
 *
 * Redis Data Structure (managed by RequestProjectionKeys domain value object):
 * - Request Hash: `request:projection:{tenant}:code` - stores all request fields
 * - Tenant Index: `request:index:by_tenant:{tenant}` - sorted set by updated timestamp
 *
 * Key Features:
 * - Uses shared CatchUpRunner for subscription management
 * - Redis-based checkpoint storage for scalability
 * - Redis pipelines for atomic multi-operation transactions
 * - Version-based optimistic concurrency control using Lua scripts
 * - Automatic indexing for efficient querying
 * - Soft delete with TTL for audit purposes
 * - Comprehensive logging and monitoring
 */
@Injectable()
export class RequestProjector
  extends BaseProjector
  implements OnModuleInit, OnModuleDestroy
{
  private readonly metricsCollector = new CacheMetricsCollector();

  // ✅ Requestion-ready shared utilities
  private cacheOptimization!: CacheOptimizationUtils;
  private pipelineBuilder!: RedisPipelineBuilder;

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    @Inject(CLOCK) private readonly clock: Clock,
    @Inject(SLACK_REQUEST_DI_TOKENS.CATCHUP_RUNNER)
    private readonly catchUpRunner: CatchUpRunner,
    @Inject(SLACK_REQUEST_DI_TOKENS.CHECKPOINT_STORE)
    checkpointStore: CheckpointStore,
    @Inject(SLACK_REQUEST_DI_TOKENS.IO_REDIS)
    private readonly redis: Redis,
    @Inject(SLACK_REQUEST_DI_TOKENS.CACHE_SERVICE)
    private readonly cache: CacheService,
    private readonly queueService: RequestQueueService,
    @Inject('RequestIdempotencyService')
    private readonly idempotencyService: IRedisIdempotencyService,
  ) {
    super(
      RequestProjectionKeys.PROJECTOR_NAME,
      RequestProjectionKeys.SUBSCRIPTION_GROUP,
      baseLogger,
      checkpointStore,
    );

    // ✅ Initialize shared utilities for requestion-ready operations
    this.cacheOptimization = new CacheOptimizationUtils();
    this.pipelineBuilder = new RedisPipelineBuilder();

    Log.info(
      this.logger,
      'RequestProjector initialized with requestion-ready shared utilities',
      {
        method: 'constructor',
        subscriptionGroup: this.subscriptionGroup,
        redisStatus: this.redis.status,
        sharedUtilities: true,
        clusterSafe: true,
        evalshaCaching: true,
      },
    );
  }

  /**
   * Start the projector using CatchUpRunner with requestion-ready utilities
   */
  onModuleInit(): void {
    Log.info(this.logger, 'Starting Request Projector with CatchUpRunner', {
      method: 'onModuleInit',
      subscriptionGroup: this.subscriptionGroup,
    });

    try {
      // ✅ Register EVALSHA scripts for optimization
      registerRedisScripts(this.redis);
      Log.info(this.logger, 'EVALSHA scripts registered successfully', {
        method: 'onModuleInit',
        feature: 'evalsha-optimization',
      });
      const runOptions: RunOptions = {
        prefixes: [RequestProjectionKeys.getEventStoreStreamPrefix()],
        batchSize: 100,
        stopOnCaughtUp: false,
        maxRetries: 3,
        retryDelayMs: 1000,
        checkpointBatchSize: 10,
      };

      // Start the projection in the background without blocking module initialization
      this.catchUpRunner
        .runSafe(
          this.subscriptionGroup,
          this.projectEvent.bind(this) as (
            event: ProjectionEvent,
          ) => Promise<void>,
          runOptions,
        )
        .then((result) => {
          if (!result.ok) {
            this.updateHealthStatusOnError(
              result.error.detail || 'Unknown error',
            );
            Log.error(this.logger, 'Projection failed to start', {
              method: 'onModuleInit',
              error: result.error.detail || 'Unknown error',
            });
          } else {
            Log.info(this.logger, 'Projection completed successfully', {
              method: 'onModuleInit',
              status: 'completed',
            });
          }
        })
        .catch((error) => {
          const e = error as Error;
          this.updateHealthStatusOnError(e.message);
          Log.error(this.logger, 'Projection failed with exception', {
            method: 'onModuleInit',
            error: e.message,
            stack: e.stack,
          });
        });

      this.setRunning(true);
      this.updateHealthStatusOnSuccess();

      Log.info(this.logger, 'Request Projector started successfully', {
        method: 'onModuleInit',
        status: 'running',
      });
    } catch (error) {
      const e = error as Error;
      this.updateHealthStatusOnError(e.message);

      Log.error(this.logger, 'Failed to start Request Projector', {
        method: 'onModuleInit',
        error: e.message,
        stack: e.stack,
      });
      throw error;
    }
  }

  /**
   * Stop the projector using CatchUpRunner shutdown
   */
  onModuleDestroy(): void {
    Log.info(this.logger, 'Stopping Request Projector', {
      method: 'onModuleDestroy',
      subscriptionGroup: this.subscriptionGroup,
    });

    try {
      this.catchUpRunner.stop(this.subscriptionGroup);
      this.setRunning(false);

      Log.info(this.logger, 'Request Projector stopped successfully', {
        method: 'onModuleDestroy',
        status: 'stopped',
      });
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error stopping Request Projector', {
        method: 'onModuleDestroy',
        error: e.message,
        stack: e.stack,
      });
    }
  }

  /**
   * Project individual event using requestion-ready EventPipelineProcessor
   * with observable outcomes, SET NX EX optimization, and cluster-safe operations
   */
  private async projectEvent(
    event: ProjectionEvent,
  ): Promise<ProjectionOutcome> {
    const tenant = this.extractTenant(event);

    try {
      // ✅ Extract request parameters using existing utility
      const params = this.extractRequestParams(event, 'project');

      // ✅ Apply version hint deduplication first (production-ready SET NX EX)
      const config = NotificationSlackProjectorConfig.getConfig();
      const alreadyProcessed = await CacheOptimizationUtils.checkVersionHint(
        this.redis,
        tenant,
        'request',
        params.code,
        params.version,
        config.VERSION_KEY_PREFIX,
      );

      if (alreadyProcessed) {
        this.logger.debug(
          'Request already processed - using version hint optimization for ' +
            params.code +
            ' version ' +
            params.version,
        );
        const outcome = ProjectionOutcome.SKIPPED_HINT;
        this.logProjectionOutcome(outcome, event, tenant);
        return outcome;
      }

      // ✅ Build field pairs using shared utility (convert to generic Record)
      const fieldPairs = RedisPipelineBuilder.buildFieldPairs(
        params as unknown as Record<string, unknown>,
      );

      // ✅ Generate cluster-safe keys using centralized RequestProjectionKeys
      const entityKey = RequestProjectionKeys.getRedisRequestKey(
        tenant,
        params.code,
      );
      const indexKey = RequestProjectionKeys.getRedisRequestIndexKey(tenant);

      // ✅ Validate hash-tag consistency for cluster safety
      RedisClusterUtils.validateHashTagConsistency(entityKey, indexKey);

      // ✅ Create pipeline for atomic operations
      const pipeline = this.redis.pipeline();

      // ✅ Route to soft delete or upsert based on deletion state
      if (params.deletedAt) {
        // Use shared Redis pipeline builder for cluster-safe soft delete
        RedisPipelineBuilder.executeSoftDelete(
          pipeline,
          entityKey,
          indexKey,
          params.code,
          params.deletedAt,
        );

        // ✅ Record soft delete operation (metrics collected by base projector)
      } else {
        // Use shared Redis pipeline builder for cluster-safe upsert
        RedisPipelineBuilder.executeUpsert(
          pipeline,
          entityKey,
          indexKey,
          params.code,
          params.version,
          params.updatedAt,
          fieldPairs,
        );

        // ✅ Record upsert operation (metrics collected by base projector)
      }

      // ✅ Execute pipeline and handle results
      const results = await pipeline.exec();

      // ✅ Check if operations succeeded (non-null results indicate success)
      const operationSucceeded = results && results.every(([error]) => !error);
      const outcome = operationSucceeded
        ? ProjectionOutcome.APPLIED
        : ProjectionOutcome.STALE_OCC;

      // ✅ Dispatch async jobs based on event types
      await this.dispatchJobsForEvent(event, params);

      // ✅ Update cache hint to prevent reprocessing (race-free SET EX)
      await CacheOptimizationUtils.updateVersionHint(
        this.redis,
        tenant,
        'request',
        params.code,
        params.version,
        undefined, // Use default TTL
        config.VERSION_KEY_PREFIX,
      );

      // ✅ Log observable outcomes for SLO monitoring
      this.logProjectionOutcome(outcome, event, tenant);

      return outcome;
    } catch (error) {
      const e = error as Error;
      this.updateHealthStatusOnError(e.message);

      Log.error(this.logger, 'Failed to project event with shared pipeline', {
        method: 'projectEvent',
        eventType: event.type,
        streamId: event.streamId,
        revision: event.revision,
        tenant,
        error: e.message,
        stack: e.stack,
      });

      throw new Error(
        withContext(RequestProjectorErrors.DATABASE_OPERATION_FAILED, {
          eventType: event.type,
          streamId: event.streamId,
          originalError: e.message,
        }).detail,
        { cause: e },
      );
    }
  }

  /**
   * Log projection outcomes for SLO monitoring and incident analysis
   */
  private logProjectionOutcome(
    outcome: ProjectionOutcome,
    event: ProjectionEvent,
    tenant: string,
  ): void {
    const outcomeLabels = {
      [ProjectionOutcome.APPLIED]: 'applied',
      [ProjectionOutcome.STALE_OCC]: 'stale_occ',
      [ProjectionOutcome.SKIPPED_DEDUP]: 'skipped_dedup',
      [ProjectionOutcome.SKIPPED_HINT]: 'skipped_hint',
      [ProjectionOutcome.UNKNOWN]: 'unknown',
    };

    const outcomeLabel = outcomeLabels[outcome] || 'unknown';
    const level = outcome === ProjectionOutcome.APPLIED ? 'debug' : 'info';

    Log[level](this.logger, `Event projection outcome: ${outcomeLabel}`, {
      method: 'logProjectionOutcome',
      outcome,
      outcomeLabel,
      eventType: event.type,
      streamId: event.streamId,
      revision: event.revision,
      tenant,
      metrics: this.metricsCollector.getMetrics(),
    });
  }

  /**
   * Extract tenant ID from event using shared utility
   */
  private extractTenant(event: ProjectionEvent): string {
    return TenantExtractor.extractTenant(event);
  }

  /**
   * Generate cluster-safe Redis keys with hash-tags for locality
   */
  private generateClusterSafeKeys(params: RequestProjectionParams): {
    entityKey: string;
    indexKey: string;
  } {
    // ✅ Hash-tags ensure both keys route to same Redis Cluster slot
    const entityKey = 'request:{' + params.tenant + '}:' + params.code;
    const indexKey = 'request:index:{' + params.tenant + '}';

    Log.debug(this.logger, 'Generated cluster-safe keys with hash-tags', {
      method: 'generateClusterSafeKeys',
      entityKey,
      indexKey,
      tenant: params.tenant,
      code: params.code,
    });

    return { entityKey, indexKey };
  }

  /**
   * Extract request parameters from event data using RequestFieldValidatorUtil
   *
   * Uses RequestFieldValidatorUtil to create validated DetailRequestResponse for consistent
   * validation across repository and projector, and TenantExtractor for reliable tenant identification.
   */
  private extractRequestParams(
    event: ProjectionEvent,
    operation: string,
  ): RequestProjectionParams {
    try {
      const eventData = event.data as Record<string, any>;

      // Extract tenant using shared utility
      const tenant = TenantExtractor.extractTenant(event);

      // Use RequestFieldValidatorUtil to create validated request snapshot
      const requestSnapshot =
        RequestFieldValidatorUtil.createRequestSnapshotFromEventData(eventData);

      // Override envelope fields with actual event envelope data
      // The version, createdAt, updatedAt should come from event envelope, not payload
      const eventTimestamp =
        event.metadata?.occurredAt instanceof Date
          ? event.metadata.occurredAt
          : new Date();

      const eventEnvelope = {
        version: event.revision, // Use event revision as version
        createdAt: eventTimestamp, // Use event timestamp
        updatedAt: eventTimestamp, // Use event timestamp
      };

      // Add projector-specific fields for Redis storage
      return {
        ...requestSnapshot,
        ...eventEnvelope, // Override with correct envelope data
        tenant,
        deletedAt: null, // Projector handles soft deletes
        lastStreamRevision: event.revision.toString(),
      };
    } catch (error) {
      const e = error as Error;
      throw new Error(
        withContext(RequestProjectorErrors.INVALID_EVENT_DATA, {
          eventType: event.type,
          streamId: event.streamId,
          operation,
          originalError: e.message,
        }).detail,
      );
    }
  }

  /**
   * Dispatch async jobs based on event types and conditions
   * Implements dispatch-once pattern with idempotency guards
   */
  private async dispatchJobsForEvent(
    event: ProjectionEvent,
    params: RequestProjectionParams,
  ): Promise<void> {
    try {
      // Validate required parameters
      const requestCode = params.code;
      const tenant = params.tenant;
      const status = params.status;

      if (!requestCode) {
        Log.warn(this.logger, 'No requestCode found in projection params', {
          method: 'dispatchJobsForEvent',
          eventType: event.type,
        });
        return;
      }

      if (!tenant) {
        Log.warn(this.logger, 'No tenant found in projection params', {
          method: 'dispatchJobsForEvent',
          eventType: event.type,
          requestCode,
        });
        return;
      }

      // Extract simple event type for dispatch logic
      const simpleEventType = event.type
        .replace(/\.v\d+$/, '') // Remove version suffix
        .replace(/^NotificationSlackRequest/, ''); // Remove domain prefix

      // Determine if this event should trigger job dispatch
      const shouldDispatch =
        simpleEventType === 'RequestCreated' ||
        (simpleEventType === 'RequestUpdated' && status === 'queued');

      if (!shouldDispatch) {
        Log.debug(this.logger, 'Event does not trigger job dispatch', {
          method: 'dispatchJobsForEvent',
          eventType: event.type,
          simpleEventType,
          requestCode,
          status,
        });
        return;
      }

      // Check dispatch-once guard before attempting to enqueue
      const firstTime = await this.tryMarkDispatchedOnce(tenant, requestCode);
      if (!firstTime) {
        Log.debug(this.logger, 'Dispatch skipped (already marked once)', {
          method: 'dispatchJobsForEvent',
          eventType: event.type,
          requestCode,
          tenant,
        });
        return;
      }

      // Dispatch the job since this is the first time
      const jobDispatched = await this.handleJobDispatchingByEventType(
        event.type,
        {
          requestCode,
          tenant,
          status,
          workspaceCode: params.workspaceCode,
          templateCode: params.templateCode,
          channelCode: params.channelCode,
        },
      );

      if (jobDispatched) {
        Log.info(
          this.logger,
          'Job dispatching completed successfully (first time)',
          {
            method: 'dispatchJobsForEvent',
            eventType: event.type,
            requestCode,
            tenant,
          },
        );
      }
    } catch (error) {
      const e = error as Error;
      // Log error but don't fail the projection
      Log.error(this.logger, 'Failed to dispatch jobs for event', {
        method: 'dispatchJobsForEvent',
        eventType: event.type,
        requestCode: params.code,
        tenant: params.tenant,
        error: e.message,
      });
    }
  }

  /**
   * Try to mark a message request as dispatched exactly once using Redis SETNX
   * @param tenant - The tenant ID
   * @param id - The message request ID
   * @returns Promise<boolean> - true if this is the first time (dispatch allowed), false if already dispatched
   */
  private async tryMarkDispatchedOnce(
    tenant: string,
    id: string,
  ): Promise<boolean> {
    const dispatchKey = `message-request:dispatched:{${tenant}}:${id}`;

    try {
      // Use SETNX (SET if Not eXists) with no expiry for permanent once-only marker
      const result = await this.redis.set(dispatchKey, '1', 'NX');
      const isFirstTime = result === 'OK';

      Log.debug(this.logger, 'Dispatch-once check completed', {
        method: 'tryMarkDispatchedOnce',
        requestCode: id,
        tenant,
        dispatchKey,
        isFirstTime,
      });

      return isFirstTime;
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Failed to check dispatch-once marker', {
        method: 'tryMarkDispatchedOnce',
        requestCode: id,
        tenant,
        dispatchKey,
        error: e.message,
      });

      // On Redis error, allow dispatch to prevent blocking (fail-open approach)
      // This trades perfect idempotency for availability
      return true;
    }
  }

  /**
   * Handle job dispatching based on specific event types
   * Only dispatches on RequestCreated or status transitions to 'queued'
   *
   * @returns Promise<boolean> - true if a job was dispatched, false otherwise
   */
  private async handleJobDispatchingByEventType(
    eventType: string,
    context: {
      requestCode: string;
      tenant: string;
      status?: string;
      workspaceCode: string;
      templateCode?: string;
      channelCode?: string;
    },
  ): Promise<boolean> {
    const {
      requestCode,
      tenant,
      status,
      workspaceCode,
      templateCode,
      channelCode,
    } = context;

    // Extract the simple event name from the full type (e.g., "NotificationSlackRequestRequestCreated.v1" -> "RequestCreated")
    const simpleEventType = eventType
      .replace(/\.v\d+$/, '') // Remove version suffix first
      .replace(/^NotificationSlackRequest/, ''); // Remove domain prefix

    switch (simpleEventType) {
      case 'RequestCreated':
        return await this.dispatchSendMessageJob(
          requestCode,
          tenant,
          'created',
          { priority: 0, delay: 0 },
          { workspaceCode, templateCode, channelCode },
        );

      case 'RequestUpdated':
        // Only queue jobs if status changed to 'queued' state
        if (status === 'queued') {
          return await this.dispatchSendMessageJob(
            requestCode,
            tenant,
            'queued transition',
            { priority: 0, delay: 0 },
            { workspaceCode, templateCode, channelCode },
          );
        }
        Log.debug(this.logger, 'No job needed for status update', {
          method: 'handleJobDispatchingByEventType',
          eventType,
          simpleEventType,
          requestCode,
          status,
        });
        return false;

      // Note: Removed RequestFailed auto-retry
      // Retries should be handled by the executor with proper backoff policy
      // rather than automatically re-enqueuing from the projector

      default:
        Log.debug(this.logger, 'No job dispatching for event type', {
          method: 'handleJobDispatchingByEventType',
          eventType,
          simpleEventType,
          requestCode,
        });
        return false;
    }
  }

  /**
   * Dispatch a send message job with dispatch-once SETNX pattern
   *
   * Uses simple BullMQ job with minimal payload as per refinement.md specification.
   * Implements dispatch-once semantics using Redis SETNX to prevent duplicate jobs.
   */
  private async dispatchSendMessageJob(
    requestCode: string,
    tenant: string,
    trigger: string,
    options: { priority: number; delay: number },
    config: {
      workspaceCode: string;
      templateCode?: string;
      channelCode?: string;
    },
  ): Promise<boolean> {
    try {
      // Step 1: Acquire dispatch-once lock using SETNX pattern
      const dispatchResult = await this.idempotencyService.acquireDispatchLock(
        tenant,
        requestCode,
      );

      if (!dispatchResult.success) {
        Log.error(
          this.logger,
          `Failed to acquire dispatch lock for ${trigger} request`,
          {
            method: 'dispatchSendMessageJob',
            trigger,
            requestCode,
            tenant,
            error: dispatchResult.error,
          },
        );
        return false;
      }

      // Step 2: If not first time, skip enqueuing (already dispatched)
      if (!dispatchResult.isFirst) {
        Log.debug(
          this.logger,
          `Request ${requestCode} already dispatched for ${trigger}, skipping`,
          {
            method: 'dispatchSendMessageJob',
            trigger,
            requestCode,
            tenant,
          },
        );
        return true; // Return true because dispatch was successful (just not first time)
      }

      // Step 3: First time - create minimal BullMQ job payload
      const job: SendRequestJob = {
        requestCode,
        tenant,
        // Include threadTs if available from config (for thread replies)
        threadTs: undefined, // Will be resolved by worker from Request data
      };

      // Step 4: Enqueue the job using simple queue service method
      const enqueuResult: {
        success: boolean;
        jobId?: string;
        error?: string;
      } = await this.queueService.enqueueSimpleSendRequestJob(job, {
        priority: options.priority,
        delay: options.delay,
        // Minimal attempts - worker should handle retries via Redis locks
        attempts: 1,
      });

      if (!enqueuResult.success) {
        Log.error(
          this.logger,
          `Failed to enqueue simple send message job for ${trigger} request`,
          {
            method: 'dispatchSendMessageJob',
            trigger,
            requestCode,
            tenant,
            error: enqueuResult.error,
          },
        );
        return false;
      }

      Log.info(
        this.logger,
        `Successfully dispatched simple send message job for ${trigger} request`,
        {
          method: 'dispatchSendMessageJob',
          trigger,
          requestCode,
          tenant,
          jobId: enqueuResult.jobId,
          priority: options.priority,
          delay: options.delay,
          isFirstDispatch: dispatchResult.isFirst,
          workspaceCode: config.workspaceCode,
          templateCode: config.templateCode,
          channelCode: config.channelCode,
        },
      );

      return true;
    } catch (error) {
      Log.error(
        this.logger,
        `Unexpected error dispatching send message job for ${trigger} request`,
        {
          method: 'dispatchSendMessageJob',
          trigger,
          requestCode,
          tenant,
          error: error instanceof Error ? error.message : 'Unknown error',
        },
      );
      return false;
    }
  }
}
