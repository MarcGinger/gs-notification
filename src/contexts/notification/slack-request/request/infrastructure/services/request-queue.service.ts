// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { Injectable, Inject } from '@nestjs/common';
import { Queue } from 'bullmq';
import { APP_LOGGER, Log, Logger, componentLogger } from 'src/shared/logging';
import { CreateRequestRequest } from '../../application/dtos';
import { IUserToken } from 'src/shared/security';
import { RequestJobs } from '../processors';
import { Result, DomainError, err, fromError } from 'src/shared/errors';
import { ActorContext } from 'src/shared/application/context';
import { Option } from 'src/shared/domain/types';
import { ConfigErrors } from 'src/shared/config/errors/config.errors';
import { SendRequestJob } from './request-queue.types';
import {
  IWorkspaceQuery,
  WORKSPACE_QUERY_TOKEN,
} from 'src/contexts/notification/slack-config/workspace/application/ports';
import {
  ITemplateQuery,
  TEMPLATE_QUERY_TOKEN,
} from 'src/contexts/notification/slack-config/template/application/ports';
import {
  IChannelQuery,
  CHANNEL_QUERY_TOKEN,
} from 'src/contexts/notification/slack-config/channel/application/ports';
import {
  IAppConfigQuery,
  APP_CONFIG_QUERY_TOKEN,
} from 'src/contexts/notification/slack-config/app-config/application/ports';
import { DetailWorkspaceResponse } from 'src/contexts/notification/slack-config/workspace/application/dtos';
import { DetailTemplateResponse } from 'src/contexts/notification/slack-config/template/application/dtos';
import { DetailChannelResponse } from 'src/contexts/notification/slack-config/channel/application/dtos';
import { DetailAppConfigResponse } from 'src/contexts/notification/slack-config/app-config/application/dtos';

/**
 * Request Queue Service
 *
 * Enhanced service for adding jobs to the RequestQueue with tenant configuration support.
 * Integrates with Redis repositories to enrich job data with workspace, template, channel,
 * and app configuration information needed for message processing.
 *
 * Features:
 * - Job queuing with tenant-aware configuration
 * - Redis-based tenant data enrichment
 * - Comprehensive job validation and error handling
 * - Production-ready logging and monitoring
 */
@Injectable()
export class RequestQueueService {
  private readonly logger: Logger;

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    @Inject('Queue:RequestQueue') private readonly queue: Queue,
    @Inject(WORKSPACE_QUERY_TOKEN)
    private readonly workspaceQuery: IWorkspaceQuery,
    @Inject(TEMPLATE_QUERY_TOKEN)
    private readonly templateQuery: ITemplateQuery,
    @Inject(CHANNEL_QUERY_TOKEN)
    private readonly channelQuery: IChannelQuery,
    @Inject(APP_CONFIG_QUERY_TOKEN)
    private readonly appConfigQuery: IAppConfigQuery,
  ) {
    this.logger = componentLogger(baseLogger, 'RequestQueueService');

    Log.info(
      this.logger,
      'RequestQueueService initialized with Redis repositories',
      {
        component: 'RequestQueueService',
        repositoriesWired: {
          workspace: !!this.workspaceQuery,
          template: !!this.templateQuery,
          channel: !!this.channelQuery,
          appConfig: !!this.appConfigQuery,
        },
      },
    );
  }

  /**
   * Enhanced method to queue a send message job with tenant configuration data
   *
   * Fetches workspace, template, channel, and app config from Redis repositories
   * to provide all necessary context for message processing.
   */
  async queueEnrichedSendRequest(
    requestCode: string,
    tenant: string,
    workspaceCode: string,
    templateCode?: string,
    channelCode?: string,
    options?: {
      delay?: number;
      priority?: number;
    },
  ): Promise<Result<string, DomainError>> {
    const actor: ActorContext = {
      tenant,
      userId: 'system',
      tenant_userId: 'system',
    };

    try {
      // Fetch tenant configuration data in parallel
      const [workspaceResult, templateResult, channelResult, appConfigResult] =
        await Promise.all([
          this.workspaceQuery.findById(actor, workspaceCode),
          templateCode
            ? this.templateQuery.findById(actor, templateCode)
            : Promise.resolve({
                ok: true,
                value: Option.none(),
              } as Result<Option<DetailTemplateResponse>, DomainError>),
          channelCode
            ? this.channelQuery.findById(actor, channelCode)
            : Promise.resolve({
                ok: true,
                value: Option.none(),
              } as Result<Option<DetailChannelResponse>, DomainError>),
          this.appConfigQuery.findById(actor, workspaceCode),
        ]);

      // Check for fetch errors
      if (!workspaceResult.ok) {
        Log.error(this.logger, 'Failed to fetch workspace configuration', {
          method: 'queueEnrichedSendRequest',
          requestCode,
          tenant,
          workspaceCode,
          error: workspaceResult.error.detail,
        });
        return workspaceResult;
      }

      if (templateCode && templateResult && !templateResult.ok) {
        Log.error(this.logger, 'Failed to fetch template configuration', {
          method: 'queueEnrichedSendRequest',
          requestCode,
          tenant,
          templateCode,
          error: templateResult.error.detail,
        });
        return templateResult;
      }

      if (channelCode && channelResult && !channelResult.ok) {
        Log.error(this.logger, 'Failed to fetch channel configuration', {
          method: 'queueEnrichedSendRequest',
          requestCode,
          tenant,
          channelCode,
          error: channelResult.error.detail,
        });
        return channelResult;
      }

      if (!appConfigResult.ok) {
        Log.error(this.logger, 'Failed to fetch app configuration', {
          method: 'queueEnrichedSendRequest',
          requestCode,
          tenant,
          workspaceCode,
          error: appConfigResult.error.detail,
        });
        return appConfigResult;
      }

      // Extract configuration data using proper Option handling
      const workspace = Option.isSome(workspaceResult.value)
        ? workspaceResult.value.value
        : null;
      const template =
        templateResult &&
        templateResult.ok &&
        Option.isSome(templateResult.value)
          ? templateResult.value.value
          : null;
      const channel =
        channelResult && channelResult.ok && Option.isSome(channelResult.value)
          ? channelResult.value.value
          : null;
      const appConfig = Option.isSome(appConfigResult.value)
        ? appConfigResult.value.value
        : null;

      if (!workspace) {
        const error = `Workspace not found: ${workspaceCode}`;
        Log.error(this.logger, error, {
          method: 'queueEnrichedSendRequest',
          requestCode,
          tenant,
          workspaceCode,
        });
        return err(
          fromError(ConfigErrors.VALIDATION_FAILED, error, {
            configKey: 'workspace',
            requestCode,
            tenant,
            workspaceCode,
          }),
        );
      }

      // Create enriched job data
      const enrichedJobData: RequestJobs['send-request'] & {
        tenantConfig?: {
          workspace: DetailWorkspaceResponse;
          template?: DetailTemplateResponse;
          channel?: DetailChannelResponse;
          appConfig?: DetailAppConfigResponse;
        };
      } = {
        requestCode,
        tenant,
        tenantConfig: {
          workspace,
          template: template || undefined,
          channel: channel || undefined,
          appConfig: appConfig || undefined,
        },
      };

      const job = await this.queue.add('send-request', enrichedJobData, {
        delay: options?.delay || 0,
        priority: options?.priority || 0,
        removeOnComplete: 100,
        removeOnFail: 50,
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000,
        },
      });

      Log.info(this.logger, 'Queued enriched send request request job', {
        method: 'queueEnrichedSendRequest',
        jobId: job.id,
        requestCode,
        tenant,
        configurationLoaded: {
          workspace: !!workspace,
          template: !!template,
          channel: !!channel,
          appConfig: !!appConfig,
        },
        delay: options?.delay || 0,
        priority: options?.priority || 0,
      });

      return { ok: true, value: job.id?.toString() || 'unknown' };
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error queuing enriched send request request', {
        method: 'queueEnrichedSendRequest',
        requestCode,
        tenant,
        error: e.message,
        stack: e.stack,
      });
      return err(
        fromError(ConfigErrors.VALIDATION_FAILED, e, {
          configKey: 'queue',
          requestCode,
          tenant,
        }),
      );
    }
  }

  /**
   * Queue a request request creation job
   */
  async queueCreateRequest(
    user: IUserToken,
    request: CreateRequestRequest,
    options?: {
      idempotencyKey?: string;
      delay?: number;
      priority?: number;
    },
  ): Promise<string> {
    const jobData: RequestJobs['create-request'] = {
      user,
      request,
      options: {
        idempotencyKey: options?.idempotencyKey,
      },
    };

    const job = await this.queue.add('create-request', jobData, {
      delay: options?.delay || 0,
      priority: options?.priority || 0,
      removeOnComplete: 100,
      removeOnFail: 50,
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000,
      },
    });

    Log.info(this.logger, 'Queued create request request job', {
      method: 'queueCreateRequest',
      jobId: job.id,
      tenant: user.tenant,
      workspaceCode: request.workspaceCode,
      templateCode: request.templateCode,
      channelCode: request.channelCode,
      delay: options?.delay || 0,
      priority: options?.priority || 0,
    });

    return job.id?.toString() || 'unknown';
  }

  /**
   * Queue a message sending job
   */
  async queueSendRequest(
    requestCode: string,
    tenant: string,
    options?: {
      delay?: number;
      priority?: number;
    },
  ): Promise<string> {
    const jobData: RequestJobs['send-request'] = {
      requestCode,
      tenant,
    };

    const job = await this.queue.add('send-request', jobData, {
      delay: options?.delay || 0,
      priority: options?.priority || 0,
      removeOnComplete: 100,
      removeOnFail: 50,
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000,
      },
    });

    Log.info(this.logger, 'Queued send request request job', {
      method: 'queueSendRequest',
      jobId: job.id,
      requestCode,
      tenant,
      delay: options?.delay || 0,
      priority: options?.priority || 0,
    });

    return job.id?.toString() || 'unknown';
  }

  /**
   * Queue a retry job for failed request requests
   */
  async queueRetryFailedRequest(
    requestCode: string,
    tenant: string,
    retryReason: string,
    options?: {
      delay?: number;
      priority?: number;
    },
  ): Promise<string> {
    const jobData: RequestJobs['retry-failed-request'] = {
      requestCode,
      tenant,
      retryReason,
    };

    const job = await this.queue.add('retry-failed-request', jobData, {
      delay: options?.delay || 30000, // Default 30s delay for retries
      priority: options?.priority || 0,
      removeOnComplete: 100,
      removeOnFail: 50,
      attempts: 2, // Fewer attempts for retries
      backoff: {
        type: 'exponential',
        delay: 5000,
      },
    });

    Log.info(this.logger, 'Queued retry failed request request job', {
      method: 'queueRetryFailedRequest',
      jobId: job.id,
      requestCode,
      tenant,
      retryReason,
      delay: options?.delay || 30000,
      priority: options?.priority || 0,
    });

    return job.id?.toString() || 'unknown';
  }

  /**
   * Simple BullMQ job enqueue with minimal payload (following refinement.md)
   *
   * Enqueues a SendRequestJob with minimal payload following the reference-only,
   * secret-free principles. The worker will resolve configuration by codes.
   */
  async enqueueSimpleSendRequestJob(
    job: SendRequestJob,
    options?: {
      priority?: number;
      delay?: number;
      attempts?: number;
    },
  ): Promise<{
    success: boolean;
    jobId?: string;
    error?: string;
  }> {
    const { requestCode, tenant } = job;

    try {
      Log.debug(this.logger, 'Enqueuing simple SendRequestJob', {
        method: 'enqueueSimpleSendRequestJob',
        requestCode,
        tenant,
        threadTs: job.threadTs,
        options,
      });

      const bullmqJob = await this.queue.add('SendRequestJob', job, {
        priority: options?.priority || 0,
        delay: options?.delay || 0,
        attempts: options?.attempts || 1,
        // Minimal job options - no complex retry logic here
        // Worker handles retries via send-lock SETNX patterns
      });

      Log.info(this.logger, 'Successfully enqueued simple SendRequestJob', {
        method: 'enqueueSimpleSendRequestJob',
        requestCode,
        tenant,
        jobId: bullmqJob.id,
        priority: options?.priority || 0,
        delay: options?.delay || 0,
        attempts: options?.attempts || 1,
      });

      return {
        success: true,
        jobId: bullmqJob.id?.toString(),
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';

      Log.error(this.logger, 'Failed to enqueue simple SendRequestJob', {
        method: 'enqueueSimpleSendRequestJob',
        requestCode,
        tenant,
        error: errorMessage,
      });

      return {
        success: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Get queue statistics and health information
   */
  async getQueueInfo(): Promise<{
    waiting: number;
    active: number;
    completed: number;
    failed: number;
    delayed: number;
  }> {
    const [waiting, active, completed, failed, delayed] = await Promise.all([
      this.queue.getWaiting(),
      this.queue.getActive(),
      this.queue.getCompleted(),
      this.queue.getFailed(),
      this.queue.getDelayed(),
    ]);

    return {
      waiting: waiting.length,
      active: active.length,
      completed: completed.length,
      failed: failed.length,
      delayed: delayed.length,
    };
  }
}
