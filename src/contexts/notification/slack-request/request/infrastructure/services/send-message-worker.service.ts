// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

/**
 * Request BullMQ Worker - Processes minimal SendRequestJob payloads
 *
 * Implements the worker resolution pattern from refinement.md:
 * 1. Resolves config by codes from Redis (workspace, template, channel, app-config)
 * 2. Acquires send-lock using SETNX for idempotency
 * 3. Processes messages via SlackApiService
 * 4. Reports outcomes back to Request projector
 */

import {
  Injectable,
  OnModuleInit,
  OnModuleDestroy,
  Inject,
} from '@nestjs/common';
import { APP_LOGGER, Log, Logger, componentLogger } from 'src/shared/logging';
import { Worker, Job } from 'bullmq';
import { Redis } from 'ioredis';
import { SendRequestJob, REQUEST_QUEUE } from './request-queue.types';
import {
  IRedisIdempotencyService,
  JobProcessingResult,
} from 'src/shared/infrastructure';
import { SLACK_REQUEST_DI_TOKENS } from '../../../slack-request.constants';
import {
  IWorkspaceQuery,
  WORKSPACE_QUERY_TOKEN,
} from 'src/contexts/notification/slack-request/workspace/application/ports';
import {
  ITemplateQuery,
  TEMPLATE_QUERY_TOKEN,
} from 'src/contexts/notification/slack-request/template/application/ports';
import {
  IChannelQuery,
  CHANNEL_QUERY_TOKEN,
} from 'src/contexts/notification/slack-request/channel/application/ports';
import {
  IConfigQuery,
  CONFIG_QUERY_TOKEN,
} from 'src/contexts/notification/slack-request/config/application/ports';
import { DetailWorkspaceResponse } from 'src/contexts/notification/slack-request/workspace/application/dtos';
import { DetailTemplateResponse } from 'src/contexts/notification/slack-request/template/application/dtos';
import { DetailChannelResponse } from 'src/contexts/notification/slack-request/channel/application/dtos';
import { DetailConfigResponse } from 'src/contexts/notification/slack-request/config/application/dtos';
import { ActorContext } from 'src/shared/application/context';
import { Option } from 'src/shared/domain/types';
import { Result, DomainError } from 'src/shared/errors';
import { RequestProjectionKeys } from '../../request-projection-keys';
import {
  SlackApiService,
  SlackSendOptions,
} from 'src/shared/infrastructure/slack/slack-api.service';
import {
  IRequestAppPort,
  REQUEST_APP_PORT,
} from '../../application/ports/request-app.port';
import { RequestTemplateAdapter } from './request-template.adapter';
import { createSystemUserToken } from 'src/shared/security/auth';

@Injectable()
export class SendRequestWorkerService implements OnModuleInit, OnModuleDestroy {
  private readonly logger: Logger;
  private worker?: Worker<SendRequestJob>;

  constructor(
    @Inject(APP_LOGGER) private readonly baseLogger: Logger,
    @Inject(SLACK_REQUEST_DI_TOKENS.IO_REDIS)
    private readonly redis: Redis,
    @Inject('RequestIdempotencyService')
    private readonly idempotencyService: IRedisIdempotencyService,
    // Config resolution services
    @Inject(WORKSPACE_QUERY_TOKEN)
    private readonly workspaceQuery: IWorkspaceQuery,
    @Inject(TEMPLATE_QUERY_TOKEN)
    private readonly templateQuery: ITemplateQuery,
    @Inject(CHANNEL_QUERY_TOKEN)
    private readonly channelQuery: IChannelQuery,
    @Inject(CONFIG_QUERY_TOKEN)
    private readonly appConfigQuery: IConfigQuery,
    // Slack API and outcome reporting
    private readonly slackApiService: SlackApiService,
    @Inject(REQUEST_APP_PORT)
    private readonly requestAppPort: IRequestAppPort,
    private readonly templateRenderer: RequestTemplateAdapter,
  ) {
    this.logger = componentLogger(baseLogger, 'SendRequestWorkerService');
  }

  onModuleInit(): void {
    // Note: Worker creation is handled by RequestProcessor
    // This service now acts as a job processing delegate
    Log.info(
      this.logger,
      'SendRequestWorkerService initialized as processing delegate',
      {
        queueName: REQUEST_QUEUE.NAME,
      },
    );
  }

  onModuleDestroy(): void {
    // Worker cleanup is handled by RequestProcessor
    Log.info(this.logger, 'SendRequestWorkerService cleanup complete');
  }

  /**
   * Process SendRequestJob - Main worker logic
   */
  async processJob(job: Job<SendRequestJob>): Promise<JobProcessingResult> {
    const { requestCode, tenant, threadTs } = job.data;

    Log.debug(this.logger, 'Processing SendRequestJob', {
      jobId: job.id,
      requestCode,
      tenant,
      threadTs,
    });

    try {
      // Step 1: Acquire send-lock using SETNX (idempotency for processing)
      const sendLockResult = await this.idempotencyService.acquireExecutionLock(
        tenant,
        requestCode,
      );

      if (!sendLockResult.success) {
        Log.warn(
          this.logger,
          'Failed to acquire send lock - job may be duplicate',
          {
            jobId: job.id,
            requestCode,
            tenant,
            error: sendLockResult.error,
          },
        );

        return {
          success: false,
          message: sendLockResult.error || 'Failed to acquire send lock',
        };
      }

      if (!sendLockResult.isFirst) {
        Log.debug(
          this.logger,
          'Send lock already acquired - skipping duplicate processing',
          {
            jobId: job.id,
            requestCode,
            tenant,
          },
        );

        return {
          success: true,
          message: 'Already processed (send-lock exists)',
        };
      }

      // Step 2: Resolve Request data to get config codes
      const requestData = await this.resolveRequestData(tenant, requestCode);

      if (!requestData.success) {
        return {
          success: false,
          message: requestData.error || 'Failed to resolve Request data',
        };
      }

      // Step 3: Resolve config by codes
      const configResult = await this.resolveConfigByCodes(
        tenant,
        requestData.data!,
      );

      if (!configResult.success) {
        return {
          success: false,
          message: configResult.error || 'Failed to resolve config by codes',
        };
      }

      // Step 4: Process the message via SlackApiService
      const processingResult = await this.processSlackMessage(
        job,
        requestData.data!,
        configResult.config!,
        threadTs || undefined,
      );

      if (!processingResult.success) {
        return {
          success: false,
          message: processingResult.error || 'Failed to process Slack message',
        };
      }

      Log.info(this.logger, 'Successfully processed SendRequestJob', {
        jobId: job.id,
        requestCode,
        tenant,
        slackResponse: processingResult.data,
      });

      return {
        success: true,
        message: 'Message processed successfully',
        metadata: {
          messageTimestamp: processingResult.data?.ts,
          targetChannel: processingResult.data?.channel,
        },
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';

      Log.error(this.logger, 'Unexpected error processing SendRequestJob', {
        jobId: job.id,
        requestCode,
        tenant,
        error: errorMessage,
      });

      return {
        success: false,
        message: errorMessage,
      };
    }
  }

  /**
   * Resolve Request data from Redis to get config codes
   */
  private async resolveRequestData(
    tenant: string,
    requestCode: string,
  ): Promise<{
    success: boolean;
    data?: {
      workspaceCode: string;
      templateCode?: string;
      channelCode?: string;
      requestData?: Record<string, unknown>;
      // Add other Request fields as needed
    };
    error?: string;
  }> {
    try {
      // Get Redis key for Request projection
      const redisKey = RequestProjectionKeys.getRedisRequestKey(
        tenant,
        requestCode,
      );

      Log.debug(this.logger, 'Resolving Request data from Redis', {
        requestCode,
        tenant,
        redisKey,
      });

      // Fetch Request data from Redis hash
      const redisHashData = await this.redis.hgetall(redisKey);

      if (!redisHashData || Object.keys(redisHashData).length === 0) {
        Log.warn(this.logger, 'Request not found in Redis projection', {
          requestCode,
          tenant,
          redisKey,
        });

        return {
          success: false,
          error: `Request not found: ${requestCode}`,
        };
      }

      // Extract required config codes from the Request data
      const workspaceCode = redisHashData.workspaceCode;
      const templateCode = redisHashData.templateCode || undefined;
      const channelCode = redisHashData.channelCode || undefined;

      // Parse requestData if it exists (it's stored as JSON string in Redis)
      let parsedRequestData: Record<string, unknown> = {};
      if (redisHashData.data) {
        try {
          parsedRequestData = JSON.parse(redisHashData.data) as Record<
            string,
            unknown
          >;
        } catch (error) {
          Log.warn(this.logger, 'Failed to parse requestData JSON', {
            requestCode,
            tenant,
            requestDataRaw: redisHashData.data,
            error: error instanceof Error ? error.message : 'Unknown error',
          });
        }
      }

      if (!workspaceCode) {
        Log.error(this.logger, 'Request missing required workspaceCode', {
          requestCode,
          tenant,
          redisHashData,
        });

        return {
          success: false,
          error: 'Request missing required workspaceCode',
        };
      }

      Log.debug(this.logger, 'Successfully resolved Request data', {
        requestCode,
        tenant,
        workspaceCode,
        templateCode,
        channelCode,
        hasRequestData: Object.keys(parsedRequestData).length > 0,
      });

      return {
        success: true,
        data: {
          workspaceCode,
          templateCode,
          channelCode,
          requestData: parsedRequestData,
        },
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';

      Log.error(this.logger, 'Failed to resolve Request data from Redis', {
        requestCode,
        tenant,
        error: errorMessage,
      });

      return {
        success: false,
        error: errorMessage,
      };
    }
  }

  /**
   * Resolve configuration by codes using query services
   */
  private async resolveConfigByCodes(
    tenant: string,
    data: {
      workspaceCode: string;
      templateCode?: string;
      channelCode?: string;
    },
  ): Promise<{
    success: boolean;
    config?: {
      workspace: DetailWorkspaceResponse;
      template?: DetailTemplateResponse;
      channel?: DetailChannelResponse;
      appConfig: DetailConfigResponse;
    };
    error?: string;
  }> {
    const systemUserToken = createSystemUserToken(tenant || 'system');
    const actor: ActorContext = {
      tenant: systemUserToken.tenant,
      userId: systemUserToken.sub,
      tenant_userId: systemUserToken.sub,
      username: systemUserToken.preferred_username,
      roles: systemUserToken.roles,
    };

    try {
      // Fetch all required configurations in parallel
      const [workspaceResult, templateResult, channelResult, appConfigResult] =
        await Promise.all([
          this.workspaceQuery.findById(actor, data.workspaceCode),
          data.templateCode
            ? this.templateQuery.findById(actor, data.templateCode)
            : Promise.resolve({
                ok: true,
                value: Option.none(),
              } as Result<Option<DetailTemplateResponse>, DomainError>),
          data.channelCode
            ? this.channelQuery.findById(actor, data.channelCode)
            : Promise.resolve({
                ok: true,
                value: Option.none(),
              } as Result<Option<DetailChannelResponse>, DomainError>),
          this.appConfigQuery.findById(actor, data.workspaceCode),
        ]);

      // Validate workspace result
      if (!workspaceResult.ok || Option.isNone(workspaceResult.value)) {
        return {
          success: false,
          error: `Workspace not found or failed to fetch: ${data.workspaceCode}`,
        };
      }

      // Validate app config result
      if (!appConfigResult.ok || Option.isNone(appConfigResult.value)) {
        return {
          success: false,
          error: `App config not found or failed to fetch for workspace: ${data.workspaceCode}`,
        };
      }

      // Extract the configuration data
      const workspace = workspaceResult.value.value;
      const appConfig = appConfigResult.value.value;

      const template =
        templateResult &&
        templateResult.ok &&
        Option.isSome(templateResult.value)
          ? templateResult.value.value
          : undefined;

      const channel =
        channelResult && channelResult.ok && Option.isSome(channelResult.value)
          ? channelResult.value.value
          : undefined;

      return {
        success: true,
        config: {
          workspace,
          template,
          channel,
          appConfig,
        },
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Process Slack message via SlackApiService
   */
  private async processSlackMessage(
    job: Job<SendRequestJob>,
    messageData: {
      workspaceCode: string;
      templateCode?: string;
      channelCode?: string;
      requestData?: Record<string, unknown>;
    },
    config: {
      workspace: DetailWorkspaceResponse;
      template?: DetailTemplateResponse;
      channel?: DetailChannelResponse;
      appConfig: DetailConfigResponse;
    },
    threadTs?: string,
  ): Promise<{
    success: boolean;
    data?: { ts: string; channel: string };
    error?: string;
  }> {
    try {
      const { workspace, template, channel } = config;
      const requestData = messageData.requestData || {};

      // Validate workspace has bot token
      if (!workspace.botToken) {
        const errorMsg = `Workspace ${workspace.code} missing bot token`;

        Log.error(this.logger, 'Bot token validation failed', {
          workspaceCode: workspace.code,
          requestCode: job.data.requestCode,
        });

        // Report failure back to Request
        try {
          await this.requestAppPort.recordFailed({
            code: job.data.requestCode,
            reason: errorMsg,
            retryable: false, // Configuration error, not retryable
            attempts: 1,
            tenant: job.data.tenant,
          });
        } catch (reportError) {
          Log.warn(
            this.logger,
            'Failed to report bot token validation failure',
            {
              requestCode: job.data.requestCode,
              reportError:
                reportError instanceof Error
                  ? reportError.message
                  : 'Unknown error',
            },
          );
        }

        return {
          success: false,
          error: errorMsg,
        };
      }

      // 1. Determine target channel ID
      let targetChannelId: string;
      if (channel) {
        // Use channel code as channelId (follows existing processor pattern)
        targetChannelId = channel.code;
        Log.debug(this.logger, 'Using configured channel', {
          channelCode: messageData.channelCode,
          channelId: targetChannelId,
          channelName: channel.name,
        });
      } else {
        // Fallback to default channel from workspace
        targetChannelId = workspace.defaultChannelId || '';
        Log.debug(this.logger, 'Using default channel from workspace', {
          channelId: targetChannelId,
        });
      }

      if (!targetChannelId) {
        const errorMsg =
          'No target channel specified and no default channel configured';

        Log.error(this.logger, 'Channel validation failed', {
          error: errorMsg,
          requestCode: job.data.requestCode,
        });

        // Report failure back to Request
        try {
          await this.requestAppPort.recordFailed({
            code: job.data.requestCode,
            reason: errorMsg,
            retryable: false, // Configuration error, not retryable
            attempts: 1,
            tenant: job.data.tenant,
          });
        } catch (reportError) {
          Log.warn(this.logger, 'Failed to report channel validation failure', {
            requestCode: job.data.requestCode,
            reportError:
              reportError instanceof Error
                ? reportError.message
                : 'Unknown error',
          });
        }

        return {
          success: false,
          error: errorMsg,
        };
      }

      // 2. Render message blocks
      let renderedBlocks: unknown[];
      if (template) {
        Log.debug(this.logger, 'Rendering template', {
          templateCode: template.code,
          templateName: template.name,
          hasContentBlocks: Array.isArray(template.contentBlocks),
          contentBlocksCount: template.contentBlocks?.length ?? 0,
          requiredVariables: template.variables ?? [],
          providedVariables: Object.keys(requestData),
        });

        const renderRes = this.templateRenderer.renderTemplate({
          template,
          variables: requestData,
        });

        if (!renderRes.ok) {
          Log.error(this.logger, 'Template rendering failed', {
            templateCode: template.code,
            renderError: renderRes.error,
            contentBlocks: template.contentBlocks,
            variables: requestData,
          });

          // Fallback to default message
          renderedBlocks = [
            {
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: `‚ö†Ô∏è Message from ${workspace.name} (template error: ${renderRes.error})`,
              },
            },
          ];
        } else {
          renderedBlocks = Array.isArray(renderRes.value)
            ? renderRes.value
            : [renderRes.value];

          Log.debug(this.logger, 'Template rendered successfully', {
            templateCode: template.code,
            renderedBlocksCount: renderedBlocks.length,
          });
        }
      } else {
        // No template - create default message
        renderedBlocks = [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `üìù Message from ${workspace.name}`,
            },
          },
        ];

        Log.debug(this.logger, 'Using default message (no template)', {
          workspaceName: workspace.name,
        });
      }

      // 3. Send message via Slack API
      const slackSendOptions: SlackSendOptions = {
        botToken: workspace.botToken,
        channel: targetChannelId,
        blocks: renderedBlocks,
        text: `Message from ${workspace.name}`,
        thread_ts: threadTs || undefined,
      };

      Log.debug(this.logger, 'Sending message to Slack', {
        channel: targetChannelId,
        blocksCount: renderedBlocks.length,
        hasThreadTs: !!threadTs,
        workspaceName: workspace.name,
      });

      const slackResult =
        await this.slackApiService.sendMessage(slackSendOptions);

      if (!slackResult.ok) {
        Log.error(this.logger, 'Slack API call failed', {
          error: slackResult.error,
          retryable: slackResult.retryable,
          retryAfterSec: slackResult.retryAfterSec,
          requestCode: job.data.requestCode,
        });

        // Report failure back to Request
        try {
          await this.requestAppPort.recordFailed({
            code: job.data.requestCode,
            reason: slackResult.error,
            retryable: slackResult.retryable,
            attempts: 1, // BullMQ handles retries at job level
            tenant: job.data.tenant,
          });

          Log.debug(this.logger, 'Recorded Slack API failure to Request', {
            requestCode: job.data.requestCode,
            slackError: slackResult.error,
          });
        } catch (reportError) {
          Log.warn(this.logger, 'Failed to report Slack failure to Request', {
            requestCode: job.data.requestCode,
            reportError:
              reportError instanceof Error
                ? reportError.message
                : 'Unknown error',
          });
        }

        return {
          success: false,
          error: slackResult.error,
        };
      }

      Log.info(this.logger, 'Message sent successfully to Slack', {
        slackTs: slackResult.value.ts,
        slackChannel: slackResult.value.channel,
        workspaceName: workspace.name,
      });

      // Report successful delivery back to Request
      try {
        await this.requestAppPort.recordSent({
          code: job.data.requestCode,
          attempts: 1, // BullMQ handles retries at job level
          tenant: job.data.tenant,
        });

        Log.debug(this.logger, 'Recorded successful delivery to Request', {
          requestCode: job.data.requestCode,
          slackTs: slackResult.value.ts,
        });
      } catch (reportError) {
        // Don't fail the job if reporting fails - the message was sent successfully
        Log.warn(this.logger, 'Failed to report success to Request', {
          requestCode: job.data.requestCode,
          reportError:
            reportError instanceof Error
              ? reportError.message
              : 'Unknown error',
        });
      }

      return {
        success: true,
        data: {
          ts: slackResult.value.ts,
          channel: slackResult.value.channel,
        },
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';

      Log.error(this.logger, 'Unexpected error processing Slack message', {
        error: errorMessage,
        requestCode: job.data.requestCode,
      });

      // Report failure back to Request
      try {
        await this.requestAppPort.recordFailed({
          code: job.data.requestCode,
          reason: errorMessage,
          attempts: 1, // BullMQ handles retries at job level
          tenant: job.data.tenant,
        });

        Log.debug(this.logger, 'Recorded failure to Request', {
          requestCode: job.data.requestCode,
          errorMessage,
        });
      } catch (reportError) {
        Log.warn(this.logger, 'Failed to report failure to Request', {
          requestCode: job.data.requestCode,
          reportError:
            reportError instanceof Error
              ? reportError.message
              : 'Unknown error',
        });
      }

      return {
        success: false,
        error: errorMessage,
      };
    }
  }
}
