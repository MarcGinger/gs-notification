// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import {
  Injectable,
  OnModuleInit,
  OnModuleDestroy,
  Inject,
} from '@nestjs/common';
import { APP_LOGGER, Log, Logger, componentLogger } from 'src/shared/logging';
import { Worker, Job } from 'bullmq';
import { Redis } from 'ioredis';
import { RequestApplicationService } from '../../application/services';
import { CreateRequestRequest } from '../../application/dtos';
import { RequestErrors } from '../../domain/errors';
import { withContext } from 'src/shared/errors';
import { IUserToken } from 'src/shared/security';
import { AppConfigUtil } from 'src/shared/config/app-config.util';
import {
  SendRequestWorkerService,
  RequestTemplateAdapter,
  SendRequestJob,
} from '../services';
import { SlackApiService } from 'src/shared/infrastructure/slack/slack-api.service';
import { SLACK_REQUEST_DI_TOKENS } from '../../../slack-request.constants';
import {
  REQUEST_QUERY_TOKEN,
  REQUEST_WRITER_TOKEN,
} from '../../application/ports';
import { IRequestQuery, IRequestWriter } from '../../application/ports';
import {
  IRequestAppPort,
  REQUEST_APP_PORT,
} from '../../application/ports/request-app.port';
import { DetailWorkspaceResponse } from 'src/contexts/notification/slack-request/workspace/application/dtos';
import { DetailTemplateResponse } from 'src/contexts/notification/slack-request/template/application/dtos';
import { DetailChannelResponse } from 'src/contexts/notification/slack-request/channel/application/dtos';
import { DetailConfigResponse } from 'src/contexts/notification/slack-request/config/application/dtos';
import { ActorContext } from 'src/shared/application/context';
import { Option } from 'src/shared/domain/types';

/**
 * Request Queue Job Types
 */
export interface RequestJobs {
  'create-request': {
    user: IUserToken;
    request: CreateRequestRequest;
    options?: {
      idempotencyKey?: string;
    };
  };
  'send-request': {
    requestCode: string;
    tenant: string;
    threadTs?: string | null;
    tenantConfig?: {
      workspace: DetailWorkspaceResponse;
      template?: DetailTemplateResponse;
      channel?: DetailChannelResponse;
      config?: DetailConfigResponse;
    };
  };
  'retry-failed-request': {
    requestCode: string;
    tenant: string;
    retryReason: string;
  };
}

/**
 * Request Queue Processor
 *
 * Handles asynchronous processing of request operations:
 * - Creating requests
 * - Sending messages via Slack API
 * - Retrying failed operations
 *
 * Uses BullMQ for reliable job processing with:
 * - Exponential backoff for retries
 * - Job persistence in Redis
 * - Comprehensive logging and monitoring
 */
@Injectable()
export class RequestProcessor implements OnModuleInit, OnModuleDestroy {
  private readonly logger: Logger;
  private worker: Worker | null = null;

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    private readonly requestService: RequestApplicationService,
    private readonly slackApiService: SlackApiService,
    private readonly templateAdapter: RequestTemplateAdapter,
    @Inject(REQUEST_QUERY_TOKEN)
    private readonly requestQuery: IRequestQuery,
    @Inject(REQUEST_WRITER_TOKEN)
    private readonly requestWriter: IRequestWriter,
    @Inject(REQUEST_APP_PORT)
    private readonly requestAppPort: IRequestAppPort,
    @Inject(SLACK_REQUEST_DI_TOKENS.IO_REDIS)
    private readonly redis: Redis,
    private readonly sendRequestWorkerService: SendRequestWorkerService,
  ) {
    this.logger = componentLogger(baseLogger, 'RequestProcessor');
  }

  /**
   * Initialize the BullMQ worker to process jobs
   */
  onModuleInit(): void {
    const redisConfig = AppConfigUtil.getRedisConfig();
    const environment = AppConfigUtil.getEnvironment();

    // Create the worker with the same configuration as the queue
    this.worker = new Worker(
      'RequestQueue',
      async (job: Job) => {
        Log.info(this.logger, 'Processing job', {
          method: 'onModuleInit.worker',
          jobId: job.id,
          jobName: job.name,
          attempts: job.attemptsMade,
        });

        try {
          // Route to appropriate handler based on job name
          switch (job.name) {
            case 'create-request':
              return await this.handleCreateRequest(
                job as Job<RequestJobs['create-request']>,
              );
            case 'send-request':
              return await this.handleSendRequest(
                job as Job<RequestJobs['send-request']>,
              );
            case 'SendRequestJob':
              return await this.handleSendRequestJob(
                job as Job<SendRequestJob>,
              );
            case 'retry-failed-request':
              return await this.handleRetryFailedRequest(
                job as Job<RequestJobs['retry-failed-request']>,
              );
            default:
              throw new Error(
                withContext(RequestErrors.INVALID_DATA, {
                  operation: 'job_processing',
                  code: job.id || 'unknown',
                  reason: `Unknown job type: ${job.name}`,
                }).detail,
                { cause: new Error(`Unknown job type: ${job.name}`) },
              );
          }
        } catch (error) {
          const e = error as Error;
          Log.error(this.logger, 'Job processing failed', {
            method: 'onModuleInit.worker',
            jobId: job.id,
            jobName: job.name,
            error: e.message,
            stack: e.stack,
          });
          throw error; // Re-throw to trigger BullMQ retry logic
        }
      },
      {
        connection: {
          host: redisConfig.host,
          port: redisConfig.port,
          db: redisConfig.database,
        },
        prefix: `${environment}:request:`,
        concurrency: 4, // Process up to 4 jobs concurrently (optimal for Slack API)
        limiter: {
          max: 10,
          duration: 60000, // 10 jobs per minute rate limiting
        },
      },
    );

    // Add event listeners for monitoring
    this.worker.on('completed', (job) => {
      Log.info(this.logger, 'Job completed successfully', {
        method: 'worker.completed',
        jobId: job.id,
        jobName: job.name,
        processingTime: job.finishedOn
          ? job.finishedOn - job.processedOn!
          : 'unknown',
      });
    });

    this.worker.on('failed', (job, err) => {
      Log.error(this.logger, 'Job failed', {
        method: 'worker.failed',
        jobId: job?.id,
        jobName: job?.name,
        attempts: job?.attemptsMade,
        error: err.message,
      });
    });

    this.worker.on('error', (err) => {
      Log.error(this.logger, 'Worker error', {
        method: 'worker.error',
        error: err.message,
        stack: err.stack,
      });
    });

    Log.info(this.logger, 'RequestProcessor worker started', {
      method: 'onModuleInit',
      queueName: 'RequestQueue',
      concurrency: 5,
      prefix: `${environment}:request:`,
    });
  }

  /**
   * Clean up the worker on module destroy
   */
  async onModuleDestroy(): Promise<void> {
    if (this.worker) {
      Log.info(this.logger, 'Stopping RequestProcessor worker', {
        method: 'onModuleDestroy',
      });

      await this.worker.close();
      this.worker = null;

      Log.info(this.logger, 'RequestProcessor worker stopped', {
        method: 'onModuleDestroy',
      });
    }
  }

  /**
   * Process request creation jobs
   */
  async handleCreateRequest(
    job: Job<RequestJobs['create-request']>,
  ): Promise<void> {
    const { user, request, options } = job.data;
    const jobId = job.id;

    Log.info(this.logger, 'Processing create request job', {
      method: 'handleCreateRequest',
      jobId,
      tenant: user.tenant,
      workspaceCode: request.workspaceCode,
      templateCode: request.templateCode,
      channelCode: request.channelCode,
      idempotencyKey: options?.idempotencyKey,
    });

    try {
      const result = await this.requestService.createRequest(
        user,
        request,
        options,
      );

      if (!result.ok) {
        Log.error(this.logger, 'Failed to create request in job', {
          method: 'handleCreateRequest',
          jobId,
          error: result.error.detail,
          context: result.error.context,
        });
        throw new Error(result.error.detail);
      }

      Log.info(this.logger, 'Successfully created request in job', {
        method: 'handleCreateRequest',
        jobId,
        requestCode: result.value.code,
        status: result.value.status,
      });

      // Optionally trigger next job in the pipeline (send message)
      if (result.value.status === 'validated') {
        // Could add job to send the message
        Log.debug(this.logger, 'Request ready for sending', {
          method: 'handleCreateRequest',
          jobId,
          requestCode: result.value.code,
          nextStep: 'send-request',
        });
      }
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing create request job', {
        method: 'handleCreateRequest',
        jobId,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }

  /**
   * Process message sending jobs with tenant configuration and Slack API integration
   * Implements idempotency guards and internal retry logic with status updates
   */
  async handleSendRequest(
    job: Job<RequestJobs['send-request']>,
  ): Promise<void> {
    const { requestCode, tenant, tenantConfig } = job.data;
    const jobId = job.id;
    const actor: ActorContext = {
      tenant,
      userId: 'system',
      tenant_userId: 'system',
    };

    Log.info(this.logger, 'Processing send request job', {
      method: 'handleSendRequest',
      jobId,
      requestCode,
      tenant,
      hasConfig: !!tenantConfig,
    });

    // 1. Idempotency guard - prevent duplicate processing
    const isFirstTime = await this.checkIdempotency(tenant, requestCode);
    if (!isFirstTime) {
      Log.info(this.logger, 'Skipping duplicate send (idempotency)', {
        method: 'handleSendRequest',
        requestCode,
        tenant,
        jobId,
      });
      return;
    }

    try {
      // 2. Fetch request details
      const requestResult = await this.requestQuery.findById(
        actor,
        requestCode,
      );
      if (!requestResult.ok || !requestResult.value) {
        return await this.fail(requestCode, tenant, 'request_not_found');
      }

      const request = requestResult.value;

      // Safely extract data from the request (handle Option type)
      const requestData = Option.isSome(request)
        ? (request.value.data ?? {})
        : {};
      const recipient = Option.isSome(request)
        ? request.value.recipient
        : undefined;

      // 3. Extract tenant configuration
      const { workspace, template, channel, config } = tenantConfig || {};
      if (!workspace?.botToken) {
        return await this.fail(requestCode, tenant, 'bot_token_missing');
      }

      // Use channel code (assuming it's the Slack channel ID) or fallback to recipient
      const channelId =
        channel?.code || recipient || workspace.defaultChannelId;
      if (!channelId) {
        return await this.fail(requestCode, tenant, 'channel_missing');
      }

      // 4. Render message template
      let renderedBlocks: unknown[];
      if (template) {
        Log.debug(this.logger, 'Rendering template', {
          method: 'handleSendRequest',
          requestCode,
          tenant,
          templateCode: template.code,
          templateName: template.name,
          hasContentBlocks: Array.isArray(template.contentBlocks),
          contentBlocksCount: template.contentBlocks?.length ?? 0,
          requiredVariables: template.variables ?? [],
          providedVariables: Object.keys(requestData),
        });

        const renderRes = this.templateAdapter.renderTemplate({
          template,
          variables: requestData,
        });
        if (!renderRes.ok) {
          Log.error(this.logger, 'Template rendering failed', {
            method: 'handleSendRequest',
            requestCode,
            tenant,
            templateCode: template.code,
            renderError: renderRes.error,
            contentBlocks: template.contentBlocks,
            variables: requestData,
          });

          // Fallback to default message instead of failing completely
          Log.info(
            this.logger,
            'Using fallback message due to template error',
            {
              method: 'handleSendRequest',
              requestCode,
              tenant,
            },
          );

          renderedBlocks = [
            {
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: `⚠️ Message from ${workspace.name} (template error: ${renderRes.error})`,
              },
            },
          ];
        } else {
          renderedBlocks = Array.isArray(renderRes.value)
            ? renderRes.value
            : [renderRes.value];

          Log.debug(this.logger, 'Template rendered successfully', {
            method: 'handleSendRequest',
            requestCode,
            tenant,
            renderedBlocksCount: Array.isArray(renderedBlocks)
              ? renderedBlocks.length
              : 1,
          });
        }
      } else {
        // Default message block if no template
        renderedBlocks = [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `Message from ${workspace.name}`,
            },
          },
        ];

        Log.debug(this.logger, 'Using default message (no template)', {
          method: 'handleSendRequest',
          requestCode,
          tenant,
        });
      }

      // 5. Send via Slack API with internal retry logic (no BullMQ retries)
      const maxAttempts = config?.maxRetryAttempts ?? 3;
      const baseBackoff = config?.retryBackoffSeconds ?? 2;

      let attempt = 0;
      let lastErr: string | undefined;

      while (attempt < maxAttempts) {
        attempt++;

        Log.debug(this.logger, 'Attempting Slack API send', {
          method: 'handleSendRequest',
          requestCode,
          tenant,
          workspaceCode: workspace.code,
          workspaceName: workspace.name,
          channelId,
          templateCode: template?.code,
          attempt,
          maxAttempts,
          jobId,
        });

        const res = await this.slackApiService.sendMessage({
          botToken: workspace.botToken,
          channel: channelId,
          blocks: renderedBlocks,
          text: `Message from ${workspace.name}`,
          thread_ts: job.data.threadTs || null,
        });

        if (res.ok) {
          // Success - record delivery through application port
          await this.requestAppPort.recordSent({
            code: requestCode,
            attempts: attempt,
            // Note: correlationId, causationId, and actor not available in send-request job data
            // Future: Could be passed through from create-request job
          });

          Log.info(this.logger, 'Request sent successfully', {
            method: 'handleSendRequest',
            jobId,
            requestCode,
            tenant,
            slackTs: res.value.ts,
            slackChannel: res.value.channel,
            attempts: attempt,
          });
          return;
        }

        lastErr = res.error;
        if (!res.retryable) break; // Don't retry non-retryable errors

        // Wait with exponential backoff (honor Slack's Retry-After if present)
        const delay =
          (res.retryAfterSec ?? baseBackoff * Math.pow(2, attempt)) * 1000;
        await this.sleepWithJitter(delay);
      }

      // Final failure after all internal attempts (no BullMQ retry)
      // Record failure through application port
      await this.requestAppPort.recordFailed({
        code: requestCode,
        reason: 'max_attempts_exceeded',
        attempts: attempt,
        retryable: false,
        lastError: lastErr || 'Unknown error after max attempts',
      });

      Log.error(this.logger, 'Request failed after attempts', {
        method: 'handleSendRequest',
        jobId,
        requestCode,
        tenant,
        lastError: lastErr,
        attempts: attempt,
      });

      return; // Don't throw - avoid BullMQ retry
    } catch (error) {
      const e = error as Error;

      // Record failure through application port
      await this.requestAppPort.recordFailed({
        code: requestCode,
        reason: 'unexpected_error',
        attempts: 1, // This is an unexpected error, not a retry
        retryable: false,
        lastError: e.message,
      });

      Log.error(this.logger, 'Error processing send request job', {
        method: 'handleSendRequest',
        jobId,
        requestCode,
        tenant,
        error: e.message,
        stack: e.stack,
      });

      return; // Don't throw - avoid BullMQ retry
    }
  }

  /**
   * Sleep with jitter to avoid thundering herd problems
   */
  private async sleepWithJitter(ms: number): Promise<void> {
    await new Promise((r) =>
      setTimeout(r, Math.floor(ms * (0.8 + Math.random() * 0.4))),
    );
  }

  /**
   * Check idempotency guard to prevent duplicate processing
   * @param tenant - The tenant ID
   * @param requestCode - The request ID
   * @returns Promise<boolean> - true if this is the first time processing, false if already processed
   */
  private async checkIdempotency(
    tenant: string,
    requestCode: string,
  ): Promise<boolean> {
    const idemKey = `idem:slack:send:${tenant}:${requestCode}`;
    try {
      const result = await this.redis.set(idemKey, '1', 'EX', 900, 'NX'); // 15 minutes, only if not exists
      return result === 'OK';
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Failed to check idempotency', {
        method: 'checkIdempotency',
        requestCode,
        tenant,
        error: e.message,
      });
      // On Redis error, allow processing (fail-open approach)
      return true;
    }
  }

  private async fail(
    requestCode: string,
    tenant: string,
    code: string,
  ): Promise<void> {
    // Record failure through application port
    await this.requestAppPort.recordFailed({
      code: requestCode,
      reason: code,
      attempts: 1,
      retryable: false,
      lastError: `Validation failure: ${code}`,
    });

    Log.error(this.logger, 'Request failed', {
      method: 'handleSendRequest',
      requestCode,
      reason: code,
    });

    // Don't throw to avoid BullMQ retries - internal retry logic handles retries
  }

  /**
   * Process retry jobs for failed requests
   */
  async handleRetryFailedRequest(
    job: Job<RequestJobs['retry-failed-request']>,
  ): Promise<void> {
    const { requestCode, tenant, retryReason } = job.data;
    const jobId = job.id;

    Log.info(this.logger, 'Processing retry failed request job', {
      method: 'handleRetryFailedRequest',
      jobId,
      requestCode,
      tenant,
      retryReason,
    });

    try {
      // This would implement retry logic for failed requests
      await new Promise((resolve) => setTimeout(resolve, 100)); // Simulate async work

      Log.info(this.logger, 'Retried failed request successfully', {
        method: 'handleRetryFailedRequest',
        jobId,
        requestCode,
        retryReason,
        status: 'retried',
      });

      // In a real implementation:
      // 1. Fetch failed request
      // 2. Determine retry strategy based on failure reason
      // 3. Re-queue for sending or mark as permanently failed
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing retry request job', {
        method: 'handleRetryFailedRequest',
        jobId,
        requestCode,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }

  /**
   * Process SendRequestJob using the dedicated worker service
   */
  async handleSendRequestJob(job: Job<SendRequestJob>): Promise<void> {
    Log.info(this.logger, 'Processing SendRequestJob', {
      method: 'handleSendRequestJob',
      jobId: job.id,
      requestCode: job.data.requestCode,
      tenant: job.data.tenant,
    });

    try {
      // Delegate to the specialized SendRequestWorkerService
      await this.sendRequestWorkerService.processJob(job);

      Log.info(this.logger, 'Successfully processed SendRequestJob', {
        method: 'handleSendRequestJob',
        jobId: job.id,
        requestCode: job.data.requestCode,
      });
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing SendRequestJob', {
        method: 'handleSendRequestJob',
        jobId: job.id,
        requestCode: job.data.requestCode,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }
}
