// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { Injectable, Inject } from '@nestjs/common';
import { Queue } from 'bullmq';
import { APP_LOGGER, Log, Logger, componentLogger } from 'src/shared/logging';
import { CreateMessageRequestRequest } from '../../application/dtos';
import { IUserToken } from 'src/shared/security';
import { MessageRequestJobs } from '../processors';

/**
 * Message Request Queue Service
 *
 * Service for adding jobs to the MessageRequestQueue for asynchronous processing.
 * Provides methods to queue various message request operations with proper
 * job configuration and error handling.
 */
@Injectable()
export class MessageRequestQueueService {
  private readonly logger: Logger;

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    @Inject('Queue:MessageRequestQueue') private readonly queue: Queue,
  ) {
    this.logger = componentLogger(baseLogger, 'MessageRequestQueueService');
  }

  /**
   * Queue a message request creation job
   */
  async queueCreateMessageRequest(
    user: IUserToken,
    request: CreateMessageRequestRequest,
    options?: {
      idempotencyKey?: string;
      delay?: number;
      priority?: number;
    },
  ): Promise<string> {
    const jobData: MessageRequestJobs['create-message-request'] = {
      user,
      request,
      options: {
        idempotencyKey: options?.idempotencyKey,
      },
    };

    const job = await this.queue.add('create-message-request', jobData, {
      delay: options?.delay || 0,
      priority: options?.priority || 0,
      removeOnComplete: 100,
      removeOnFail: 50,
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000,
      },
    });

    Log.info(this.logger, 'Queued create message request job', {
      method: 'queueCreateMessageRequest',
      jobId: job.id,
      tenant: user.tenant,
      workspaceCode: request.workspaceCode,
      templateCode: request.templateCode,
      channelCode: request.channelCode,
      delay: options?.delay || 0,
      priority: options?.priority || 0,
    });

    return job.id?.toString() || 'unknown';
  }

  /**
   * Queue a message sending job
   */
  async queueSendMessageRequest(
    messageRequestId: string,
    tenant: string,
    options?: {
      delay?: number;
      priority?: number;
    },
  ): Promise<string> {
    const jobData: MessageRequestJobs['send-message-request'] = {
      messageRequestId,
      tenant,
    };

    const job = await this.queue.add('send-message-request', jobData, {
      delay: options?.delay || 0,
      priority: options?.priority || 0,
      removeOnComplete: 100,
      removeOnFail: 50,
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000,
      },
    });

    Log.info(this.logger, 'Queued send message request job', {
      method: 'queueSendMessageRequest',
      jobId: job.id,
      messageRequestId,
      tenant,
      delay: options?.delay || 0,
      priority: options?.priority || 0,
    });

    return job.id?.toString() || 'unknown';
  }

  /**
   * Queue a retry job for failed message requests
   */
  async queueRetryFailedMessageRequest(
    messageRequestId: string,
    tenant: string,
    retryReason: string,
    options?: {
      delay?: number;
      priority?: number;
    },
  ): Promise<string> {
    const jobData: MessageRequestJobs['retry-failed-message-request'] = {
      messageRequestId,
      tenant,
      retryReason,
    };

    const job = await this.queue.add('retry-failed-message-request', jobData, {
      delay: options?.delay || 30000, // Default 30s delay for retries
      priority: options?.priority || 0,
      removeOnComplete: 100,
      removeOnFail: 50,
      attempts: 2, // Fewer attempts for retries
      backoff: {
        type: 'exponential',
        delay: 5000,
      },
    });

    Log.info(this.logger, 'Queued retry failed message request job', {
      method: 'queueRetryFailedMessageRequest',
      jobId: job.id,
      messageRequestId,
      tenant,
      retryReason,
      delay: options?.delay || 30000,
      priority: options?.priority || 0,
    });

    return job.id?.toString() || 'unknown';
  }

  /**
   * Get queue statistics and health information
   */
  async getQueueInfo(): Promise<{
    waiting: number;
    active: number;
    completed: number;
    failed: number;
    delayed: number;
  }> {
    const [waiting, active, completed, failed, delayed] = await Promise.all([
      this.queue.getWaiting(),
      this.queue.getActive(),
      this.queue.getCompleted(),
      this.queue.getFailed(),
      this.queue.getDelayed(),
    ]);

    return {
      waiting: waiting.length,
      active: active.length,
      completed: completed.length,
      failed: failed.length,
      delayed: delayed.length,
    };
  }
}
