// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import {
  Injectable,
  Inject,
  OnModuleInit,
  OnModuleDestroy,
} from '@nestjs/common';
import { Job, Worker } from 'bullmq';
import { APP_LOGGER, Log, Logger, componentLogger } from 'src/shared/logging';
import { AppConfigUtil } from 'src/shared/config/app-config.util';
import { MessageRequestApplicationService } from '../../application/services';
import { CreateMessageRequestRequest } from '../../application/dtos';
import { IUserToken } from 'src/shared/security';

// Import response DTOs for tenant configuration
import { DetailWorkspaceResponse } from 'src/contexts/notification/slack-config/workspace/application/dtos';
import { DetailTemplateResponse } from 'src/contexts/notification/slack-config/template/application/dtos';
import { DetailChannelResponse } from 'src/contexts/notification/slack-config/channel/application/dtos';
import { DetailAppConfigResponse } from 'src/contexts/notification/slack-config/app-config/application/dtos';

// Import Slack API and template services
import { SlackApiService } from 'src/shared/infrastructure/slack/slack-api.service';
import { TemplateRendererService } from '../services/template-renderer.service';

// Import repositories and error handling
import { ActorContext } from 'src/shared/application/context';
import { Option } from 'src/shared/domain/types';
import {
  MESSAGE_REQUEST_QUERY_TOKEN,
  MESSAGE_REQUEST_WRITER_TOKEN,
} from '../../application/ports';
import type {
  IMessageRequestQuery,
  IMessageRequestWriter,
} from '../../application/ports';

/**
 * Message Request Queue Job Types
 */
export interface MessageRequestJobs {
  'create-message-request': {
    user: IUserToken;
    request: CreateMessageRequestRequest;
    options?: {
      idempotencyKey?: string;
    };
  };
  'send-message-request': {
    messageRequestId: string;
    tenant: string;
    threadTs?: string | null;
    tenantConfig?: {
      workspace: DetailWorkspaceResponse;
      template?: DetailTemplateResponse;
      channel?: DetailChannelResponse;
      appConfig?: DetailAppConfigResponse;
    };
  };
  'retry-failed-message-request': {
    messageRequestId: string;
    tenant: string;
    retryReason: string;
  };
}

/**
 * Message Request Queue Processor
 *
 * Handles asynchronous processing of message request operations:
 * - Creating message requests
 * - Sending messages via Slack API
 * - Retrying failed operations
 *
 * Uses BullMQ for reliable job processing with:
 * - Exponential backoff for retries
 * - Job persistence in Redis
 * - Comprehensive logging and monitoring
 */
@Injectable()
export class MessageRequestProcessor implements OnModuleInit, OnModuleDestroy {
  private readonly logger: Logger;
  private worker: Worker | null = null;

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    private readonly messageRequestService: MessageRequestApplicationService,
    private readonly slackApiService: SlackApiService,
    private readonly templateRenderer: TemplateRendererService,
    @Inject(MESSAGE_REQUEST_QUERY_TOKEN)
    private readonly messageRequestQuery: IMessageRequestQuery,
    @Inject(MESSAGE_REQUEST_WRITER_TOKEN)
    private readonly messageRequestWriter: IMessageRequestWriter,
  ) {
    this.logger = componentLogger(baseLogger, 'MessageRequestProcessor');
  }

  /**
   * Initialize the BullMQ worker to process jobs
   */
  onModuleInit(): void {
    const redisConfig = AppConfigUtil.getRedisConfig();
    const environment = AppConfigUtil.getEnvironment();

    // Create the worker with the same configuration as the queue
    this.worker = new Worker(
      'MessageRequestQueue',
      async (job: Job) => {
        Log.info(this.logger, 'Processing job', {
          method: 'onModuleInit.worker',
          jobId: job.id,
          jobName: job.name,
          attempts: job.attemptsMade,
        });

        try {
          // Route to appropriate handler based on job name
          switch (job.name) {
            case 'create-message-request':
              return await this.handleCreateMessageRequest(
                job as Job<MessageRequestJobs['create-message-request']>,
              );
            case 'send-message-request':
              return await this.handleSendMessageRequest(
                job as Job<MessageRequestJobs['send-message-request']>,
              );
            case 'retry-failed-message-request':
              return await this.handleRetryFailedMessageRequest(
                job as Job<MessageRequestJobs['retry-failed-message-request']>,
              );
            default:
              throw new Error(`Unknown job type: ${job.name}`);
          }
        } catch (error) {
          const e = error as Error;
          Log.error(this.logger, 'Job processing failed', {
            method: 'onModuleInit.worker',
            jobId: job.id,
            jobName: job.name,
            error: e.message,
            stack: e.stack,
          });
          throw error; // Re-throw to trigger BullMQ retry logic
        }
      },
      {
        connection: {
          host: redisConfig.host,
          port: redisConfig.port,
          db: redisConfig.database,
        },
        prefix: `${environment}:message-request:`,
        concurrency: 5, // Process up to 5 jobs concurrently
        limiter: {
          max: 10,
          duration: 60000, // 10 jobs per minute rate limiting
        },
      },
    );

    // Add event listeners for monitoring
    this.worker.on('completed', (job) => {
      Log.info(this.logger, 'Job completed successfully', {
        method: 'worker.completed',
        jobId: job.id,
        jobName: job.name,
        processingTime: job.finishedOn
          ? job.finishedOn - job.processedOn!
          : 'unknown',
      });
    });

    this.worker.on('failed', (job, err) => {
      Log.error(this.logger, 'Job failed', {
        method: 'worker.failed',
        jobId: job?.id,
        jobName: job?.name,
        attempts: job?.attemptsMade,
        error: err.message,
      });
    });

    this.worker.on('error', (err) => {
      Log.error(this.logger, 'Worker error', {
        method: 'worker.error',
        error: err.message,
        stack: err.stack,
      });
    });

    Log.info(this.logger, 'MessageRequestProcessor worker started', {
      method: 'onModuleInit',
      queueName: 'MessageRequestQueue',
      concurrency: 5,
      prefix: `${environment}:message-request:`,
    });
  }

  /**
   * Clean up the worker on module destroy
   */
  async onModuleDestroy(): Promise<void> {
    if (this.worker) {
      Log.info(this.logger, 'Stopping MessageRequestProcessor worker', {
        method: 'onModuleDestroy',
      });

      await this.worker.close();
      this.worker = null;

      Log.info(this.logger, 'MessageRequestProcessor worker stopped', {
        method: 'onModuleDestroy',
      });
    }
  }

  /**
   * Process message request creation jobs
   */
  async handleCreateMessageRequest(
    job: Job<MessageRequestJobs['create-message-request']>,
  ): Promise<void> {
    const { user, request, options } = job.data;
    const jobId = job.id;

    Log.info(this.logger, 'Processing create message request job', {
      method: 'handleCreateMessageRequest',
      jobId,
      tenant: user.tenant,
      workspaceCode: request.workspaceCode,
      templateCode: request.templateCode,
      channelCode: request.channelCode,
      idempotencyKey: options?.idempotencyKey,
    });

    try {
      const result = await this.messageRequestService.createMessageRequest(
        user,
        request,
        options,
      );

      if (!result.ok) {
        Log.error(this.logger, 'Failed to create message request in job', {
          method: 'handleCreateMessageRequest',
          jobId,
          error: result.error.detail,
          context: result.error.context,
        });
        throw new Error(result.error.detail);
      }

      Log.info(this.logger, 'Successfully created message request in job', {
        method: 'handleCreateMessageRequest',
        jobId,
        messageRequestId: result.value.id,
        status: result.value.status,
      });

      // Optionally trigger next job in the pipeline (send message)
      if (result.value.status === 'validated') {
        // Could add job to send the message
        Log.debug(this.logger, 'Message request ready for sending', {
          method: 'handleCreateMessageRequest',
          jobId,
          messageRequestId: result.value.id,
          nextStep: 'send-message-request',
        });
      }
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing create message request job', {
        method: 'handleCreateMessageRequest',
        jobId,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }

  /**
   * Process message sending jobs with tenant configuration and Slack API integration
   */
  async handleSendMessageRequest(
    job: Job<MessageRequestJobs['send-message-request']>,
  ): Promise<void> {
    const { messageRequestId, tenant, tenantConfig } = job.data;
    const jobId = job.id;
    const actor: ActorContext = {
      tenant,
      userId: 'system',
      tenant_userId: 'system',
    };

    Log.info(this.logger, 'Processing send message request job', {
      method: 'handleSendMessageRequest',
      jobId,
      messageRequestId,
      tenant,
      hasConfig: !!tenantConfig,
    });

    try {
      // 1. Fetch message request details
      const requestResult = await this.messageRequestQuery.findById(
        actor,
        messageRequestId,
      );
      if (!requestResult.ok || !requestResult.value) {
        this.fail(messageRequestId, 'request_not_found');
        return;
      }

      const request = requestResult.value;

      // 2. Extract tenant configuration
      const { workspace, template, channel, appConfig } = tenantConfig || {};
      if (!workspace) {
        this.fail(messageRequestId, 'workspace_missing');
        return;
      }

      const botToken = workspace.botToken;
      if (!botToken) {
        this.fail(messageRequestId, 'bot_token_missing');
        return;
      }

      // Safely extract properties from Option type
      const recipient = Option.isSome(request)
        ? request.value.recipient
        : undefined;
      const requestData = Option.isSome(request)
        ? request.value.data || {}
        : {};

      const channelId =
        channel?.code || recipient || workspace.defaultChannelId;
      if (!channelId) {
        this.fail(messageRequestId, 'channel_missing');
        return;
      }

      // 3. Render message template if available
      let renderedBlocks: unknown[] = [];
      if (template) {
        const renderResult = this.templateRenderer.renderTemplate({
          template,
          variables: requestData,
        });
        if (!renderResult.ok) {
          this.fail(messageRequestId, `render_error:${renderResult.error}`);
          return;
        }
        renderedBlocks = renderResult.value as unknown[];
      } else {
        // Default message block if no template
        renderedBlocks = [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `Message from ${workspace.name}`,
            },
          },
        ];
      }

      // 4. Send via Slack API with retry logic
      const maxAttempts = appConfig?.maxRetryAttempts ?? 3;
      const baseBackoff = appConfig?.retryBackoffSeconds ?? 2;

      let attempt = 0;
      let lastErr: string | undefined;

      while (attempt < maxAttempts) {
        attempt++;
        const res = await this.slackApiService.sendMessage({
          botToken,
          channel: channelId,
          blocks: renderedBlocks,
          text: `Message from ${workspace.name}`,
          thread_ts: job.data.threadTs || null,
        });

        if (res.ok) {
          // Success - log and exit (no status update since writer doesn't support it)
          Log.info(this.logger, 'Message request sent successfully', {
            method: 'handleSendMessageRequest',
            jobId,
            messageRequestId,
            slackTs: res.value.ts,
            slackChannel: res.value.channel,
            attempts: attempt,
          });
          return;
        }

        lastErr = res.error;
        if (!res.retryable) break; // Don't retry non-retryable errors

        // Wait with exponential backoff and jitter
        const delay =
          (res.retryAfterSec ?? baseBackoff * Math.pow(2, attempt)) * 1000;
        await this.sleepWithJitter(delay);
      }

      // All attempts failed
      Log.error(this.logger, 'Message request failed after all attempts', {
        method: 'handleSendMessageRequest',
        jobId,
        messageRequestId,
        lastError: lastErr,
        attempts: attempt,
      });

      // Re-throw to trigger BullMQ retry logic
      throw new Error(`Slack message send failed: ${lastErr}`);
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing send message request job', {
        method: 'handleSendMessageRequest',
        jobId,
        messageRequestId,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }

  private async sleepWithJitter(ms: number): Promise<void> {
    await new Promise((r) =>
      setTimeout(r, Math.floor(ms * (0.8 + Math.random() * 0.4))),
    );
  }

  private fail(messageRequestId: string, code: string): never {
    Log.error(this.logger, 'Message request failed', {
      method: 'handleSendMessageRequest',
      messageRequestId,
      reason: code,
    });

    // Since we can't update status through writer, throw error to trigger retry
    throw new Error(`Message request failed: ${code}`);
  }

  /**
   * Process retry jobs for failed message requests
   */
  async handleRetryFailedMessageRequest(
    job: Job<MessageRequestJobs['retry-failed-message-request']>,
  ): Promise<void> {
    const { messageRequestId, tenant, retryReason } = job.data;
    const jobId = job.id;

    Log.info(this.logger, 'Processing retry failed message request job', {
      method: 'handleRetryFailedMessageRequest',
      jobId,
      messageRequestId,
      tenant,
      retryReason,
    });

    try {
      // This would implement retry logic for failed message requests
      await new Promise((resolve) => setTimeout(resolve, 100)); // Simulate async work

      Log.info(this.logger, 'Retried failed message request successfully', {
        method: 'handleRetryFailedMessageRequest',
        jobId,
        messageRequestId,
        retryReason,
        status: 'retried',
      });

      // In a real implementation:
      // 1. Fetch failed message request
      // 2. Determine retry strategy based on failure reason
      // 3. Re-queue for sending or mark as permanently failed
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing retry message request job', {
        method: 'handleRetryFailedMessageRequest',
        jobId,
        messageRequestId,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }
}
