// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { Injectable, Inject } from '@nestjs/common';
import { Job, Worker } from 'bullmq';
import { APP_LOGGER, Log, Logger, componentLogger } from 'src/shared/logging';
import { MessageRequestApplicationService } from '../../application/services';
import { CreateMessageRequestRequest } from '../../application/dtos';
import { IUserToken } from 'src/shared/security';

/**
 * Message Request Queue Job Types
 */
export interface MessageRequestJobs {
  'create-message-request': {
    user: IUserToken;
    request: CreateMessageRequestRequest;
    options?: {
      idempotencyKey?: string;
    };
  };
  'send-message-request': {
    messageRequestId: string;
    tenant: string;
  };
  'retry-failed-message-request': {
    messageRequestId: string;
    tenant: string;
    retryReason: string;
  };
}

/**
 * Message Request Queue Processor
 *
 * Handles asynchronous processing of message request operations:
 * - Creating message requests
 * - Sending messages via Slack API
 * - Retrying failed operations
 *
 * Uses BullMQ for reliable job processing with:
 * - Exponential backoff for retries
 * - Job persistence in Redis
 * - Comprehensive logging and monitoring
 */
@Injectable()
export class MessageRequestProcessor {
  private readonly logger: Logger;

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    private readonly messageRequestService: MessageRequestApplicationService,
  ) {
    this.logger = componentLogger(baseLogger, 'MessageRequestProcessor');
  }

  /**
   * Process message request creation jobs
   */
  async handleCreateMessageRequest(
    job: Job<MessageRequestJobs['create-message-request']>,
  ): Promise<void> {
    const { user, request, options } = job.data;
    const jobId = job.id;

    Log.info(this.logger, 'Processing create message request job', {
      method: 'handleCreateMessageRequest',
      jobId,
      tenant: user.tenant,
      workspaceCode: request.workspaceCode,
      templateCode: request.templateCode,
      channelCode: request.channelCode,
      idempotencyKey: options?.idempotencyKey,
    });

    try {
      const result = await this.messageRequestService.createMessageRequest(
        user,
        request,
        options,
      );

      if (!result.ok) {
        Log.error(this.logger, 'Failed to create message request in job', {
          method: 'handleCreateMessageRequest',
          jobId,
          error: result.error.detail,
          context: result.error.context,
        });
        throw new Error(result.error.detail);
      }

      Log.info(this.logger, 'Successfully created message request in job', {
        method: 'handleCreateMessageRequest',
        jobId,
        messageRequestId: result.value.id,
        status: result.value.status,
      });

      // Optionally trigger next job in the pipeline (send message)
      if (result.value.status === 'validated') {
        // Could add job to send the message
        Log.debug(this.logger, 'Message request ready for sending', {
          method: 'handleCreateMessageRequest',
          jobId,
          messageRequestId: result.value.id,
          nextStep: 'send-message-request',
        });
      }
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing create message request job', {
        method: 'handleCreateMessageRequest',
        jobId,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }

  /**
   * Process message sending jobs
   */
  async handleSendMessageRequest(
    job: Job<MessageRequestJobs['send-message-request']>,
  ): Promise<void> {
    const { messageRequestId, tenant } = job.data;
    const jobId = job.id;

    Log.info(this.logger, 'Processing send message request job', {
      method: 'handleSendMessageRequest',
      jobId,
      messageRequestId,
      tenant,
    });

    try {
      // This would integrate with Slack API or other messaging services
      // For now, just log the intent
      await new Promise((resolve) => setTimeout(resolve, 100)); // Simulate async work

      Log.info(this.logger, 'Message request sent successfully', {
        method: 'handleSendMessageRequest',
        jobId,
        messageRequestId,
        status: 'sent',
      });

      // In a real implementation:
      // 1. Fetch message request details
      // 2. Format message using template
      // 3. Send via Slack API
      // 4. Update message request status to 'sent' or 'failed'
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing send message request job', {
        method: 'handleSendMessageRequest',
        jobId,
        messageRequestId,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }

  /**
   * Process retry jobs for failed message requests
   */
  async handleRetryFailedMessageRequest(
    job: Job<MessageRequestJobs['retry-failed-message-request']>,
  ): Promise<void> {
    const { messageRequestId, tenant, retryReason } = job.data;
    const jobId = job.id;

    Log.info(this.logger, 'Processing retry failed message request job', {
      method: 'handleRetryFailedMessageRequest',
      jobId,
      messageRequestId,
      tenant,
      retryReason,
    });

    try {
      // This would implement retry logic for failed message requests
      await new Promise((resolve) => setTimeout(resolve, 100)); // Simulate async work

      Log.info(this.logger, 'Retried failed message request successfully', {
        method: 'handleRetryFailedMessageRequest',
        jobId,
        messageRequestId,
        retryReason,
        status: 'retried',
      });

      // In a real implementation:
      // 1. Fetch failed message request
      // 2. Determine retry strategy based on failure reason
      // 3. Re-queue for sending or mark as permanently failed
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error processing retry message request job', {
        method: 'handleRetryFailedMessageRequest',
        jobId,
        messageRequestId,
        error: e.message,
        stack: e.stack,
      });
      throw error; // Re-throw to trigger BullMQ retry logic
    }
  }
}
