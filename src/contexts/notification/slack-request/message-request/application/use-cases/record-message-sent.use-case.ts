// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Inject } from '@nestjs/common';
import { Result, DomainError, ok, err } from 'src/shared/errors';
import { ActorContext } from 'src/shared/application/context';

// Shared utilities and infrastructure
import { APP_LOGGER, componentLogger, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';

import {
  UseCaseLoggingUtil,
  UseCaseLoggingConfig,
} from 'src/shared/application/utils/use-case-logging.util';
import { IUserToken } from 'src/shared/security';

// Service configuration
import { SlackRequestServiceConstants } from '../../../service-constants';

// Domain types and errors
import { MessageRequestAggregate } from '../../domain/aggregates';
import { MessageRequestEntity } from '../../domain/entities/message-request.entity';
import { createMessageRequestId } from '../../domain/value-objects/id.vo';
import { MessageRequestErrors } from '../../domain/errors';
import { Option } from 'src/shared/domain/types/option';
import { EventMetadata } from 'src/shared/domain/events';
import { SystemClock } from 'src/shared/infrastructure/time';

// Application layer

import {
  IMessageRequestReader,
  IMessageRequestWriter,
  MESSAGE_REQUEST_READER_TOKEN,
  MESSAGE_REQUEST_WRITER_TOKEN,
} from '../ports';
import {
  MessageRequestForeignKeyValidatorService,
  MessageRequestAuthorizationAdapter,
} from '../services';
import { DetailMessageRequestResponse } from '../dtos';
import { MessageRequestDtoAssembler } from '../assemblers';
import { IRecordMessageSentUseCase } from './contracts';
import { RecordMessageSentProps } from '../../domain/props';

// Shared compliance services
import {
  PIIClassificationService,
  PIIProtectionService,
  DataRetentionService,
} from 'src/shared/services/compliance';

@Injectable()
export class RecordMessageSentUseCase implements IRecordMessageSentUseCase {
  private readonly logger: Logger;
  private readonly loggingConfig: UseCaseLoggingConfig;

  constructor(
    @Inject(MESSAGE_REQUEST_READER_TOKEN)
    private readonly messageRequestReader: IMessageRequestReader,
    @Inject(MESSAGE_REQUEST_WRITER_TOKEN)
    private readonly messageRequestWriter: IMessageRequestWriter,
    private readonly foreignKeyValidator: MessageRequestForeignKeyValidatorService,
    private readonly authorizationService: MessageRequestAuthorizationAdapter,
    @Inject(APP_LOGGER)
    readonly moduleLogger: Logger,
    @Inject(CLOCK)
    private readonly clock: Clock,
    private readonly piiClassificationService: PIIClassificationService,
    private readonly piiProtectionService: PIIProtectionService,
    private readonly dataRetentionService: DataRetentionService,
  ) {
    this.loggingConfig = {
      serviceName: SlackRequestServiceConstants.SERVICE_NAME,
      component: 'RecordMessageSentUseCase',
      domain: 'slack-request',
      entityType: 'message-request',
    };
    this.logger = componentLogger(moduleLogger, this.loggingConfig.component);
  }

  async execute(params: {
    user: IUserToken;
    props: RecordMessageSentProps;
    correlationId: string;
    authorizationReason: string;
  }): Promise<Result<DetailMessageRequestResponse, DomainError>> {
    const operation = 'record_message_sent';
    const startTime = this.clock.nowMs();

    // Create a command-like object for internal use
    const command = {
      user: params.user,
      props: params.props,
      correlationId: params.correlationId,
      authorizationReason: params.authorizationReason,
      securityContext: {
        tenant: params.user.tenant,
        userId: params.user.sub,
        roles: params.user.roles,
      },
      timestamp: this.clock.now(),
    };

    // Step 1: Validate command (before creating any log context to avoid PII logging)
    const validation = UseCaseLoggingUtil.validateCommand(
      this.logger,
      command,
      {}, // Empty context to avoid PII logging during validation
    );
    if (!validation.ok) {
      return err(validation.error);
    }

    // Step 2: Check PII compliance for input data with domain context
    const classification = this.piiClassificationService.classifyData(
      {},
      {
        domain: 'slack-request',
        tenant: command.user.tenant,
        // entityType: 'MessageRequest' // Future: for entity-level rules
      },
    );

    // Step 3: Create safe log context (no raw command that might contain PII)
    const safeLogContext = UseCaseLoggingUtil.createLogContext(
      this.loggingConfig,
      this.clock,
      operation,
      {
        correlationId: command.correlationId,
        user: command.user,
        securityContext: command.securityContext,
        timestamp: command.timestamp,
      },
      {
        operationRisk: UseCaseLoggingUtil.assessOperationRisk(operation),
        messageRequestId: params.props.id,
        attempts: params.props.attempts,
      },
    );

    // Log compliance check with detailed audit trail
    UseCaseLoggingUtil.logComplianceCheck(
      this.logger,
      operation,
      safeLogContext,
      classification,
    );

    // Step 4: Execute the update operation (following adapter pattern but with better structure)
    let updateResult: Result<MessageRequestAggregate, DomainError>;

    try {
      // Create message request ID value object
      const messageRequestIdResult = createMessageRequestId(params.props.id);
      if (!messageRequestIdResult.ok) {
        return err(MessageRequestErrors.INVALID_ID);
      }

      // Create actor context
      const actor: ActorContext = {
        tenant: params.user.tenant,
        userId: params.user.sub,
        tenant_userId: params.user.tenant_id ?? params.user.sub,
        roles: params.user.roles || [],
      };

      // Load aggregate snapshot
      const snapshotResult = await this.messageRequestReader.findById(
        actor,
        messageRequestIdResult.value,
      );
      if (!snapshotResult.ok) {
        return err(snapshotResult.error);
      }

      if (!snapshotResult.value || Option.isNone(snapshotResult.value)) {
        return err(MessageRequestErrors.INVALID_ID);
      }

      // Reconstitute entity from snapshot
      const entityResult = MessageRequestEntity.fromSnapshot(
        snapshotResult.value.value,
      );
      if (!entityResult.ok) {
        return err(entityResult.error);
      }

      // Create event metadata
      const eventMetadata: EventMetadata = {
        correlationId: params.correlationId,
        causationId: params.props.causationId,
        actor: {
          ...actor,
          sessionId: 'record-message-sent-use-case',
        },
        service: 'notification-service',
        timestampIso: new SystemClock().nowIso(),
        eventVersion: '1.0.0',
        schemaVersion: '2023.1',
      };

      // Reconstitute aggregate from entity
      const aggregate = MessageRequestAggregate.reconstitute(
        entityResult.value,
        new SystemClock(),
        eventMetadata,
      );

      // Apply domain operation
      const sentResult = aggregate.markSent({
        attempts: params.props.attempts,
      });

      if (!sentResult.ok) {
        return err(sentResult.error);
      }

      // Save the updated aggregate
      const saveResult = await this.messageRequestWriter.save(actor, aggregate);
      if (!saveResult.ok) {
        return err(saveResult.error);
      }

      updateResult = ok(aggregate);
    } catch (error) {
      return err({
        ...MessageRequestErrors.INVALID_MESSAGE_REQUEST_DATA,
        detail: error instanceof Error ? error.message : 'Unknown error',
      });
    }

    // Step 5: Handle errors
    if (!updateResult.ok) {
      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        updateResult.error,
        'HIGH',
      );
      return updateResult;
    }

    const aggregate = updateResult.value;

    // Step 6: Get domain state directly from aggregate (clean architecture)
    const domainState = aggregate.toDomainState();
    const dto = MessageRequestDtoAssembler.toDetailResponse(domainState);

    // Log operation success with comprehensive metrics
    const executionTime = this.clock.nowMs() - startTime;
    UseCaseLoggingUtil.logOperationSuccess(
      this.logger,
      operation,
      safeLogContext,
      {
        executionTimeMs: executionTime,
        aggregateVersion: aggregate.version,
        eventCount: aggregate.uncommittedEvents?.length ?? 0,
        businessData: {
          messageRequestCode: dto.id,
          deliveryRecorded: true,
        },
      },
    );

    return ok(dto);
  }
}
