// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { EntityIdBase } from 'src/shared/domain/entities';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { MessageRequestSnapshotProps } from '../props';
import { MessageRequestDomainState } from '../state';
import { MessageRequestErrors } from '../errors/message-request.errors';
import {
  MessageRequestChannelCode,
  MessageRequestCreatedAt,
  MessageRequestUpdatedAt,
  MessageRequestVersion,
  MessageRequestData,
  MessageRequestId,
  MessageRequestRecipient,
  MessageRequestStatus,
  MessageRequestStatusLogic,
  MessageRequestStatusValue,
  MessageRequestTemplateCode,
  MessageRequestWorkspaceCode,
  createMessageRequestStatus,
} from '../value-objects';

/**
 * Domain Entity: MessageRequest
 *
 * Represents the core MessageRequest entity in the notification domain.
 * Encapsulates messageRequest data, identity, and basic entity behavior.
 *
 * This entity follows DDD principles:
 * - Identity: Id as unique identifier
 * - Immutability: Changes create new instances
 * - Encapsulation: Private state with controlled access
 * - Business validation: Domain rules enforced
 *
 * @domain Notification Context - MessageRequest Entity
 * @layer Domain Entities
 */

/**
 * MessageRequest Entity
 *
 * Core domain entity representing a messageRequest in the notification.
 * Handles messageRequest identity, validation, and state management.
 */
export class MessageRequestEntity extends EntityIdBase<
  MessageRequestDomainState,
  MessageRequestId
> {
  private static clock: { now: () => Date } = { now: () => new Date() };

  public static setClock(c: { now: () => Date }) {
    this.clock = c;
  }

  /**
   * Helper method to create updatedAt VO from date
   */
  private static createUpdatedAt(
    date?: Date,
  ): Result<MessageRequestUpdatedAt, DomainError> {
    const targetDate = date || MessageRequestEntity.clock.now();
    const result = MessageRequestUpdatedAt.from(targetDate);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create version VO from number
   */
  private static createVersion(
    versionNumber?: number,
    currentVersion?: MessageRequestVersion,
  ): Result<MessageRequestVersion, DomainError> {
    const targetVersion = versionNumber ?? currentVersion?.value ?? 1;
    const result = MessageRequestVersion.from(targetVersion);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create updated entity with common logic
   */
  private createUpdatedEntity(
    fieldUpdates: Partial<MessageRequestDomainState>,
    updatedAt?: Date,
    version?: number,
  ): Result<MessageRequestEntity, DomainError> {
    const updatedAtResult = MessageRequestEntity.createUpdatedAt(updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = MessageRequestEntity.createVersion(
      version,
      this.props.version,
    );
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const updatedProps: MessageRequestDomainState = {
      ...this.props,
      ...fieldUpdates,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return MessageRequestEntity.create(updatedProps);
  }

  private constructor(props: MessageRequestDomainState) {
    super(props, props.id);
  }

  /**
   * Factory method to create a new messageRequest entity
   *
   * @param props - MessageRequest properties
   * @returns Result containing MessageRequestEntity or DomainError
   */
  public static create(
    props: MessageRequestDomainState,
  ): Result<MessageRequestEntity, DomainError> {
    // Validate required properties
    const validationResult = MessageRequestEntity.validate(props);
    if (validationResult.ok === false) {
      return err(validationResult.error);
    }

    return ok(new MessageRequestEntity(props));
  }

  /**
   * Factory method to reconstitute a messageRequest entity from persistence
   *
   * @param props - MessageRequest properties from database
   * @returns MessageRequestEntity instance
   */
  public static reconstitute(
    props: MessageRequestDomainState,
  ): MessageRequestEntity {
    return new MessageRequestEntity(props);
  }

  /**
   * Factory method to reconstitute entity from snapshot
   *
   * @param snapshot - MessageRequest snapshot properties
   * @returns Result containing MessageRequestEntity or DomainError
   */
  public static fromSnapshot(
    snapshot: MessageRequestSnapshotProps,
  ): Result<MessageRequestEntity, DomainError> {
    const idResult = MessageRequestId.from(snapshot.id);
    if (!idResult.ok) {
      return err(idResult.error);
    }
    const recipientResult = MessageRequestRecipient.from(snapshot.recipient);
    if (!recipientResult.ok) {
      return err(recipientResult.error);
    }
    const dataResult = MessageRequestData.from(snapshot.data);
    if (!dataResult.ok) {
      return err(dataResult.error);
    }
    const statusResult = createMessageRequestStatus(snapshot.status);
    if (!statusResult.ok) {
      return err(statusResult.error);
    }
    const workspaceCodeResult = MessageRequestWorkspaceCode.from(
      snapshot.workspaceCode,
    );
    if (!workspaceCodeResult.ok) {
      return err(workspaceCodeResult.error);
    }
    const templateCodeResult = MessageRequestTemplateCode.from(
      snapshot.templateCode,
    );
    if (!templateCodeResult.ok) {
      return err(templateCodeResult.error);
    }
    const channelCodeResult = MessageRequestChannelCode.from(
      snapshot.channelCode,
    );
    if (!channelCodeResult.ok) {
      return err(channelCodeResult.error);
    }
    const createdAtResult = MessageRequestCreatedAt.from(snapshot.createdAt);
    if (!createdAtResult.ok) {
      return err(createdAtResult.error);
    }

    const updatedAtResult = MessageRequestUpdatedAt.from(snapshot.updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = MessageRequestVersion.from(snapshot.version);
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const props: MessageRequestDomainState = {
      id: idResult.value,
      recipient: recipientResult.value,
      data: dataResult.value,
      status: statusResult.value,
      workspaceCode: workspaceCodeResult.value,
      templateCode: templateCodeResult.value,
      channelCode: channelCodeResult.value,
      createdAt: createdAtResult.value,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return MessageRequestEntity.create(props);
  }

  /**
   * Validates messageRequest entity properties
   *
   * @param props - Properties to validate
   * @returns Validation result
   */
  private static validate(
    props: MessageRequestDomainState,
  ): Result<void, DomainError> {
    // Basic validation
    if (!props.id) {
      return err(MessageRequestErrors.INVALID_ID_DATA);
    }
    if (!props.workspaceCode) {
      return err(MessageRequestErrors.INVALID_WORKSPACE_CODE_DATA);
    }
    if (!props.templateCode) {
      return err(MessageRequestErrors.INVALID_TEMPLATE_CODE_DATA);
    }

    return ok(undefined);
  }

  // ======================
  // Getters (Public API)
  // ======================

  public get id(): MessageRequestId {
    return this.props.id;
  }

  public get recipient(): MessageRequestRecipient | undefined {
    return this.props.recipient;
  }

  public get data(): MessageRequestData | undefined {
    return this.props.data;
  }

  public get status(): MessageRequestStatus | undefined {
    return this.props.status;
  }

  public get workspaceCode(): MessageRequestWorkspaceCode {
    return this.props.workspaceCode;
  }

  public get templateCode(): MessageRequestTemplateCode {
    return this.props.templateCode;
  }

  public get channelCode(): MessageRequestChannelCode | undefined {
    return this.props.channelCode;
  }

  public get createdAt(): MessageRequestCreatedAt {
    return this.props.createdAt;
  }

  public get updatedAt(): MessageRequestUpdatedAt {
    return this.props.updatedAt;
  }

  public get version(): MessageRequestVersion {
    return this.props.version;
  }

  // ======================
  // Simple Update Methods (No Business Logic)
  // ======================

  /**
   * Creates a new entity with updated recipient (pure state transition)
   *
   * @param recipient - New recipient value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<MessageRequestEntity, DomainError>
   */
  public withRecipient(
    recipient: MessageRequestRecipient,
    updatedAt?: Date,
    version?: number,
  ): Result<MessageRequestEntity, DomainError> {
    return this.createUpdatedEntity({ recipient }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated data (pure state transition)
   *
   * @param data - New data value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<MessageRequestEntity, DomainError>
   */
  public withData(
    data: MessageRequestData,
    updatedAt?: Date,
    version?: number,
  ): Result<MessageRequestEntity, DomainError> {
    return this.createUpdatedEntity({ data }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated status (with basic transition validation)
   *
   * @param status - New status value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<MessageRequestEntity, DomainError>
   */
  public withStatus(
    status: MessageRequestStatus,
    updatedAt?: Date,
    version?: number,
  ): Result<MessageRequestEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    if (this.props.status) {
      // If current status exists, validate transition
      const currentStatus = this.props.status.value;
      const targetStatus = status.value;

      if (
        !MessageRequestStatusLogic.canTransition(currentStatus, targetStatus)
      ) {
        return err({
          ...MessageRequestErrors.INVALID_STATUS_TRANSITION,
          context: {
            currentStatus,
            targetStatus,
            validTransitions:
              MessageRequestStatusLogic.getValidTransitions(currentStatus),
          },
        });
      }
    }

    return this.createUpdatedEntity({ status }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated workspaceCode (pure state transition)
   *
   * @param workspaceCode - New workspace_code value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<MessageRequestEntity, DomainError>
   */
  public withWorkspaceCode(
    workspaceCode: MessageRequestWorkspaceCode,
    updatedAt?: Date,
    version?: number,
  ): Result<MessageRequestEntity, DomainError> {
    return this.createUpdatedEntity({ workspaceCode }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated templateCode (pure state transition)
   *
   * @param templateCode - New template_code value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<MessageRequestEntity, DomainError>
   */
  public withTemplateCode(
    templateCode: MessageRequestTemplateCode,
    updatedAt?: Date,
    version?: number,
  ): Result<MessageRequestEntity, DomainError> {
    return this.createUpdatedEntity({ templateCode }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated channelCode (pure state transition)
   *
   * @param channelCode - New channel_code value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<MessageRequestEntity, DomainError>
   */
  public withChannelCode(
    channelCode: MessageRequestChannelCode,
    updatedAt?: Date,
    version?: number,
  ): Result<MessageRequestEntity, DomainError> {
    return this.createUpdatedEntity({ channelCode }, updatedAt, version);
  }

  /**
   * Get valid next statuses from current state
   * @returns readonly MessageRequestStatusValue[]
   */
  public getValidStatusTransitions(): readonly MessageRequestStatusValue[] {
    // Get valid next statuses from current state
    if (!this.props.status) {
      return []; // No transitions possible if no current status
    }
    return MessageRequestStatusLogic.getValidTransitions(
      this.props.status.value,
    );
  }

  // ======================
  // Query Methods
  // ======================

  /**
   * Checks if two messageRequests are the same entity
   *
   * @param other - Other messageRequest to compare
   */
  public sameAs(other: MessageRequestEntity): boolean {
    return this.props.id.equals(other.props.id);
  }

  /**
   * Gets a snapshot of current entity state for serialization
   */
  public toSnapshot(): MessageRequestSnapshotProps {
    return {
      id: this.props.id.value,
      recipient: this.props.recipient?.value,
      data: this.props.data?.value,
      status: this.props.status?.value,
      workspaceCode: this.props.workspaceCode.value,
      templateCode: this.props.templateCode.value,
      channelCode: this.props.channelCode?.value,
      createdAt: this.props.createdAt.value,
      updatedAt: this.props.updatedAt.value,
      version: this.props.version.value,
    };
  }

  /**
   * Gets the current domain state with value objects
   *
   * Provides access to the rich domain state for application layer
   * without requiring infrastructure mappers. Maintains clean architecture.
   *
   * @returns Current domain state with value objects
   */
  public getDomainState(): MessageRequestDomainState {
    return this.props;
  }
}
