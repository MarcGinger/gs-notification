// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Config Projector - ESDB to PostgreSQL Projection (SQL-Only)
// Optimized for moderate traffic and configuration domains with simplified architecture

import {
  Injectable,
  Inject,
  OnModuleInit,
  OnModuleDestroy,
} from '@nestjs/common';
import { DataSource, QueryRunner } from 'typeorm';
import {
  CatchUpRunner,
  ProjectionEvent,
  RunOptions,
} from 'src/shared/infrastructure/projections/catchup.runner';
import { PostgreSQLCheckpointStore } from 'src/shared/infrastructure/projections/postgresql-checkpoint.store';
import { BaseProjector } from 'src/shared/infrastructure/projections/base.projector';
import {
  CommonProjectorErrorDefinitions,
  createProjectorErrorCatalog,
  TenantExtractor,
} from 'src/shared/infrastructure/projections/projection.utils';
import { APP_LOGGER, Log, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import { withContext } from 'src/shared/errors';
import { safeParseJSON } from 'src/shared/infrastructure/repositories';
import { SLACK_CONFIG_DI_TOKENS } from '../../../slack-config.constants';
import { ConfigProjectionKeys } from '../../config-projection-keys';
import { DetailConfigResponse } from '../../application/dtos';
import { ConfigFieldValidatorUtil } from '../utilities/config-field-validator.util';
import {
  ConfigRowQueries,
  ConfigProjectionUpsertResult,
  ConfigRowMappers,
} from '../schemas/config.schema';

/**
 * Config projector error catalog using shared error definitions
 */
const ConfigProjectorErrors = createProjectorErrorCatalog(
  'CONFIG_PROJECTOR',
  CommonProjectorErrorDefinitions,
);

/**
 * Config row parameters for PostgreSQL projection operations
 *
 * Extends DetailConfigResponse with projection-specific fields needed for event sourcing.
 *
 * Key Additions:
 * - tenant: Multi-tenant support for data isolation
 * - version: Optimistic concurrency control via SQL
 * - deletedAt: Soft delete timestamp for audit purposes
 * - lastStreamRevision: Event sourcing revision tracking
 */
interface ConfigRowParams extends DetailConfigResponse {
  // Projection-specific fields for PostgreSQL storage
  tenant: string;
  version: number;
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
  lastStreamRevision?: string | null;
}

/**
 * Config Projector using SQL-Only Architecture
 *
 * Optimized for moderate traffic scenarios (tens of events/sec or less)
 * and configuration-style domains where simplicity is preferred over
 * maximum performance optimization.
 *
 * SQL-Only Benefits:
 * - Lower operational complexity (single datastore)
 * - Fewer failure modes (no cache outages/evictions)
 * - Strong idempotency with UPSERT + version column
 * - Acceptable replay performance within SLOs
 * - Simpler debugging and monitoring
 *
 * PostgreSQL Features:
 * - ACID transactions for data consistency
 * - Optimistic concurrency control via version column
 * - Efficient UPSERT with ON CONFLICT handling
 * - JSONB support for complex domain objects
 * - Built-in indexing and query optimization
 *
 * Key Features:
 * - Uses shared CatchUpRunner for subscription management
 * - PostgreSQL-based checkpoint storage for reliability
 * - Shared field validation utilities for consistency
 * - Production-ready error handling patterns
 * - Comprehensive logging and monitoring
 */
@Injectable()
export class ConfigProjector
  extends BaseProjector
  implements OnModuleInit, OnModuleDestroy
{
  // Note: Using centralized ConfigRowQueries.UPSERT_CONFIG_PROJECTION
  // for consistent SQL query definitions and better maintainability

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    @Inject(CLOCK) private readonly clock: Clock,
    @Inject(SLACK_CONFIG_DI_TOKENS.CATCHUP_RUNNER)
    private readonly catchUpRunner: CatchUpRunner,
    @Inject(SLACK_CONFIG_DI_TOKENS.DATA_SOURCE)
    private readonly dataSource: DataSource,
  ) {
    // Create PostgreSQL checkpoint store for SQL-only architecture
    const checkpointStore = new PostgreSQLCheckpointStore(
      dataSource,
      baseLogger,
      'sql-only:', // Environment prefix for isolation
    );

    super(
      'config-projector-sql-only',
      'config-projection-sql-only',
      baseLogger,
      checkpointStore,
    );

    Log.info(
      this.logger,
      'ConfigProjector initialized with simplified SQL-only architecture',
      {
        method: 'constructor',
        subscriptionGroup: this.subscriptionGroup,
        postgresStatus: this.dataSource.isInitialized,
        architecture: 'sql-only',
        benefits: [
          'lower-operational-complexity',
          'fewer-failure-modes',
          'strong-idempotency',
          'acceptable-replay-performance',
        ],
      },
    );
  }

  /**
   * Start the projector using CatchUpRunner
   */
  onModuleInit(): void {
    Log.info(
      this.logger,
      'Starting Config Projector (SQL-Only) with CatchUpRunner',
      {
        method: 'onModuleInit',
        subscriptionGroup: this.subscriptionGroup,
        architecture: 'sql-only',
      },
    );

    try {
      const runOptions: RunOptions = {
        prefixes: [ConfigProjectionKeys.getEventStoreStreamPrefix()],
        batchSize: 100,
        stopOnCaughtUp: false,
        maxRetries: 3,
        retryDelayMs: 1000,
        checkpointBatchSize: 10,
      };

      // Start the projection in the background without blocking module initialization
      this.catchUpRunner
        .runSafe(
          this.subscriptionGroup,
          this.projectEvent.bind(this) as (
            event: ProjectionEvent,
          ) => Promise<void>,
          runOptions,
        )
        .then((result) => {
          if (!result.ok) {
            this.updateHealthStatusOnError(
              result.error.detail || 'Unknown error',
            );
            Log.error(this.logger, 'Projection failed to start', {
              method: 'onModuleInit',
              error: result.error.detail || 'Unknown error',
            });
          } else {
            Log.info(this.logger, 'Projection completed successfully', {
              method: 'onModuleInit',
              status: 'completed',
            });
          }
        })
        .catch((error) => {
          const e = error as Error;
          this.updateHealthStatusOnError(e.message);
          Log.error(this.logger, 'Projection failed with exception', {
            method: 'onModuleInit',
            error: e.message,
            stack: e.stack,
          });
        });

      this.setRunning(true);
      this.updateHealthStatusOnSuccess();

      Log.info(
        this.logger,
        'Config Projector (SQL-Only) started successfully',
        {
          method: 'onModuleInit',
          status: 'running',
        },
      );
    } catch (error) {
      const e = error as Error;
      this.updateHealthStatusOnError(e.message);

      Log.error(this.logger, 'Failed to start Config Projector (SQL-Only)', {
        method: 'onModuleInit',
        error: e.message,
        stack: e.stack,
      });
      throw error;
    }
  }

  /**
   * Stop the projector using CatchUpRunner shutdown
   */
  onModuleDestroy(): void {
    Log.info(this.logger, 'Stopping Config Projector (SQL-Only)', {
      method: 'onModuleDestroy',
      subscriptionGroup: this.subscriptionGroup,
    });

    try {
      this.catchUpRunner.stop(this.subscriptionGroup);
      this.setRunning(false);

      Log.info(this.logger, 'Config Projector stopped successfully', {
        method: 'onModuleDestroy',
        status: 'stopped',
      });
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error stopping Config Projector (SQL-Only)', {
        method: 'onModuleDestroy',
        error: e.message,
        stack: e.stack,
      });
    }
  }

  /**
   * Project individual event using SQL-only architecture
   * with ACID transactions and version-based concurrency control
   */
  private async projectEvent(event: ProjectionEvent): Promise<void> {
    const tenant = this.extractTenant(event);

    try {
      // Extract config parameters using shared field validation
      const params = this.extractConfigParams(event, 'project');

      // Execute PostgreSQL transaction with optimistic concurrency control
      const queryRunner = this.dataSource.createQueryRunner();
      await queryRunner.connect();
      await queryRunner.startTransaction();

      try {
        const result = await this.applyEventToDatabase(
          queryRunner,
          event,
          params,
        );
        await queryRunner.commitTransaction();

        // Log successful projection with version info
        if (result && result.length > 0) {
          Log.debug(
            this.logger,
            'Event projected successfully with version check',
            {
              method: 'projectEvent',
              eventType: event.type,
              streamId: event.streamId,
              revision: event.revision,
              tenant,
              workspaceCode: result[0].workspaceCode,
              version: result[0].version,
              outcome: 'applied',
            },
          );
        } else {
          Log.debug(this.logger, 'Event skipped due to stale version', {
            method: 'projectEvent',
            eventType: event.type,
            streamId: event.streamId,
            revision: event.revision,
            tenant,
            outcome: 'skipped-stale-version',
          });
        }

        // Update health status
        const checkpointPosition = event.position
          ? `${event.position.commit}:${event.position.prepare}`
          : undefined;
        this.updateHealthStatusOnSuccess(checkpointPosition);
      } catch (error) {
        await queryRunner.rollbackTransaction();
        throw error;
      } finally {
        await queryRunner.release();
      }
    } catch (error) {
      const e = error as Error;
      this.updateHealthStatusOnError(e.message);

      Log.error(
        this.logger,
        'Failed to project event with SQL-only architecture',
        {
          method: 'projectEvent',
          eventType: event.type,
          streamId: event.streamId,
          revision: event.revision,
          tenant,
          error: e.message,
          stack: e.stack,
        },
      );

      throw new Error(
        withContext(ConfigProjectorErrors.DATABASE_OPERATION_FAILED, {
          eventType: event.type,
          streamId: event.streamId,
          originalError: e.message,
        }).detail,
        { cause: e },
      );
    }
  }

  /**
   * Extract tenant ID from event using shared utility
   */
  private extractTenant(event: ProjectionEvent): string {
    return TenantExtractor.extractTenant(event);
  }

  /**
   * Apply event to database using SQL UPSERT with version-based concurrency control
   */
  private async applyEventToDatabase(
    queryRunner: QueryRunner,
    event: ProjectionEvent,
    params: ConfigRowParams,
  ): Promise<{ workspaceCode: string; version: number }[]> {
    switch (event.type) {
      case 'NotificationSlackConfigConfigCreated.v1':
        return this.handleConfigCreated(queryRunner, params);
      case 'NotificationSlackConfigConfigUpdated.v1':
        return this.handleConfigUpdated(queryRunner, params);
      case 'NotificationSlackConfigConfigDeleted.v1':
        return this.handleConfigDeleted(queryRunner, params);
      default:
        Log.warn(this.logger, 'Unknown event type in projection', {
          method: 'applyEventToDatabase',
          eventType: event.type,
          streamId: event.streamId,
        });
        // Don't fail on unknown events - allows for forward compatibility
        return [];
    }
  }

  /**
   * Handle ConfigCreated event
   */
  private async handleConfigCreated(
    queryRunner: QueryRunner,
    params: ConfigRowParams,
  ): Promise<{ workspaceCode: string; version: number }[]> {
    return this.executeUpsert(queryRunner, params);
  }

  /**
   * Handle ConfigUpdated event
   */
  private async handleConfigUpdated(
    queryRunner: QueryRunner,
    params: ConfigRowParams,
  ): Promise<{ workspaceCode: string; version: number }[]> {
    return this.executeUpsert(queryRunner, params);
  }

  /**
   * Handle ConfigDeleted event
   */
  private async handleConfigDeleted(
    queryRunner: QueryRunner,
    params: ConfigRowParams,
  ): Promise<{ workspaceCode: string; version: number }[]> {
    // Mark as deleted with current timestamp
    const deletedParams = {
      ...params,
      deletedAt: this.clock.now(),
    };
    return this.executeUpsert(queryRunner, deletedParams);
  }

  /**
   * Execute SQL UPSERT with optimistic concurrency control using centralized queries
   * Returns affected rows for logging and monitoring
   */
  private async executeUpsert(
    queryRunner: QueryRunner,
    params: ConfigRowParams,
  ): Promise<{ workspaceCode: string; version: number }[]> {
    try {
      const result = (await queryRunner.query(
        ConfigRowQueries.UPSERT_CONFIG_PROJECTION,
        [
          params.workspaceCode,
          params.maxRetryAttempts,
          params.retryBackoffSeconds,
          params.defaultLocale,
          params.loggingEnabled,
          params.auditChannelId,
          params.metadata,
          params.tenant,
          params.version,
          params.createdAt,
          params.updatedAt,
          params.deletedAt,
          params.lastStreamRevision,
        ],
      )) as ConfigProjectionUpsertResult[];

      // Use centralized mapper for consistent result handling
      return result.map((row) =>
        ConfigRowMappers.mapToProjectionUpsertResult(row),
      );
    } catch (error) {
      const e = error as Error;
      throw new Error(
        withContext(ConfigProjectorErrors.DATABASE_OPERATION_FAILED, {
          operation: 'executeUpsert',
          workspaceCode: params.workspaceCode,
          version: params.version,
          originalError: e.message,
        }).detail,
      );
    }
  }

  /**
   * Extract config parameters from event data using ConfigFieldValidatorUtil
   *
   * Uses ConfigFieldValidatorUtil to create validated ConfigSnapshotProps for consistent
   * validation across repository and projector, and TenantExtractor for reliable tenant identification.
   */
  private extractConfigParams(
    event: ProjectionEvent,
    operation: string,
  ): ConfigRowParams {
    try {
      const eventData = event.data as Record<string, any>;

      // Extract tenant using shared utility
      const tenant = TenantExtractor.extractTenant(event);

      // Use ConfigFieldValidatorUtil to create validated config snapshot
      const projectorData =
        ConfigFieldValidatorUtil.createConfigProjectorDataFromEventData(
          eventData,
        );

      // Parse object fields using safeParseJSON utility
      const metadata = safeParseJSON<Record<string, unknown>>(
        projectorData.metadata,
        'metadata',
      );

      // Add projector-specific fields for SQL storage
      return {
        ...projectorData,
        metadata,
        tenant,
        deletedAt: null, // Projector handles soft deletes
        lastStreamRevision: event.revision.toString(),
      };
    } catch (error) {
      const e = error as Error;
      throw new Error(
        withContext(ConfigProjectorErrors.INVALID_EVENT_DATA, {
          eventType: event.type,
          streamId: event.streamId,
          operation,
          originalError: e.message,
        }).detail,
      );
    }
  }
}
