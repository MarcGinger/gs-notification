// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Inject } from '@nestjs/common';
import {
  Result,
  ok,
  err,
  DomainError,
  isOk,
  withContext,
} from 'src/shared/errors';

// Shared utilities and infrastructure
import { APP_LOGGER, componentLogger, Logger } from 'src/shared/logging';
import { CACHE_TTL } from 'src/shared/application/caching/cache.config';
import { RepositoryOptions } from 'src/shared/infrastructure/repositories/repository.types';
import { Option } from 'src/shared/domain/types';
import { ActorContextUtil } from 'src/shared/utilities/actor-context.util';
import { IUserToken } from 'src/shared/security';

// Application layer
import { IConfigQuery, CONFIG_QUERY_TOKEN } from '../ports';
import { DetailConfigResponse } from '../dtos';
import { IGetConfigUseCase } from './contracts';
import { ConfigErrors } from '../../domain/errors';

/**
 * Get Config Use Case - Simplified CQRS Read Side Implementation
 *
 * Simple use case that queries for config data by workspaceCode.
 * Authorization is handled at the service layer.
 */

@Injectable()
export class GetConfigUseCase implements IGetConfigUseCase {
  private readonly logger: Logger;

  constructor(
    @Inject(CONFIG_QUERY_TOKEN)
    private readonly query: IConfigQuery,
    @Inject(APP_LOGGER) moduleLogger: Logger,
  ) {
    this.logger = componentLogger(moduleLogger, 'GetConfigUseCase');
  }

  async execute(params: {
    user: IUserToken;
    workspaceCode: string;
    correlationId: string;
  }): Promise<Result<DetailConfigResponse, DomainError>> {
    const { user, workspaceCode, correlationId } = params;

    // Simple input validation
    if (!workspaceCode?.trim()) {
      return err({
        code: 'CONFIG.INVALID_WORKSPACE_CODE' as const,
        title: 'Invalid workspaceCode',
        category: 'validation' as const,
        context: { workspaceCode, correlationId, userId: user.sub },
      });
    }

    // Setup repository options with caching
    const repositoryOptions: RepositoryOptions = {
      cache: {
        ttl: CACHE_TTL.STANDARD,
        refreshCache: false,
      },
      correlationId,
      requestId: user.sub,
    };

    // Convert user token to actor context
    const actorResult = ActorContextUtil.fromUserTokenSafe(user);
    if (!isOk(actorResult)) {
      return err(
        withContext(actorResult.error, {
          correlationId,
          userId: user.sub,
          operation: 'get_config',
          workspaceCode,
        }),
      );
    }

    // Query for the config data
    const queryResult = await this.query.findById(
      actorResult.value,
      workspaceCode,
      repositoryOptions,
    );

    if (!isOk(queryResult)) {
      return err(
        withContext(queryResult.error, {
          correlationId,
          userId: user.sub,
          operation: 'get_config',
          workspaceCode,
        }),
      );
    }

    // Handle Option<DetailConfigResponse>
    const configDto = Option.isNone(queryResult.value)
      ? null
      : queryResult.value.value;

    if (!configDto) {
      return err(
        withContext(ConfigErrors.CONFIG_NOT_FOUND, {
          workspaceCode,
          correlationId,
          userId: user.sub,
          operation: 'get_config',
        }),
      );
    }

    // Success - no logging needed as this is handled at service layer

    return ok(configDto);
  }
}
