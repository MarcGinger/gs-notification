// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, ok, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { ConfigAggregate } from '../aggregates';
import { ConfigEntity } from '../entities';
import { ConfigSnapshotProps, UpdateConfigProps } from '../props';
import { ValidatedConfigUpdateFields } from '../types';
import {
  ConfigMaxRetryAttempts,
  ConfigRetryBackoffSeconds,
  ConfigDefaultLocale,
  ConfigLoggingEnabled,
  ConfigAuditChannelId,
  ConfigMetadata,
} from '../value-objects';

/**
 * Update Config Aggregate Factory
 *
 * Handles the complete update flow for Config aggregates:
 * 1. Loads existing aggregate from snapshot
 * 2. Validates update properties and creates value objects
 * 3. Applies updates with proper business rule enforcement
 * 4. Returns updated aggregate ready for persistence
 *
 * This factory provides:
 * - Consistent update pattern matching create operations
 * - Centralized validation and business logic
 * - Efficient batch updates vs field-by-field
 * - Proper error context and logging integration
 */
export function updateConfigAggregateFromSnapshot(
  existingSnapshot: ConfigSnapshotProps,
  updateProps: UpdateConfigProps,
  metadata: EventMetadata,
  clock: Clock,
): Result<ConfigAggregate, DomainError> {
  // 1. Reconstitute existing aggregate
  const entityResult = ConfigEntity.fromSnapshot(existingSnapshot);
  if (!entityResult.ok) {
    return err(
      withContext(entityResult.error, {
        operation: 'update_config_reconstitute',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
      }),
    );
  }

  const existingAggregate = ConfigAggregate.reconstitute(
    entityResult.value,
    clock,
    metadata,
  );

  // 2. Validate and apply updates for each provided field
  const validatedFields: ValidatedConfigUpdateFields = {};

  // Validate maxRetryAttempts if provided
  if (updateProps.maxRetryAttempts !== undefined) {
    const maxRetryAttemptsResult = ConfigMaxRetryAttempts.from(
      updateProps.maxRetryAttempts,
    );
    if (!maxRetryAttemptsResult.ok) {
      return err(
        withContext(maxRetryAttemptsResult.error, {
          operation: 'update_config_max_retry_attempts_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedMaxRetryAttempts: updateProps.maxRetryAttempts,
        }),
      );
    }
    validatedFields.maxRetryAttempts = maxRetryAttemptsResult.value;
  }

  // Validate retryBackoffSeconds if provided
  if (updateProps.retryBackoffSeconds !== undefined) {
    const retryBackoffSecondsResult = ConfigRetryBackoffSeconds.from(
      updateProps.retryBackoffSeconds,
    );
    if (!retryBackoffSecondsResult.ok) {
      return err(
        withContext(retryBackoffSecondsResult.error, {
          operation: 'update_config_retry_backoff_seconds_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedRetryBackoffSeconds: updateProps.retryBackoffSeconds,
        }),
      );
    }
    validatedFields.retryBackoffSeconds = retryBackoffSecondsResult.value;
  }

  // Validate defaultLocale if provided
  if (updateProps.defaultLocale !== undefined) {
    const defaultLocaleResult = ConfigDefaultLocale.from(
      updateProps.defaultLocale,
    );
    if (!defaultLocaleResult.ok) {
      return err(
        withContext(defaultLocaleResult.error, {
          operation: 'update_config_default_locale_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedDefaultLocale: updateProps.defaultLocale,
        }),
      );
    }
    validatedFields.defaultLocale = defaultLocaleResult.value;
  }

  // Validate loggingEnabled if provided
  if (updateProps.loggingEnabled !== undefined) {
    const loggingEnabledResult = ConfigLoggingEnabled.from(
      updateProps.loggingEnabled,
    );
    if (!loggingEnabledResult.ok) {
      return err(
        withContext(loggingEnabledResult.error, {
          operation: 'update_config_logging_enabled_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedLoggingEnabled: updateProps.loggingEnabled,
        }),
      );
    }
    validatedFields.loggingEnabled = loggingEnabledResult.value;
  }

  // Validate auditChannelId if provided
  if (updateProps.auditChannelId !== undefined) {
    const auditChannelIdResult = ConfigAuditChannelId.from(
      updateProps.auditChannelId,
    );
    if (!auditChannelIdResult.ok) {
      return err(
        withContext(auditChannelIdResult.error, {
          operation: 'update_config_audit_channel_id_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedAuditChannelId: updateProps.auditChannelId,
        }),
      );
    }
    validatedFields.auditChannelId = auditChannelIdResult.value;
  }

  // Validate metadata if provided
  if (updateProps.metadata !== undefined) {
    const metadataResult = ConfigMetadata.from(updateProps.metadata);
    if (!metadataResult.ok) {
      return err(
        withContext(metadataResult.error, {
          operation: 'update_config_metadata_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedMetadata: updateProps.metadata,
        }),
      );
    }
    validatedFields.metadata = metadataResult.value;
  }

  // 3. Apply all validated changes in single atomic operation
  const batchUpdateResult = existingAggregate.updateBatch(validatedFields);
  if (!batchUpdateResult.ok) {
    return err(
      withContext(batchUpdateResult.error, {
        operation: 'update_product_batch_application',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        fieldsUpdated: Object.keys(validatedFields),
      }),
    );
  }

  return ok(existingAggregate);
}
