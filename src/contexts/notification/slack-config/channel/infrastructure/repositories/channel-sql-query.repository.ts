// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { Injectable, Inject } from '@nestjs/common';
import { DataSource } from 'typeorm';
import { APP_LOGGER, Log, componentLogger, Logger } from 'src/shared/logging';
import { CorrelationUtil } from 'src/shared/utilities/correlation.util';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import {
  RepositoryLoggingUtil,
  RepositoryLoggingConfig,
  RepositoryExecutionUtil,
  safeParseJSON,
  handleRepositoryError,
  RepositoryOptions,
  isString,
  safeParseJSONArray,
} from 'src/shared/infrastructure/repositories';
import { Result, DomainError, err, ok } from 'src/shared/errors';
import { ActorContext } from 'src/shared/application/context';
import { RepositoryErrorFactory } from 'src/shared/domain/errors/repository.error';
import { Option } from 'src/shared/domain/types';
import { SLACK_CONFIG_DI_TOKENS } from '../../../slack-config.constants';
import {
  ChannelPageResponse,
  ListChannelFilterRequest,
  ListChannelResponse,
  DetailChannelResponse,
} from '../../application/dtos';
import { PaginationMetaResponse } from 'src/shared/application/dtos';
import { IChannelQuery } from '../../application/ports';
import { ChannelRow, ChannelRowQueries } from '../schemas/channel.schema';

/**
 * Channel Query Repository - Interface Segregation Principle Implementation
 *
 * Bounded Context: Notification/Channel
 * Handles complex query operations including pagination, filtering, and search.
 * This repository focuses solely on advanced data retrieval operations using PostgreSQL.
 *
 * ISP Benefits:
 * - Clients that need simple reads don't depend on complex query methods
 * - Can be optimized independently (e.g., using read replicas)
 * - Easier to implement caching strategies for query operations
 * - Supports analytical and reporting use cases
 *
 * PostgreSQL Features Used:
 * - Advanced filtering with type-safe query builders
 * - JSON column querying for complex configuration data
 * - Efficient pagination with LIMIT/OFFSET
 * - Full-text search capabilities
 * - Tenant isolation with row-level security support
 *
 * @domain Notification Context - Channel Query Repository
 * @layer Infrastructure
 * @pattern Repository Pattern + Interface Segregation Principle
 */
@Injectable()
export class ChannelQueryRepository implements IChannelQuery {
  private readonly logger: Logger;
  private readonly loggingConfig: RepositoryLoggingConfig;

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    @Inject(CLOCK) private readonly clock: Clock,
    @Inject(SLACK_CONFIG_DI_TOKENS.DATA_SOURCE)
    private readonly dataSource: DataSource,
  ) {
    this.loggingConfig = {
      serviceName: 'ChannelConfigService',
      component: 'ChannelQueryRepository',
    };
    this.logger = componentLogger(baseLogger, this.loggingConfig.component);
  }
  async findById(
    actor: ActorContext,
    code: string,
    options?: RepositoryOptions,
  ): Promise<Result<Option<DetailChannelResponse>, DomainError>> {
    const operation = 'findById';
    const correlationId =
      options?.correlationId ??
      CorrelationUtil.generateForOperation('channel-query-findById');

    const logContext = this.createLogContext(operation, correlationId, actor, {
      channelCode: code,
    });

    // Validate actor context with enhanced security logging
    const validation = RepositoryLoggingUtil.validateActorContext(
      this.logger,
      actor,
      logContext,
    );
    if (!validation.ok) return err(validation.error);

    // Guard tenant explicitly
    if (!actor.tenant) {
      return err(
        RepositoryErrorFactory.validationError('tenant', 'Missing tenant id'),
      );
    }

    // Log successful authorization
    RepositoryLoggingUtil.logAuthorizationSuccess(
      this.logger,
      operation,
      logContext,
      {
        operationType: 'channel_query_findById',
        scope: 'single_channel_lookup',
        tenant: actor.tenant,
      },
    );

    try {
      // Use centralized query from schema for consistency
      const query = ChannelRowQueries.FIND_CHANNEL_BY_CODE;
      const parameters = [actor.tenant, code];

      Log.debug(this.logger, 'Executing channel findById query', {
        ...logContext,
        sql: query,
        parameters: parameters.map((p, i) => `$${i + 1}: ${String(p)}`),
      });

      // Execute query with optional timeout
      const queryPromise = this.dataSource.query(query, parameters);
      const results = (await RepositoryExecutionUtil.executeWithTimeout(
        queryPromise,
        options?.timeout,
        'Channel findById query timeout',
      )) as ChannelRow[];

      if (results.length === 0) {
        Log.debug(this.logger, 'Channel not found', logContext);
        return ok(Option.none());
      }

      const channel = results[0];

      // Transform to DetailChannelResponse DTO
      const detailResponse = this.toDetailResponse(channel);

      Log.debug(this.logger, 'Channel found successfully', {
        ...logContext,
        resultData: {
          channelCode: detailResponse.code,
          channelName: detailResponse.name,
        },
      });

      return ok(Option.some(detailResponse));
    } catch (error) {
      // Log operation error using shared utility
      RepositoryLoggingUtil.logOperationError(
        this.logger,
        operation,
        logContext,
        error as Error,
        'MEDIUM',
      );

      // Handle and return the classified error using shared utility
      return handleRepositoryError(error);
    }
  }

  /**
   * Helper to create consistent logging context using shared utilities
   */
  private createLogContext(
    operation: string,
    correlationId: string,
    actor: ActorContext,
    additionalContext?: Record<string, unknown>,
  ): Record<string, unknown> {
    return RepositoryLoggingUtil.createLogContext(
      this.loggingConfig,
      this.clock,
      operation,
      correlationId,
      actor,
      additionalContext,
    );
  }

  /**
   * Find Channel records with pagination and filtering using raw SQL.
   *
   * Leverages the proven schema and patterns from ChannelReaderRepository
   * with type-safe SQL queries and proper JSONB field handling.
   *
   * Features:
   * - Type-safe filtering by code and name using actual database schema
   * - Multi-field sorting with configurable directions
   * - Efficient pagination with total count
   * - Tenant isolation
   * - Comprehensive logging and error handling
   * - Proper JSONB field parsing with safeParseJSON utility
   *
   * @param actor - The actor context containing authentication and request metadata.
   * @param filter - Optional filter criteria for the channel search.
   * @param options - Optional repository options (e.g., pagination, sorting).
   * @returns A promise resolving to a Result containing paginated Channel responses or a DomainError.
   */
  async findPaginated(
    actor: ActorContext,
    filter?: ListChannelFilterRequest,
    options?: RepositoryOptions,
  ): Promise<Result<ChannelPageResponse, DomainError>> {
    const operation = 'findPaginated';
    const correlationId =
      options?.correlationId ??
      CorrelationUtil.generateForOperation('channel-query-paginated');

    const logContext = this.createLogContext(operation, correlationId, actor, {
      filterCode: filter?.code,
      filterName: filter?.name,
      filterWorkspaceCode: filter?.workspaceCode,
      page: filter?.page,
      size: filter?.size,
      sortBy: filter?.getSortByRecord?.() || {},
    });

    // Validate actor context with enhanced security logging
    const validation = RepositoryLoggingUtil.validateActorContext(
      this.logger,
      actor,
      logContext,
    );
    if (!validation.ok) return err(validation.error);

    // Guard tenant explicitly
    if (!actor.tenant) {
      return err(
        RepositoryErrorFactory.validationError('tenant', 'Missing tenant id'),
      );
    }

    // Log successful authorization
    RepositoryLoggingUtil.logAuthorizationSuccess(
      this.logger,
      operation,
      logContext,
      {
        operationType: 'channel_query_paginated',
        scope: 'paginated_search',
        tenant: actor.tenant,
      },
    );

    try {
      // Build dynamic WHERE conditions and parameters
      const whereConditions = ['tenant_id = $1'];
      const parameters: unknown[] = [actor.tenant];
      let paramCount = 1;
      // Add code filter
      if (filter?.code) {
        paramCount++;
        if (filter.code.includes('%') || filter.code.includes('*')) {
          // Wildcard search
          const pattern = filter.code.replace(/\*/g, '%');
          whereConditions.push(`code ILIKE $${paramCount}`);
          parameters.push(pattern);
        } else {
          // Exact match
          whereConditions.push(`code = $${paramCount}`);
          parameters.push(filter.code);
        }
      }

      // Add name filter
      if (filter?.name) {
        paramCount++;
        if (filter.name.includes('%') || filter.name.includes('*')) {
          // Wildcard search
          const pattern = filter.name.replace(/\*/g, '%');
          whereConditions.push(`name ILIKE $${paramCount}`);
          parameters.push(pattern);
        } else {
          // Exact match
          whereConditions.push(`name = $${paramCount}`);
          parameters.push(filter.name);
        }
      }

      // Add workspaceCode filter
      if (filter?.workspaceCode) {
        paramCount++;
        if (
          filter.workspaceCode.includes('%') ||
          filter.workspaceCode.includes('*')
        ) {
          // Wildcard search
          const pattern = filter.workspaceCode.replace(/\*/g, '%');
          whereConditions.push(`workspace_code ILIKE $${paramCount}`);
          parameters.push(pattern);
        } else {
          // Exact match
          whereConditions.push(`workspace_code = $${paramCount}`);
          parameters.push(filter.workspaceCode);
        }
      }

      // Build ORDER BY clause
      const orderBy = this.buildOrderByClause(filter?.getSortByRecord?.());

      // Build pagination
      const page = filter?.page ?? 1;
      const size = Math.min(filter?.size ?? 20, 100); // Cap at 100 items per page
      const offset = (page - 1) * size;

      // First, get total count for pagination metadata using centralized schema query
      const countQuery =
        ChannelRowQueries.COUNT_CHANNELS_BASE +
        ' WHERE ' +
        whereConditions.join(' AND ');

      Log.debug(this.logger, 'Executing channel count query', {
        ...logContext,
        sql: countQuery,
        parameters,
      });

      const countResult: unknown =
        await RepositoryExecutionUtil.executeWithTimeout(
          this.dataSource.query(countQuery, parameters),
          options?.timeout,
          'Simple count query timeout',
        );
      // Raw SQL COUNT query returns numeric string in total field - handle any type safely
      const isValidCountResult = (
        result: unknown,
      ): result is [{ total: string }] =>
        Array.isArray(result) &&
        result.length > 0 &&
        typeof result[0] === 'object' &&
        result[0] !== null &&
        'total' in result[0];

      const totalItems = parseInt(
        isValidCountResult(countResult) ? countResult[0].total : '0',
        10,
      );

      // Then get the actual data using centralized schema query with consistent column list
      const dataQuery =
        ChannelRowQueries.FIND_CHANNELS_PAGINATED_BASE +
        ' WHERE ' +
        whereConditions.join(' AND ') +
        ' ' +
        orderBy +
        ` LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}`;

      parameters.push(size, offset);

      Log.debug(this.logger, 'Executing paginated channel query', {
        ...logContext,
        sql: dataQuery,
        parameters: parameters.map((p, i) => `$${i + 1}: ${String(p)}`),
        totalItems,
        page,
        size,
        offset,
      });

      // Execute query with optional timeout
      const queryPromise = this.dataSource.query(dataQuery, parameters);
      const channels = (await RepositoryExecutionUtil.executeWithTimeout(
        queryPromise,
        options?.timeout,
        'Channel data query timeout',
      )) as ChannelRow[];

      // Transform to DTOs
      const channelResponses = channels.map((channel) =>
        this.toListResponse(channel),
      );

      // Create pagination metadata
      const totalPages = Math.ceil(totalItems / size);
      const hasNextPage = page < totalPages;
      const hasPreviousPage = page > 1;

      const meta = new PaginationMetaResponse({
        page,
        size,
        totalItems,
        totalPages,
        hasNextPage,
        hasPreviousPage,
      });

      const response = ChannelPageResponse.create(channelResponses, meta);

      // Log successful query metrics
      RepositoryLoggingUtil.logQueryMetrics(
        this.logger,
        operation,
        logContext,
        {
          resultCount: channels.length,
          dataQuality: channels.length > 0 ? 'good' : 'empty',
          sampleData: {
            totalItems,
            page,
            size,
            hasFilters: !!(
              filter?.code ||
              filter?.name ||
              filter?.workspaceCode
            ),
            sortFields: Object.keys(filter?.getSortByRecord?.() ?? {}),
          },
        },
      );

      return ok(response);
    } catch (error) {
      // Log operation error using shared utility
      RepositoryLoggingUtil.logOperationError(
        this.logger,
        operation,
        logContext,
        error as Error,
        'HIGH',
      );

      // Handle and return the classified error using shared utility
      return handleRepositoryError(error);
    }
  }

  /**
   * Build ORDER BY clause for SQL query based on sort criteria
   */
  private buildOrderByClause(sortBy?: Record<string, string>): string {
    const defaultSort = { code: 'asc', name: 'asc' };
    const actualSort = sortBy ?? defaultSort;

    const orderClauses: string[] = [];

    for (const [field, direction] of Object.entries(actualSort)) {
      const column = this.getSortableColumn(field);
      if (column) {
        const sortDirection =
          direction?.toLowerCase() === 'desc' ? 'DESC' : 'ASC';
        orderClauses.push(`${column} ${sortDirection}`);
      }
    }

    // Always add code as final sort for consistent pagination if not already included
    if (!actualSort.code && !('id' in actualSort)) {
      orderClauses.push('code ASC');
    }

    return orderClauses.length > 0 ? `ORDER BY ${orderClauses.join(', ')}` : '';
  }

  /**
   * Map filter field names to actual database column names
   */
  private getSortableColumn(field: string): string | null {
    const columnMap: Record<string, string> = {
      createdAt: 'created_at',
      updatedAt: 'updated_at',
      code: 'code',
      name: 'name',
      workspaceCode: 'workspace_code',
    };

    return columnMap[field] || null;
  }
  /**
   * Transform ChannelRow to DetailChannelResponse DTO
   * Uses the same parsing logic as toListResponse but returns DetailChannelResponse
   */
  private toDetailResponse(channel: ChannelRow): DetailChannelResponse {
    // Parse complex JSONB objects - let undefined values be undefined (no fake defaults)
    const subscribedEvents = channel.subscribed_events
      ? safeParseJSONArray(
          channel.subscribed_events,
          'subscribed_events',
          isString,
        )
      : undefined;

    // Create DetailChannelResponse with explicit field mapping
    const response: DetailChannelResponse = {
      code: channel.code,
      name: channel.name,
      workspaceCode: channel.workspace_code,
      isPrivate: channel.is_private,
      isDm: channel.is_dm,
      topic: channel.topic ?? undefined,
      purpose: channel.purpose ?? undefined,
      subscribedEvents,
      enabled: channel.enabled,
    };

    return response;
  }

  /**
   * Transform ChannelRow to ListChannelResponse DTO
   * Uses the proven transformation patterns from ChannelReaderRepository
   * with proper JSONB field parsing and type-safe conversion
   */
  private toListResponse(channel: ChannelRow): ListChannelResponse {
    // Parse JSON arrays using specialized utility with type validation
    // Parse complex JSONB objects - let undefined values be undefined (no fake defaults)

    // Create properly structured response with explicit field mapping
    // All undefined values are passed through - no fake defaults
    const response: ListChannelResponse = {
      code: channel.code,
      name: channel.name,
      workspaceCode: channel.workspace_code,
      isPrivate: channel.is_private,
      isDm: channel.is_dm,
      topic: channel.topic ?? undefined,
      purpose: channel.purpose ?? undefined,
      subscribedEvents: channel.subscribed_events ?? undefined,
      enabled: channel.enabled,
    };

    return response;
  }
}
