// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { EntityIdBase } from 'src/shared/domain/entities';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { ChannelSnapshotProps } from '../props';
import { ChannelDomainState } from '../state';
import { ChannelErrors } from '../errors/channel.errors';
import {
  ChannelCode,
  ChannelCreatedAt,
  ChannelUpdatedAt,
  ChannelVersion,
  ChannelEnabled,
  ChannelIsDm,
  ChannelIsPrivate,
  ChannelName,
  ChannelPurpose,
  ChannelSubscribedEvents,
  ChannelTopic,
  ChannelWorkspaceCode,
} from '../value-objects';

/**
 * Domain Entity: Channel
 *
 * Represents the core Channel entity in the notification domain.
 * Encapsulates channel data, identity, and basic entity behavior.
 *
 * This entity follows DDD principles:
 * - Identity: Code as unique identifier
 * - Immutability: Changes create new instances
 * - Encapsulation: Private state with controlled access
 * - Business validation: Domain rules enforced
 *
 * @domain Notification Context - Channel Entity
 * @layer Domain Entities
 */

/**
 * Channel Entity
 *
 * Core domain entity representing a channel in the notification.
 * Handles channel identity, validation, and state management.
 */
export class ChannelEntity extends EntityIdBase<
  ChannelDomainState,
  ChannelCode
> {
  private static clock: { now: () => Date } = { now: () => new Date() };

  public static setClock(c: { now: () => Date }) {
    this.clock = c;
  }

  /**
   * Helper method to create updatedAt VO from date
   */
  private static createUpdatedAt(
    date?: Date,
  ): Result<ChannelUpdatedAt, DomainError> {
    const targetDate = date || ChannelEntity.clock.now();
    const result = ChannelUpdatedAt.from(targetDate);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create version VO from number
   */
  private static createVersion(
    versionNumber?: number,
    currentVersion?: ChannelVersion,
  ): Result<ChannelVersion, DomainError> {
    const targetVersion = versionNumber ?? currentVersion?.value ?? 1;
    const result = ChannelVersion.from(targetVersion);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create updated entity with common logic
   */
  private createUpdatedEntity(
    fieldUpdates: Partial<ChannelDomainState>,
    updatedAt?: Date,
    version?: number,
  ): Result<ChannelEntity, DomainError> {
    const updatedAtResult = ChannelEntity.createUpdatedAt(updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = ChannelEntity.createVersion(
      version,
      this.props.version,
    );
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const updatedProps: ChannelDomainState = {
      ...this.props,
      ...fieldUpdates,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return ChannelEntity.create(updatedProps);
  }

  private constructor(props: ChannelDomainState) {
    super(props, props.code);
  }

  /**
   * Factory method to create a new channel entity
   *
   * @param props - Channel properties
   * @returns Result containing ChannelEntity or DomainError
   */
  public static create(
    props: ChannelDomainState,
  ): Result<ChannelEntity, DomainError> {
    // Validate required properties
    const validationResult = ChannelEntity.validate(props);
    if (validationResult.ok === false) {
      return err(validationResult.error);
    }

    return ok(new ChannelEntity(props));
  }

  /**
   * Factory method to reconstitute a channel entity from persistence
   *
   * @param props - Channel properties from database
   * @returns ChannelEntity instance
   */
  public static reconstitute(props: ChannelDomainState): ChannelEntity {
    return new ChannelEntity(props);
  }

  /**
   * Factory method to reconstitute entity from snapshot
   *
   * @param snapshot - Channel snapshot properties
   * @returns Result containing ChannelEntity or DomainError
   */
  public static fromSnapshot(
    snapshot: ChannelSnapshotProps,
  ): Result<ChannelEntity, DomainError> {
    const codeResult = ChannelCode.from(snapshot.code);
    if (!codeResult.ok) {
      return err(codeResult.error);
    }
    const nameResult = ChannelName.from(snapshot.name);
    if (!nameResult.ok) {
      return err(nameResult.error);
    }
    const workspaceCodeResult = ChannelWorkspaceCode.from(
      snapshot.workspaceCode,
    );
    if (!workspaceCodeResult.ok) {
      return err(workspaceCodeResult.error);
    }
    const isPrivateResult = ChannelIsPrivate.from(snapshot.isPrivate);
    if (!isPrivateResult.ok) {
      return err(isPrivateResult.error);
    }
    const isDmResult = ChannelIsDm.from(snapshot.isDm);
    if (!isDmResult.ok) {
      return err(isDmResult.error);
    }
    const topicResult = ChannelTopic.from(snapshot.topic);
    if (!topicResult.ok) {
      return err(topicResult.error);
    }
    const purposeResult = ChannelPurpose.from(snapshot.purpose);
    if (!purposeResult.ok) {
      return err(purposeResult.error);
    }
    const subscribedEventsResult = ChannelSubscribedEvents.from(
      snapshot.subscribedEvents,
    );
    if (!subscribedEventsResult.ok) {
      return err(subscribedEventsResult.error);
    }
    const enabledResult = ChannelEnabled.from(snapshot.enabled);
    if (!enabledResult.ok) {
      return err(enabledResult.error);
    }
    const createdAtResult = ChannelCreatedAt.from(snapshot.createdAt);
    if (!createdAtResult.ok) {
      return err(createdAtResult.error);
    }

    const updatedAtResult = ChannelUpdatedAt.from(snapshot.updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = ChannelVersion.from(snapshot.version);
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const props: ChannelDomainState = {
      code: codeResult.value,
      name: nameResult.value,
      workspaceCode: workspaceCodeResult.value,
      isPrivate: isPrivateResult.value,
      isDm: isDmResult.value,
      topic: topicResult.value,
      purpose: purposeResult.value,
      subscribedEvents: subscribedEventsResult.value,
      enabled: enabledResult.value,
      createdAt: createdAtResult.value,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return ChannelEntity.create(props);
  }

  /**
   * Validates channel entity properties
   *
   * @param props - Properties to validate
   * @returns Validation result
   */
  private static validate(
    props: ChannelDomainState,
  ): Result<void, DomainError> {
    // Basic validation
    if (!props.code) {
      return err(ChannelErrors.INVALID_CODE_DATA);
    }
    if (!props.name) {
      return err(ChannelErrors.INVALID_NAME_DATA);
    }
    if (!props.workspaceCode) {
      return err(ChannelErrors.INVALID_WORKSPACE_CODE_DATA);
    }
    if (!props.isPrivate) {
      return err(ChannelErrors.INVALID_IS_PRIVATE_DATA);
    }
    if (!props.isDm) {
      return err(ChannelErrors.INVALID_IS_DM_DATA);
    }
    if (!props.enabled) {
      return err(ChannelErrors.INVALID_ENABLED_DATA);
    }

    return ok(undefined);
  }

  // ======================
  // Getters (Public API)
  // ======================

  public get code(): ChannelCode {
    return this.props.code;
  }

  public get name(): ChannelName {
    return this.props.name;
  }

  public get workspaceCode(): ChannelWorkspaceCode {
    return this.props.workspaceCode;
  }

  public get isPrivate(): ChannelIsPrivate {
    return this.props.isPrivate;
  }

  public get isDm(): ChannelIsDm {
    return this.props.isDm;
  }

  public get topic(): ChannelTopic | undefined {
    return this.props.topic;
  }

  public get purpose(): ChannelPurpose | undefined {
    return this.props.purpose;
  }

  public get subscribedEvents(): ChannelSubscribedEvents | undefined {
    return this.props.subscribedEvents;
  }

  public get enabled(): ChannelEnabled {
    return this.props.enabled;
  }

  public get createdAt(): ChannelCreatedAt {
    return this.props.createdAt;
  }

  public get updatedAt(): ChannelUpdatedAt {
    return this.props.updatedAt;
  }

  public get version(): ChannelVersion {
    return this.props.version;
  }

  // ======================
  // Simple Update Methods (No Business Logic)
  // ======================

  /**
   * Creates a new entity with updated name (pure state transition)
   *
   * @param name - New name value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ChannelEntity, DomainError>
   */
  public withName(
    name: ChannelName,
    updatedAt?: Date,
    version?: number,
  ): Result<ChannelEntity, DomainError> {
    return this.createUpdatedEntity({ name }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated workspaceCode (pure state transition)
   *
   * @param workspaceCode - New workspace_code value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ChannelEntity, DomainError>
   */
  public withWorkspaceCode(
    workspaceCode: ChannelWorkspaceCode,
    updatedAt?: Date,
    version?: number,
  ): Result<ChannelEntity, DomainError> {
    return this.createUpdatedEntity({ workspaceCode }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated isPrivate (pure state transition)
   *
   * @param isPrivate - New is_private value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ChannelEntity, DomainError>
   */
  public withIsPrivate(
    isPrivate: ChannelIsPrivate,
    updatedAt?: Date,
    version?: number,
  ): Result<ChannelEntity, DomainError> {
    return this.createUpdatedEntity({ isPrivate }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated isDm (pure state transition)
   *
   * @param isDm - New is_dm value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ChannelEntity, DomainError>
   */
  public withIsDm(
    isDm: ChannelIsDm,
    updatedAt?: Date,
    version?: number,
  ): Result<ChannelEntity, DomainError> {
    return this.createUpdatedEntity({ isDm }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated topic (pure state transition)
   *
   * @param topic - New topic value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ChannelEntity, DomainError>
   */
  public withTopic(
    topic: ChannelTopic,
    updatedAt?: Date,
    version?: number,
  ): Result<ChannelEntity, DomainError> {
    return this.createUpdatedEntity({ topic }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated purpose (pure state transition)
   *
   * @param purpose - New purpose value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ChannelEntity, DomainError>
   */
  public withPurpose(
    purpose: ChannelPurpose,
    updatedAt?: Date,
    version?: number,
  ): Result<ChannelEntity, DomainError> {
    return this.createUpdatedEntity({ purpose }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated subscribedEvents (pure state transition)
   *
   * @param subscribedEvents - New subscribed_events value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ChannelEntity, DomainError>
   */
  public withSubscribedEvents(
    subscribedEvents: ChannelSubscribedEvents,
    updatedAt?: Date,
    version?: number,
  ): Result<ChannelEntity, DomainError> {
    return this.createUpdatedEntity({ subscribedEvents }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated enabled (pure state transition)
   *
   * @param enabled - New enabled value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ChannelEntity, DomainError>
   */
  public withEnabled(
    enabled: ChannelEnabled,
    updatedAt?: Date,
    version?: number,
  ): Result<ChannelEntity, DomainError> {
    return this.createUpdatedEntity({ enabled }, updatedAt, version);
  }

  // ======================
  // Query Methods
  // ======================

  /**
   * Checks if two channels are the same entity
   *
   * @param other - Other channel to compare
   */
  public sameAs(other: ChannelEntity): boolean {
    return this.props.code.equals(other.props.code);
  }

  /**
   * Gets a snapshot of current entity state for serialization
   */
  public toSnapshot(): ChannelSnapshotProps {
    return {
      code: this.props.code.value,
      name: this.props.name.value,
      workspaceCode: this.props.workspaceCode.value,
      isPrivate: this.props.isPrivate.value,
      isDm: this.props.isDm.value,
      topic: this.props.topic?.value,
      purpose: this.props.purpose?.value,
      subscribedEvents: this.props.subscribedEvents?.toArray(),
      enabled: this.props.enabled.value,
      createdAt: this.props.createdAt.value,
      updatedAt: this.props.updatedAt.value,
      version: this.props.version.value,
    };
  }

  /**
   * Gets the current domain state with value objects
   *
   * Provides access to the rich domain state for application layer
   * without requiring infrastructure mappers. Maintains clean architecture.
   *
   * @returns Current domain state with value objects
   */
  public getDomainState(): ChannelDomainState {
    return this.props;
  }
}
