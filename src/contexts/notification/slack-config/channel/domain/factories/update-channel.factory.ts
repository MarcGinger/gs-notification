// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, ok, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { ChannelAggregate } from '../aggregates';
import { ChannelEntity } from '../entities';
import { ChannelSnapshotProps, UpdateChannelProps } from '../props';
import { ValidatedChannelUpdateFields } from '../types';
import {
  ChannelName,
  ChannelWorkspaceId,
  ChannelIsPrivate,
  ChannelIsDm,
  ChannelTopic,
  ChannelPurpose,
  ChannelSubscribedEvents,
  ChannelEnabled,
} from '../value-objects';

/**
 * Update Channel Aggregate Factory
 *
 * Handles the complete update flow for Channel aggregates:
 * 1. Loads existing aggregate from snapshot
 * 2. Validates update properties and creates value objects
 * 3. Applies updates with proper business rule enforcement
 * 4. Returns updated aggregate ready for persistence
 *
 * This factory provides:
 * - Consistent update pattern matching create operations
 * - Centralized validation and business logic
 * - Efficient batch updates vs field-by-field
 * - Proper error context and logging integration
 */
export function updateChannelAggregateFromSnapshot(
  existingSnapshot: ChannelSnapshotProps,
  updateProps: UpdateChannelProps,
  metadata: EventMetadata,
  clock: Clock,
): Result<ChannelAggregate, DomainError> {
  // 1. Reconstitute existing aggregate
  const entityResult = ChannelEntity.fromSnapshot(existingSnapshot);
  if (!entityResult.ok) {
    return err(
      withContext(entityResult.error, {
        operation: 'update_channel_reconstitute',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
      }),
    );
  }

  const existingAggregate = ChannelAggregate.reconstitute(
    entityResult.value,
    clock,
    metadata,
  );

  // 2. Validate and apply updates for each provided field
  const validatedFields: ValidatedChannelUpdateFields = {};

  // Validate name if provided
  if (updateProps.name !== undefined) {
    const nameResult = ChannelName.from(updateProps.name);
    if (!nameResult.ok) {
      return err(
        withContext(nameResult.error, {
          operation: 'update_channel_name_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedName: updateProps.name,
        }),
      );
    }
    validatedFields.name = nameResult.value;
  }

  // Validate workspaceId if provided
  if (updateProps.workspaceId !== undefined) {
    const workspaceIdResult = ChannelWorkspaceId.from(updateProps.workspaceId);
    if (!workspaceIdResult.ok) {
      return err(
        withContext(workspaceIdResult.error, {
          operation: 'update_channel_workspace_id_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedWorkspaceId: updateProps.workspaceId,
        }),
      );
    }
    validatedFields.workspaceId = workspaceIdResult.value;
  }

  // Validate isPrivate if provided
  if (updateProps.isPrivate !== undefined) {
    const isPrivateResult = ChannelIsPrivate.from(updateProps.isPrivate);
    if (!isPrivateResult.ok) {
      return err(
        withContext(isPrivateResult.error, {
          operation: 'update_channel_is_private_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedIsPrivate: updateProps.isPrivate,
        }),
      );
    }
    validatedFields.isPrivate = isPrivateResult.value;
  }

  // Validate isDm if provided
  if (updateProps.isDm !== undefined) {
    const isDmResult = ChannelIsDm.from(updateProps.isDm);
    if (!isDmResult.ok) {
      return err(
        withContext(isDmResult.error, {
          operation: 'update_channel_is_dm_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedIsDm: updateProps.isDm,
        }),
      );
    }
    validatedFields.isDm = isDmResult.value;
  }

  // Validate topic if provided
  if (updateProps.topic !== undefined) {
    const topicResult = ChannelTopic.from(updateProps.topic);
    if (!topicResult.ok) {
      return err(
        withContext(topicResult.error, {
          operation: 'update_channel_topic_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedTopic: updateProps.topic,
        }),
      );
    }
    validatedFields.topic = topicResult.value;
  }

  // Validate purpose if provided
  if (updateProps.purpose !== undefined) {
    const purposeResult = ChannelPurpose.from(updateProps.purpose);
    if (!purposeResult.ok) {
      return err(
        withContext(purposeResult.error, {
          operation: 'update_channel_purpose_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedPurpose: updateProps.purpose,
        }),
      );
    }
    validatedFields.purpose = purposeResult.value;
  }

  // Validate subscribedEvents if provided
  if (updateProps.subscribedEvents !== undefined) {
    const subscribedEventsResult = ChannelSubscribedEvents.from(
      updateProps.subscribedEvents,
    );
    if (!subscribedEventsResult.ok) {
      return err(
        withContext(subscribedEventsResult.error, {
          operation: 'update_channel_subscribed_events_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedSubscribedEvents: updateProps.subscribedEvents,
        }),
      );
    }
    validatedFields.subscribedEvents = subscribedEventsResult.value;
  }

  // Validate enabled if provided
  if (updateProps.enabled !== undefined) {
    const enabledResult = ChannelEnabled.from(updateProps.enabled);
    if (!enabledResult.ok) {
      return err(
        withContext(enabledResult.error, {
          operation: 'update_channel_enabled_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedEnabled: updateProps.enabled,
        }),
      );
    }
    validatedFields.enabled = enabledResult.value;
  }

  // 3. Apply all validated changes in single atomic operation
  const batchUpdateResult = existingAggregate.updateBatch(validatedFields);
  if (!batchUpdateResult.ok) {
    return err(
      withContext(batchUpdateResult.error, {
        operation: 'update_product_batch_application',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        fieldsUpdated: Object.keys(validatedFields),
      }),
    );
  }

  return ok(existingAggregate);
}
