// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Inject } from '@nestjs/common';
import {
  Result,
  ok,
  err,
  DomainError,
  isOk,
  withContext,
} from 'src/shared/errors';

// Shared utilities and infrastructure
import { APP_LOGGER, componentLogger, Logger } from 'src/shared/logging';
import { CACHE_TTL } from 'src/shared/application/caching/cache.config';
import { RepositoryOptions } from 'src/shared/infrastructure/repositories/repository.types';
import { Option } from 'src/shared/domain/types';
import { ActorContextUtil } from 'src/shared/utilities/actor-context.util';
import { IUserToken } from 'src/shared/security';

// Application layer
import { IChannelQuery, CHANNEL_QUERY_TOKEN } from '../ports';
import { DetailChannelResponse } from '../dtos';
import { IGetChannelUseCase } from './contracts';
import { ChannelErrors } from '../../domain/errors';

/**
 * Get Channel Use Case - Simplified CQRS Read Side Implementation
 *
 * Simple use case that queries for channel data by code.
 * Authorization is handled at the service layer.
 */

@Injectable()
export class GetChannelUseCase implements IGetChannelUseCase {
  private readonly logger: Logger;

  constructor(
    @Inject(CHANNEL_QUERY_TOKEN)
    private readonly query: IChannelQuery,
    @Inject(APP_LOGGER) moduleLogger: Logger,
  ) {
    this.logger = componentLogger(moduleLogger, 'GetChannelUseCase');
  }

  async execute(params: {
    user: IUserToken;
    code: string;
    correlationId: string;
  }): Promise<Result<DetailChannelResponse, DomainError>> {
    const { user, code, correlationId } = params;

    // Simple input validation
    if (!code?.trim()) {
      return err({
        code: 'CHANNEL.INVALID_CODE' as const,
        title: 'Invalid code',
        category: 'validation' as const,
        context: { code, correlationId, userId: user.sub },
      });
    }

    // Setup repository options with caching
    const repositoryOptions: RepositoryOptions = {
      cache: {
        ttl: CACHE_TTL.STANDARD,
        refreshCache: false,
      },
      correlationId,
      requestId: user.sub,
    };

    // Convert user token to actor context
    const actorResult = ActorContextUtil.fromUserTokenSafe(user);
    if (!isOk(actorResult)) {
      return err(
        withContext(actorResult.error, {
          correlationId,
          userId: user.sub,
          operation: 'get_channel',
          code,
        }),
      );
    }

    // Query for the channel data
    const queryResult = await this.query.findById(
      actorResult.value,
      code,
      repositoryOptions,
    );

    if (!isOk(queryResult)) {
      return err(
        withContext(queryResult.error, {
          correlationId,
          userId: user.sub,
          operation: 'get_channel',
          code,
        }),
      );
    }

    // Handle Option<DetailChannelResponse>
    const channelDto = Option.isNone(queryResult.value)
      ? null
      : queryResult.value.value;

    if (!channelDto) {
      return err(
        withContext(ChannelErrors.CHANNEL_NOT_FOUND, {
          code,
          correlationId,
          userId: user.sub,
          operation: 'get_channel',
        }),
      );
    }

    // Success - no logging needed as this is handled at service layer

    return ok(channelDto);
  }
}
