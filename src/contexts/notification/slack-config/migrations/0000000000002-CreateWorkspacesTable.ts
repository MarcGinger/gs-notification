// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

/**
 * TypeORM Migration: CreateWorkspacesTable
 *
 * ARCHITECTURE OVERVIEW:
 * This migration creates a read model table for the Workspace domain.
 *
 * EVENT SOURCING ARCHITECTURE:
 * - EventStoreDB serves as the source of truth for all domain events
 * - This PostgreSQL table acts as a read model projection for query optimization
 * - Data flows: EventStoreDB -> Projector -> PostgreSQL Read Model
 *
 * PROJECTION STRATEGY:
 * - Events from EventStoreDB are projected into this table by domain projectors
 * - The projector handles event replay and real-time projection updates
 * - This table should only be modified through the projection process
 *
 * PERFORMANCE CONSIDERATIONS:
 * - Indexes are optimized for multi-tenant query patterns
 * - JSONB columns provide flexible storage for complex domain data
 * - Composite indexes support efficient filtering and sorting operations
 */

import { MigrationInterface, QueryRunner } from 'typeorm';

// 0 ms â†’ 1970-01-01 00:00:00 UTC
// CREATE TABLE IF NOT EXISTS "workspaces" (

export class CreateWorkspacesTable0000000000002 implements MigrationInterface {
  name = 'CreateWorkspacesTable0000000000002';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      CREATE TABLE "slack_config"."workspaces" (
        "id" VARCHAR(64) NOT NULL,
        "name" VARCHAR(255) NOT NULL,
        "bot_token" TEXT,
        "signing_secret" TEXT,
        "app_id" VARCHAR(64),
        "bot_user_id" VARCHAR(64),
        "default_channel_id" VARCHAR(64),
        "enabled" BOOLEAN NOT NULL,
        "tenant_id" VARCHAR(100) NOT NULL,
        "version" INTEGER NOT NULL DEFAULT 0,
        "created_at" TIMESTAMP NOT NULL DEFAULT NOW(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT NOW(),
        "deleted_at" TIMESTAMP,
        "last_stream_revision" VARCHAR(50),
        PRIMARY KEY ("tenant_id", "id")
      );
    `);

    // Create performance indexes for multi-tenant architecture
    await queryRunner.query(`
      CREATE INDEX "idx_workspaces_tenant_id" ON "slack_config"."workspaces" ("tenant_id");
    `);

    await queryRunner.query(`
      CREATE INDEX "idx_workspaces_created_at" ON "slack_config"."workspaces" ("created_at");
    `);

    await queryRunner.query(`
      CREATE INDEX "idx_workspaces_updated_at" ON "slack_config"."workspaces" ("updated_at");
    `);

    // Add unique constraints if needed

    // Add table comment for documentation
    await queryRunner.query(`
      COMMENT ON TABLE "slack_config"."workspaces" IS 'Read model projection for Workspace domain. Source of truth: EventStoreDB. Updated via domain projectors.';
    `);

    // Add column comments for better documentation
    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."id" IS 'Unique identifier for the Slack workspace/team, provided by Slack API during OAuth installation. This is the primary key linking all workspace-specific configurations.';
    `);
    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."name" IS 'Human-readable display name of the Slack workspace as configured by workspace administrators. Used for identification and logging purposes.';
    `);
    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."bot_token" IS 'OAuth bot token with scope permissions for posting messages, reading channels, and accessing workspace information. Encrypted at rest using AES-256 encryption for security compliance.';
    `);
    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."signing_secret" IS 'Slack application signing secret used to verify that incoming requests are genuinely from Slack. Required for webhook authentication and security validation. Encrypted using the same key as bot_token.';
    `);
    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."app_id" IS 'Unique identifier for the Slack application as registered in the Slack App Directory. Used for app-specific API calls and identifying the source of bot interactions.';
    `);
    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."bot_user_id" IS 'Unique user identifier for the bot within the workspace. Used to identify bot messages and prevent the bot from responding to its own messages in conversations.';
    `);
    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."default_channel_id" IS 'Fallback channel ID for notifications when no specific channel is configured or available. Must be a channel where the bot has posting permissions.';
    `);
    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."enabled" IS 'Global toggle for Slack integration functionality. When false, all notifications to this workspace are disabled, useful for maintenance or temporary suspension.';
    `);

    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."tenant_id" IS 'Multi-tenant isolation key - identifies which tenant this channel belongs to.';
    `);
    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."version" IS 'Aggregate version for optimistic concurrency control and event ordering.';
    `);
    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."deleted_at" IS 'Soft delete timestamp - NULL means active channel, non-NULL means logically deleted.';
    `);
    await queryRunner.query(`
      COMMENT ON COLUMN "slack_config"."workspaces"."last_stream_revision" IS 'EventStore stream revision for idempotency and duplicate event detection.';
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE "slack_config"."workspaces"`);
  }
}
