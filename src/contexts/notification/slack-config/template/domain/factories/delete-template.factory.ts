// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, ok, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { TemplateAggregate } from '../aggregates';
import { TemplateEntity } from '../entities';
import { TemplateSnapshotProps } from '../props';

/**
 * Delete Template Aggregate Factory
 *
 * Handles the complete deletion flow for Template aggregates:
 * 1. Loads existing aggregate from snapshot
 * 2. Executes domain deletion logic with proper business rule enforcement
 * 3. Generates appropriate domain events (TemplateDeleted)
 * 4. Returns updated aggregate ready for persistence
 *
 * This factory provides:
 * - Consistent deletion pattern matching create/update operations
 * - Centralized domain logic and business rule enforcement
 * - Proper event generation and aggregate state management
 * - Enhanced error context and logging integration
 * - Domain-driven design compliance
 */
export function deleteTemplateAggregateFromSnapshot(
  existingSnapshot: TemplateSnapshotProps,
  metadata: EventMetadata,
  clock: Clock,
): Result<TemplateAggregate, DomainError> {
  // 1. Reconstitute existing aggregate from snapshot
  const entityResult = TemplateEntity.fromSnapshot(existingSnapshot);
  if (!entityResult.ok) {
    return err(
      withContext(entityResult.error, {
        operation: 'delete_template_reconstitute',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        aggregateId: existingSnapshot.code,
      }),
    );
  }

  const existingAggregate = TemplateAggregate.reconstitute(
    entityResult.value,
    clock,
    metadata,
  );

  // 2. Execute domain deletion logic with business rule validation
  const deleteResult = existingAggregate.delete();
  if (!deleteResult.ok) {
    return err(
      withContext(deleteResult.error, {
        operation: 'delete_template_domain_operation',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        aggregateId: existingSnapshot.code,
        aggregateVersion: existingAggregate.version,
      }),
    );
  }

  // 3. Return the aggregate with deletion event applied
  return ok(existingAggregate);
}
