// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, ok, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { ExecuteAggregate } from '../aggregates';
import { ExecuteEntity } from '../entities';
import { ExecuteSnapshotProps, UpdateExecuteProps } from '../props';
import { ValidatedExecuteUpdateFields } from '../types';
import {
  ExecuteWorkspaceId,
  ExecuteChannelId,
  ExecuteTemplateCode,
  ExecuteRecipient,
  ExecuteData,
  createExecuteStatus,
} from '../value-objects';

/**
 * Update Execute Aggregate Factory
 *
 * Handles the complete update flow for Execute aggregates:
 * 1. Loads existing aggregate from snapshot
 * 2. Validates update properties and creates value objects
 * 3. Applies updates with proper business rule enforcement
 * 4. Returns updated aggregate ready for persistence
 *
 * This factory provides:
 * - Consistent update pattern matching create operations
 * - Centralized validation and business logic
 * - Efficient batch updates vs field-by-field
 * - Proper error context and logging integration
 */
export function updateExecuteAggregateFromSnapshot(
  existingSnapshot: ExecuteSnapshotProps,
  updateProps: UpdateExecuteProps,
  metadata: EventMetadata,
  clock: Clock,
): Result<ExecuteAggregate, DomainError> {
  // 1. Reconstitute existing aggregate
  const entityResult = ExecuteEntity.fromSnapshot(existingSnapshot);
  if (!entityResult.ok) {
    return err(
      withContext(entityResult.error, {
        operation: 'update_execute_reconstitute',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
      }),
    );
  }

  const existingAggregate = ExecuteAggregate.reconstitute(
    entityResult.value,
    clock,
    metadata,
  );

  // 2. Validate and apply updates for each provided field
  const validatedFields: ValidatedExecuteUpdateFields = {};

  // Validate workspaceId if provided
  if (updateProps.workspaceId !== undefined) {
    const workspaceIdResult = ExecuteWorkspaceId.from(updateProps.workspaceId);
    if (!workspaceIdResult.ok) {
      return err(
        withContext(workspaceIdResult.error, {
          operation: 'update_execute_workspace_id_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedWorkspaceId: updateProps.workspaceId,
        }),
      );
    }
    validatedFields.workspaceId = workspaceIdResult.value;
  }

  // Validate channelId if provided
  if (updateProps.channelId !== undefined) {
    const channelIdResult = ExecuteChannelId.from(updateProps.channelId);
    if (!channelIdResult.ok) {
      return err(
        withContext(channelIdResult.error, {
          operation: 'update_execute_channel_id_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedChannelId: updateProps.channelId,
        }),
      );
    }
    validatedFields.channelId = channelIdResult.value;
  }

  // Validate templateCode if provided
  if (updateProps.templateCode !== undefined) {
    const templateCodeResult = ExecuteTemplateCode.from(
      updateProps.templateCode,
    );
    if (!templateCodeResult.ok) {
      return err(
        withContext(templateCodeResult.error, {
          operation: 'update_execute_template_code_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedTemplateCode: updateProps.templateCode,
        }),
      );
    }
    validatedFields.templateCode = templateCodeResult.value;
  }

  // Validate recipient if provided
  if (updateProps.recipient !== undefined) {
    const recipientResult = ExecuteRecipient.from(updateProps.recipient);
    if (!recipientResult.ok) {
      return err(
        withContext(recipientResult.error, {
          operation: 'update_execute_recipient_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedRecipient: updateProps.recipient,
        }),
      );
    }
    validatedFields.recipient = recipientResult.value;
  }

  // Validate data if provided
  if (updateProps.data !== undefined) {
    const dataResult = ExecuteData.from(updateProps.data);
    if (!dataResult.ok) {
      return err(
        withContext(dataResult.error, {
          operation: 'update_execute_data_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedData: updateProps.data,
        }),
      );
    }
    validatedFields.data = dataResult.value;
  }

  // Validate status if provided
  if (updateProps.status !== undefined) {
    const statusResult = createExecuteStatus(updateProps.status);
    if (!statusResult.ok) {
      return err(
        withContext(statusResult.error, {
          operation: 'update_execute_status_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedStatus: updateProps.status,
        }),
      );
    }
    validatedFields.status = statusResult.value;
  }

  // 3. Apply all validated changes in single atomic operation
  const batchUpdateResult = existingAggregate.updateBatch(validatedFields);
  if (!batchUpdateResult.ok) {
    return err(
      withContext(batchUpdateResult.error, {
        operation: 'update_product_batch_application',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        fieldsUpdated: Object.keys(validatedFields),
      }),
    );
  }

  return ok(existingAggregate);
}
