// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Execute Projector Health Controller
// Provides health check endpoints for the Execute Projector

import { Controller, Get, Inject } from '@nestjs/common';
import { APP_LOGGER, Log, componentLogger, Logger } from 'src/shared/logging';
import { ExecuteProjector } from '../../../infrastructure/projectors';
import { ExecuteProjectionKeys } from '../../../execute-projection-keys';

@Controller('health/projectors')
export class ExecuteProjectorHealthController {
  private readonly logger: Logger;

  constructor(
    private readonly executeProjector: ExecuteProjector,
    @Inject(APP_LOGGER) baseLogger: Logger,
  ) {
    this.logger = componentLogger(
      baseLogger,
      'ExecuteProjectorHealthController',
    );
  }

  @Get('execute')
  async getExecuteProjectorHealth() {
    try {
      const health = this.executeProjector.getHealthStatus();
      const checkpoint = await this.executeProjector.getCurrentCheckpoint();

      Log.debug(this.logger, 'Execute projector health check', {
        isHealthy: health.isHealthy,
        isRunning: health.isRunning,
        projectorName: health.projectorName,
        hasCheckpoint: !!checkpoint,
      });

      return {
        isHealthy: health.isHealthy,
        isRunning: health.isRunning,
        projectorName: health.projectorName,
        subscriptionGroup: health.subscriptionGroup,
        eventsProcessed: health.eventsProcessed,
        lastProcessedAt: health.lastProcessedAt?.toISOString() || null,
        lastError: health.lastError,
        checkpointPosition: checkpoint,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      const e = error as Error;

      Log.error(this.logger, 'Execute projector health check failed', {
        error: e.message,
        stack: e.stack,
      });

      return {
        isHealthy: false,
        isRunning: false,
        projectorName: ExecuteProjectionKeys.PROJECTOR_NAME,
        subscriptionGroup: ExecuteProjectionKeys.SUBSCRIPTION_GROUP,
        eventsProcessed: 0,
        lastProcessedAt: null,
        lastError: e.message,
        checkpointPosition: null,
        timestamp: new Date().toISOString(),
      };
    }
  }

  @Get('execute/metrics')
  async getExecuteProjectorMetrics() {
    try {
      const health = this.executeProjector.getHealthStatus();
      const checkpoint = await this.executeProjector.getCurrentCheckpoint();

      // This would typically integrate with your metrics system
      // For now, return basic health metrics
      return {
        projector_status: health.isHealthy ? 1 : 0,
        projector_running: health.isRunning ? 1 : 0,
        events_processed: health.eventsProcessed,
        checkpoint_position: checkpoint || '0:0',
        last_processed_at: health.lastProcessedAt?.toISOString() || null,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      const e = error as Error;

      Log.error(this.logger, 'Execute projector metrics failed', {
        error: e.message,
      });

      return {
        projector_status: 0,
        projector_running: 0,
        events_processed: 0,
        checkpoint_position: '0:0',
        last_processed_at: null,
        timestamp: new Date().toISOString(),
        error: e.message,
      };
    }
  }
}
