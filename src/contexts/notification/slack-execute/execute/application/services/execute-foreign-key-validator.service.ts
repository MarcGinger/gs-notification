// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { Injectable, Inject } from '@nestjs/common';
import { Result, ok, err, DomainError, withContext } from 'src/shared/errors';
import { Log, Logger } from 'src/shared/logging';
import { ActorContext } from 'src/shared/application/context';
import { Option } from 'src/shared/domain/types';
import { ExecuteErrors } from '../../domain/errors';
import { SlackExecuteServiceConstants } from '../../../service-constants';
import {
  CHANNEL_REFERENCE_READER_TOKEN,
  ChannelReference,
  IChannelReader,
  TEMPLATE_REFERENCE_READER_TOKEN,
  TemplateReference,
  ITemplateReader,
  WORKSPACE_REFERENCE_READER_TOKEN,
  WorkspaceReference,
  IWorkspaceReader,
} from '../ports';

export interface ForeignKeyValidationContext {
  correlationId?: string;
  userId?: string;
  operation: string;
  component: string;
}

/**
 * Execute Foreign Key Validation Service
 *
 * Provides centralized validation for foreign key references used in Execute domain.
 * This service validates that referenced entities exist before Execute creation or updates.
 *
 * Benefits:
 * - Single responsibility for foreign key validation
 * - Reusable across create and update use cases
 * - Consistent error handling and logging
 * - Fail-fast validation to avoid expensive operations
 */
@Injectable()
export class ExecuteForeignKeyValidatorService {
  constructor(
    @Inject(TEMPLATE_REFERENCE_READER_TOKEN)
    private readonly templateReader: ITemplateReader,
    @Inject(WORKSPACE_REFERENCE_READER_TOKEN)
    private readonly workspaceReader: IWorkspaceReader,
    @Inject(CHANNEL_REFERENCE_READER_TOKEN)
    private readonly channelReader: IChannelReader,
  ) {}
  /**
   * Validates templateCode existence
   * @param actor - User context for authorization
   * @param templateCode - Template code to validate
   * @param context - Validation context for logging and error handling
   * @param logger - Logger instance for structured logging
   * @returns Result indicating validation success or failure
   */
  async validateTemplateCode(
    actor: ActorContext,
    templateCode: string | undefined,
    context: ForeignKeyValidationContext,
    logger: Logger,
  ): Promise<Result<TemplateReference | undefined, DomainError>> {
    if (!templateCode) {
      return ok(undefined);
    }
    Log.debug(logger, 'Validating templateCode foreign key', {
      application: SlackExecuteServiceConstants.SERVICE_NAME,
      component: context.component,
      method: 'validateTemplateCode',
      correlationId: context.correlationId,
      userId: context.userId,
      templateCode,
      operation: context.operation,
    });

    const templateCodeResult = await this.templateReader.findTemplateByCode(
      actor,
      templateCode,
    );

    if (!templateCodeResult.ok) {
      Log.error(logger, 'Template lookup failed during validation', {
        application: SlackExecuteServiceConstants.SERVICE_NAME,
        component: context.component,
        method: 'validateTemplateCode',
        correlationId: context.correlationId,
        userId: context.userId,
        templateCode,
        operation: context.operation,
        error: templateCodeResult.error,
      });
      return err(templateCodeResult.error);
    }

    const template = templateCodeResult.value;

    if (Option.isNone(template)) {
      Log.warn(logger, 'Template not found during validation', {
        application: SlackExecuteServiceConstants.SERVICE_NAME,
        component: context.component,
        method: 'validateTemplateCode',
        correlationId: context.correlationId,
        userId: context.userId,
        templateCode,
        operation: context.operation,
      });
      return err(
        withContext(ExecuteErrors.INVALID_TEMPLATE_CODE, {
          correlationId: context.correlationId,
          userId: context.userId,
          operation: context.operation,
          templateCode,
          reason: 'Template code does not exist in the system',
        }),
      );
    }

    Log.debug(logger, 'Template existence validation passed', {
      application: SlackExecuteServiceConstants.SERVICE_NAME,
      component: context.component,
      method: 'validateTemplateCode',
      correlationId: context.correlationId,
      userId: context.userId,
      templateCode,
      operation: context.operation,
    });

    return ok(template.value);
  }

  /**
   * Validates workspaceId existence
   * @param actor - User context for authorization
   * @param workspaceId - Workspace id to validate
   * @param context - Validation context for logging and error handling
   * @param logger - Logger instance for structured logging
   * @returns Result indicating validation success or failure
   */
  async validateWorkspaceId(
    actor: ActorContext,
    workspaceId: string | undefined,
    context: ForeignKeyValidationContext,
    logger: Logger,
  ): Promise<Result<WorkspaceReference | undefined, DomainError>> {
    if (!workspaceId) {
      return ok(undefined);
    }
    Log.debug(logger, 'Validating workspaceId foreign key', {
      application: SlackExecuteServiceConstants.SERVICE_NAME,
      component: context.component,
      method: 'validateWorkspaceId',
      correlationId: context.correlationId,
      userId: context.userId,
      workspaceId,
      operation: context.operation,
    });

    const workspaceIdResult = await this.workspaceReader.findWorkspaceById(
      actor,
      workspaceId,
    );

    if (!workspaceIdResult.ok) {
      Log.error(logger, 'Workspace lookup failed during validation', {
        application: SlackExecuteServiceConstants.SERVICE_NAME,
        component: context.component,
        method: 'validateWorkspaceId',
        correlationId: context.correlationId,
        userId: context.userId,
        workspaceId,
        operation: context.operation,
        error: workspaceIdResult.error,
      });
      return err(workspaceIdResult.error);
    }

    const workspace = workspaceIdResult.value;

    if (Option.isNone(workspace)) {
      Log.warn(logger, 'Workspace not found during validation', {
        application: SlackExecuteServiceConstants.SERVICE_NAME,
        component: context.component,
        method: 'validateWorkspaceId',
        correlationId: context.correlationId,
        userId: context.userId,
        workspaceId,
        operation: context.operation,
      });
      return err(
        withContext(ExecuteErrors.INVALID_WORKSPACE_ID, {
          correlationId: context.correlationId,
          userId: context.userId,
          operation: context.operation,
          workspaceId,
          reason: 'Workspace id does not exist in the system',
        }),
      );
    }

    Log.debug(logger, 'Workspace existence validation passed', {
      application: SlackExecuteServiceConstants.SERVICE_NAME,
      component: context.component,
      method: 'validateWorkspaceId',
      correlationId: context.correlationId,
      userId: context.userId,
      workspaceId,
      operation: context.operation,
    });

    return ok(workspace.value);
  }

  /**
   * Validates channelId existence
   * @param actor - User context for authorization
   * @param channelId - Channel id to validate
   * @param context - Validation context for logging and error handling
   * @param logger - Logger instance for structured logging
   * @returns Result indicating validation success or failure
   */
  async validateChannelId(
    actor: ActorContext,
    channelId: string | undefined,
    context: ForeignKeyValidationContext,
    logger: Logger,
  ): Promise<Result<ChannelReference | undefined, DomainError>> {
    if (!channelId) {
      return ok(undefined);
    }
    Log.debug(logger, 'Validating channelId foreign key', {
      application: SlackExecuteServiceConstants.SERVICE_NAME,
      component: context.component,
      method: 'validateChannelId',
      correlationId: context.correlationId,
      userId: context.userId,
      channelId,
      operation: context.operation,
    });

    const channelIdResult = await this.channelReader.findChannelById(
      actor,
      channelId,
    );

    if (!channelIdResult.ok) {
      Log.error(logger, 'Channel lookup failed during validation', {
        application: SlackExecuteServiceConstants.SERVICE_NAME,
        component: context.component,
        method: 'validateChannelId',
        correlationId: context.correlationId,
        userId: context.userId,
        channelId,
        operation: context.operation,
        error: channelIdResult.error,
      });
      return err(channelIdResult.error);
    }

    const channel = channelIdResult.value;

    if (Option.isNone(channel)) {
      Log.warn(logger, 'Channel not found during validation', {
        application: SlackExecuteServiceConstants.SERVICE_NAME,
        component: context.component,
        method: 'validateChannelId',
        correlationId: context.correlationId,
        userId: context.userId,
        channelId,
        operation: context.operation,
      });
      return err(
        withContext(ExecuteErrors.INVALID_CHANNEL_ID, {
          correlationId: context.correlationId,
          userId: context.userId,
          operation: context.operation,
          channelId,
          reason: 'Channel id does not exist in the system',
        }),
      );
    }

    Log.debug(logger, 'Channel existence validation passed', {
      application: SlackExecuteServiceConstants.SERVICE_NAME,
      component: context.component,
      method: 'validateChannelId',
      correlationId: context.correlationId,
      userId: context.userId,
      channelId,
      operation: context.operation,
    });

    return ok(channel.value);
  }

  /**
   * Validates all foreign keys for execute props
   * @param actor - User context for authorization
   * @param props - Execute properties containing foreign key fields
   * @param context - Validation context for logging and error handling
   * @param logger - Logger instance for structured logging
   * @returns Result indicating validation success or failure
   */
  async validateExecuteForeignKeys(
    actor: ActorContext,
    props: {
      templateCode?: string;
      workspaceId?: string;
      channelId?: string;
    },
    context: ForeignKeyValidationContext,
    logger: Logger,
  ): Promise<
    Result<
      {
        templateCode?: TemplateReference;
        workspaceId?: WorkspaceReference;
        channelId?: ChannelReference;
      },
      DomainError
    >
  > {
    // Validate templateCode if provided
    const templateCodeValidation = await this.validateTemplateCode(
      actor,
      props.templateCode,
      context,
      logger,
    );
    if (!templateCodeValidation.ok) {
      return templateCodeValidation;
    }

    // Validate workspaceId if provided
    const workspaceIdValidation = await this.validateWorkspaceId(
      actor,
      props.workspaceId,
      context,
      logger,
    );
    if (!workspaceIdValidation.ok) {
      return workspaceIdValidation;
    }

    // Validate channelId if provided
    const channelIdValidation = await this.validateChannelId(
      actor,
      props.channelId,
      context,
      logger,
    );
    if (!channelIdValidation.ok) {
      return channelIdValidation;
    }

    return ok({
      templateCode: templateCodeValidation.value,
      workspaceId: workspaceIdValidation.value,
      channelId: channelIdValidation.value,
    });
  }

  /**
   * Generic alias for validateExecuteForeignKeys to match shared runner interface
   * @param actor - Actor context for permissions and auditing
   * @param props - Props containing foreign key fields to validate
   * @param context - Validation context for logging and error handling
   * @param logger - Logger instance for structured logging
   * @returns Result indicating validation success or failure
   */
  async validateForeignKeys(
    actor: ActorContext,
    props: {
      templateCode?: string;
      workspaceId?: string;
      channelId?: string;
    },
    context: ForeignKeyValidationContext,
    logger: Logger,
  ): Promise<
    Result<
      {
        templateCode?: TemplateReference;
        workspaceId?: WorkspaceReference;
        channelId?: ChannelReference;
      },
      DomainError
    >
  > {
    return this.validateExecuteForeignKeys(actor, props, context, logger);
  }
}
