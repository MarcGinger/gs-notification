// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { EventDataProcessingUtils } from 'src/shared/infrastructure/events/utilities/event-data-processing.utils';
import {
  AuthSignatureAlgorithmValue,
  AuthTypeValue,
} from '../../application/dtos';

/**
 * Auth Field Validator Utility
 *
 * Centralized utility for parsing and validating Auth aggregate data from EventStore events.
 * Provides consistent field validation patterns that can be reused across repositories
 * and projectors for Auth domain operations.
 *
 * @domain Notification Context - Auth Field Validation Utility
 * @layer Infrastructure
 * @pattern Utility Pattern + Field Validation
 */
export class AuthFieldValidatorUtil {
  /**
   * Create projector data with SecretRef objects for Redis storage
   *
   * This method extracts SecretRef objects from event data and serializes them
   * as JSON strings for storage in Redis. The reader repository will deserialize
   * and resolve these SecretRef objects back to actual secret values.
   *
   * @param aggregateData - Raw event data from EventStore containing SecretRef objects
   * @returns Projector data object with SecretRef fields as JSON strings
   */
  static createAuthProjectorDataFromEventData(
    aggregateData: Record<string, any>,
  ): {
    webhookId: string;
    type: AuthTypeValue;
    verifyTls?: boolean;
    signingSecret?: string;
    signatureAlgorithm?: AuthSignatureAlgorithmValue;
    username?: string;
    password?: string;
    apiKey?: string;
    apiKeyHeader?: string;
    apiKeyQueryParam?: string;
    tokenUrl?: string;
    clientId?: string;
    clientSecret?: string;
    scope?: string;
    cert?: string;
    key?: string;
    ca?: string;
    version: number;
    createdAt: Date;
    updatedAt: Date;
  } {
    const webhookId = aggregateData.webhookId as string;
    const type = aggregateData.type as AuthTypeValue;
    const verifyTls =
      aggregateData.verifyTls === 'true' || aggregateData.verifyTls === true;
    const signingSecret = aggregateData.signingSecret
      ? JSON.stringify(aggregateData.signingSecret)
      : undefined;
    const signatureAlgorithm =
      aggregateData.signatureAlgorithm as AuthSignatureAlgorithmValue;
    const username = aggregateData.username
      ? JSON.stringify(aggregateData.username)
      : undefined;
    const password = aggregateData.password
      ? JSON.stringify(aggregateData.password)
      : undefined;
    const apiKey = aggregateData.apiKey
      ? JSON.stringify(aggregateData.apiKey)
      : undefined;
    const apiKeyHeader = aggregateData.apiKeyHeader as string;
    const apiKeyQueryParam = aggregateData.apiKeyQueryParam as string;
    const tokenUrl = aggregateData.tokenUrl as string;
    const clientId = aggregateData.clientId as string;
    const clientSecret = aggregateData.clientSecret
      ? JSON.stringify(aggregateData.clientSecret)
      : undefined;
    const scope = aggregateData.scope as string;
    const cert = aggregateData.cert
      ? JSON.stringify(aggregateData.cert)
      : undefined;
    const key = aggregateData.key
      ? JSON.stringify(aggregateData.key)
      : undefined;
    const ca = aggregateData.ca ? JSON.stringify(aggregateData.ca) : undefined;

    // Extract version and timestamps with proper type conversion
    const version = EventDataProcessingUtils.extractVersion(aggregateData);
    const { createdAt, updatedAt } =
      EventDataProcessingUtils.extractTimestamps(aggregateData);

    return {
      webhookId,
      type,
      verifyTls,
      signingSecret,
      signatureAlgorithm,
      username,
      password,
      apiKey,
      apiKeyHeader,
      apiKeyQueryParam,
      tokenUrl,
      clientId,
      clientSecret,
      scope,
      cert,
      key,
      ca,
      version,
      createdAt,
      updatedAt,
    };
  }
}
