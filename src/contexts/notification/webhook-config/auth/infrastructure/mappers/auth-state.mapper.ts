// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

/**
 * Auth State Infrastructure Mappers
 *
 * Bidirectional mapping between pure VO domain state and primitive persistence snapshot.
 * Handles conversion between rich domain objects and raw database data.
 */

import {
  AuthCreatedAt,
  AuthUpdatedAt,
  AuthVersion,
  AuthWebhookId,
  createAuthType,
  AuthVerifyTls,
  AuthSigningSecret,
  createAuthSignatureAlgorithm,
  AuthUsername,
  AuthPassword,
  AuthApiKey,
  AuthApiKeyHeader,
  AuthApiKeyQueryParam,
  AuthTokenUrl,
  AuthClientId,
  AuthClientSecret,
  AuthScope,
  AuthCert,
  AuthKey,
  AuthCa,
} from '../../domain/value-objects';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { AuthDomainState } from '../../domain/state/auth.state';
import { AuthSnapshotProps } from '../../domain/props';

/**
 * Infrastructure State Mapper
 *
 * Handles conversion between domain VOs and persistence primitives.
 * This is where primitive obsession is eliminated - converting between
 * rich domain objects and raw database data.
 */
export class AuthStateMapper {
  /**
   * Convert primitive persistence snapshot to rich domain state
   *
   * @param snapshot - Raw database/persistence data
   * @returns Rich domain state with VOs or error
   */
  static toDomain(
    snapshot: AuthSnapshotProps,
  ): Result<AuthDomainState, DomainError> {
    const errors: Array<{ field: string; error: DomainError }> = [];

    // Helper function to validate and collect errors
    const validateField = <T>(
      fieldName: string,
      result: Result<T, DomainError>,
    ): T | null => {
      if (!result.ok) {
        errors.push({ field: fieldName, error: result.error });
        return null;
      }
      return result.value;
    };

    // Convert each primitive to its corresponding VO with error collection
    const webhookId = validateField(
      'webhookId',
      AuthWebhookId.from(snapshot.webhookId),
    );
    const type = validateField('type', createAuthType(snapshot.type));
    const verifyTls = snapshot.verifyTls
      ? validateField('verifyTls', AuthVerifyTls.from(snapshot.verifyTls))
      : undefined;
    const signingSecret = snapshot.signingSecret
      ? validateField(
          'signingSecret',
          AuthSigningSecret.from(snapshot.signingSecret),
        )
      : undefined;
    const signatureAlgorithm = validateField(
      'signatureAlgorithm',
      createAuthSignatureAlgorithm(snapshot.signatureAlgorithm),
    );
    const username = snapshot.username
      ? validateField('username', AuthUsername.from(snapshot.username))
      : undefined;
    const password = snapshot.password
      ? validateField('password', AuthPassword.from(snapshot.password))
      : undefined;
    const apiKey = snapshot.apiKey
      ? validateField('apiKey', AuthApiKey.from(snapshot.apiKey))
      : undefined;
    const apiKeyHeader = snapshot.apiKeyHeader
      ? validateField(
          'apiKeyHeader',
          AuthApiKeyHeader.from(snapshot.apiKeyHeader),
        )
      : undefined;
    const apiKeyQueryParam = snapshot.apiKeyQueryParam
      ? validateField(
          'apiKeyQueryParam',
          AuthApiKeyQueryParam.from(snapshot.apiKeyQueryParam),
        )
      : undefined;
    const tokenUrl = snapshot.tokenUrl
      ? validateField('tokenUrl', AuthTokenUrl.from(snapshot.tokenUrl))
      : undefined;
    const clientId = snapshot.clientId
      ? validateField('clientId', AuthClientId.from(snapshot.clientId))
      : undefined;
    const clientSecret = snapshot.clientSecret
      ? validateField(
          'clientSecret',
          AuthClientSecret.from(snapshot.clientSecret),
        )
      : undefined;
    const scope = snapshot.scope
      ? validateField('scope', AuthScope.from(snapshot.scope))
      : undefined;
    const cert = snapshot.cert
      ? validateField('cert', AuthCert.from(snapshot.cert))
      : undefined;
    const key = snapshot.key
      ? validateField('key', AuthKey.from(snapshot.key))
      : undefined;
    const ca = snapshot.ca
      ? validateField('ca', AuthCa.from(snapshot.ca))
      : undefined;
    const version = validateField(
      'version',
      AuthVersion.from(snapshot.version),
    );
    const createdAt = validateField(
      'createdAt',
      AuthCreatedAt.from(snapshot.createdAt),
    );
    const updatedAt = validateField(
      'updatedAt',
      AuthUpdatedAt.from(snapshot.updatedAt),
    );

    // If any validations failed, return aggregated error
    if (errors.length > 0) {
      return err({
        code: 'AUTH.MAPPER_VALIDATION_FAILED',
        title: 'Domain State Mapping Failed',
        detail: `Failed to create domain state from persistence snapshot. ${errors.length} validation error(s) occurred.`,
        category: 'infrastructure',
        retryable: false,
        context: {
          validationErrors: errors.map((e) => ({
            field: e.field,
            errorCode: e.error.code,
            errorMessage: e.error.detail,
          })),
          snapshotCode: snapshot.webhookId,
        },
      });
    }

    // All validations passed, construct the rich domain state
    const domainState: AuthDomainState = {
      webhookId: webhookId!,
      type: type!,
      verifyTls: verifyTls || undefined,
      signingSecret: signingSecret || undefined,
      signatureAlgorithm: signatureAlgorithm || undefined,
      username: username || undefined,
      password: password || undefined,
      apiKey: apiKey || undefined,
      apiKeyHeader: apiKeyHeader || undefined,
      apiKeyQueryParam: apiKeyQueryParam || undefined,
      tokenUrl: tokenUrl || undefined,
      clientId: clientId || undefined,
      clientSecret: clientSecret || undefined,
      scope: scope || undefined,
      cert: cert || undefined,
      key: key || undefined,
      ca: ca || undefined,
      version: version!,
      createdAt: createdAt!,
      updatedAt: updatedAt!,
    };

    return ok(domainState);
  }

  /**
   * Convert rich domain state to primitive persistence snapshot
   *
   * @param domainState - Rich domain state with VOs
   * @returns Raw persistence data for database storage
   */
  static toSnapshot(domainState: AuthDomainState): AuthSnapshotProps {
    return {
      // Extract primitive values from VOs
      webhookId: domainState.webhookId.value,
      type: domainState.type.value,
      verifyTls: domainState.verifyTls?.value,
      signingSecret: domainState.signingSecret?.value,
      signatureAlgorithm: domainState.signatureAlgorithm?.value,
      username: domainState.username?.value,
      password: domainState.password?.value,
      apiKey: domainState.apiKey?.value,
      apiKeyHeader: domainState.apiKeyHeader?.value,
      apiKeyQueryParam: domainState.apiKeyQueryParam?.value,
      tokenUrl: domainState.tokenUrl?.value,
      clientId: domainState.clientId?.value,
      clientSecret: domainState.clientSecret?.value,
      scope: domainState.scope?.value,
      cert: domainState.cert?.value,
      key: domainState.key?.value,
      ca: domainState.ca?.value,
      version: domainState.version.value,
      createdAt: domainState.createdAt.value,
      updatedAt: domainState.updatedAt.value,
    };
  }
}
