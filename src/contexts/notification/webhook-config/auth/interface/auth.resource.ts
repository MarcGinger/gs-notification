// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

/**
 * Auth Resource Decorators - Domain-Driven Authorization
 *
 * Clean integration with domain-driven permissions infrastructure.
 * All business rules and risk assessments come from the domain layer.
 *
 * ARCHITECTURAL PRINCIPLE: No business logic duplication
 * ✅ Risk levels: AuthPermissionHelpers.getRiskLevel()
 * ✅ Justification rules: AuthPermissionHelpers.requiresJustification()
 * ✅ Categories: AuthPermissionRegistry[permission].category
 * ✅ Policy paths: AuthPermissionHelpers.getPolicyPath()
 * ✅ Audit requirements: AuthPermissionRegistry[permission].auditRequired
 *
 * This keeps the HTTP layer thin and ensures business rules
 * live in the domain where they belong.
 */

import { Resource } from 'src/shared/security/opa';
import { Request } from 'express';
import {
  AuthPermission,
  AuthPermissionHelpers,
  AuthPermissionRegistry,
} from '../domain/permissions';

/**
 * Domain-driven Auth resource decorator
 *
 * All business rules come from the domain layer - no duplication!
 */
export const AuthResource = (permission: AuthPermission) =>
  Resource({
    type: 'auth',
    action: permission,
    extractId: (req: Request) => req.params?.webhookId || req.params?.id,
    extractAttributes: (req: Request) => {
      const body = req.body as Record<string, unknown> | undefined;
      const query = req.query as Record<string, unknown> | undefined;

      // Business data extraction
      const type = body?.type || query?.type;
      const verifyTls = body?.verifyTls || query?.verifyTls;
      const signingSecret = body?.signingSecret || query?.signingSecret;
      const signatureAlgorithm =
        body?.signatureAlgorithm || query?.signatureAlgorithm;
      const username = body?.username || query?.username;
      const password = body?.password || query?.password;
      const apiKey = body?.apiKey || query?.apiKey;
      const apiKeyHeader = body?.apiKeyHeader || query?.apiKeyHeader;
      const apiKeyQueryParam =
        body?.apiKeyQueryParam || query?.apiKeyQueryParam;
      const tokenUrl = body?.tokenUrl || query?.tokenUrl;
      const clientId = body?.clientId || query?.clientId;
      const clientSecret = body?.clientSecret || query?.clientSecret;
      const scope = body?.scope || query?.scope;
      const cert = body?.cert || query?.cert;
      const key = body?.key || query?.key;
      const ca = body?.ca || query?.ca;

      const baseAttributes = {
        type,
        verifyTls,
        signingSecret,
        signatureAlgorithm,
        username,
        password,
        apiKey,
        apiKeyHeader,
        apiKeyQueryParam,
        tokenUrl,
        clientId,
        clientSecret,
        scope,
        cert,
        key,
        ca,
      };

      // Domain-driven permission context (no hardcoded business rules!)
      const permissionMeta = AuthPermissionRegistry[permission];
      const permissionContext = {
        permission,
        riskLevel: AuthPermissionHelpers.getRiskLevel(permission),
        requiresJustification:
          AuthPermissionHelpers.requiresJustification(permission),
        category: permissionMeta?.category as string,
        policyPath: AuthPermissionHelpers.getPolicyPath(permission),
        auditRequired: AuthPermissionHelpers.requiresAudit(permission),
      };

      return {
        ...baseAttributes,
        _permissionContext: permissionContext,
      };
    },
  });

/**
 * Specialized decorators for high-risk operations
 */
export const AuthDeleteResource = () =>
  AuthResource(AuthPermission.DOMAIN_AUTH_DELETE);

export const AuthCreateResource = () =>
  AuthResource(AuthPermission.DOMAIN_AUTH_CREATE);

export const AuthUpdateResource = () =>
  AuthResource(AuthPermission.DOMAIN_AUTH_UPDATE);

export const AuthReadResource = () =>
  AuthResource(AuthPermission.DOMAIN_AUTH_READ);
