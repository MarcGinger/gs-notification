// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Inject } from '@nestjs/common';
import { Result, DomainError, ok, err } from 'src/shared/errors';
import { ActorContext } from 'src/shared/application/context';

// Shared utilities and infrastructure
import { APP_LOGGER, componentLogger, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import { Option } from 'src/shared/domain/types';
import { runUseCaseWithSecurity } from 'src/shared/application/utils';
import { extractDefinedFields } from 'src/shared/utilities';
import {
  UseCaseLoggingUtil,
  UseCaseLoggingConfig,
} from 'src/shared/application/utils/use-case-logging.util';
import { IUserToken } from 'src/shared/security';

// Service configuration
import { WebhookConfigServiceConstants } from '../../../service-constants';

// Domain types and errors
import { AuthAggregate } from '../../domain/aggregates';
import { CreateAuthProps, UpsertAuthProps } from '../../domain/props';
import { AuthWebhookId } from '../../domain/value-objects';
import {
  createAuthAggregateFromProps,
  updateAuthAggregateFromSnapshot,
} from '../../domain/factories';
import { AuthErrors } from '../../domain/errors';

// Application layer
import {
  IAuthReader,
  IAuthWriter,
  AUTH_READER_TOKEN,
  AUTH_WRITER_TOKEN,
} from '../ports';
import { UpsertAuthCommand } from '../commands';
import { IUpsertAuthUseCase } from './contracts';

import {
  AuthForeignKeyValidatorService,
  AuthAuthorizationAdapter,
} from '../services';
import { DetailAuthResponse } from '../dtos';
import { AuthDtoAssembler } from '../assemblers';
// Shared compliance services
import {
  PIIClassificationService,
  PIIProtectionService,
  DataRetentionService,
} from 'src/shared/services/compliance';
type AuthSnapshot = Parameters<typeof updateAuthAggregateFromSnapshot>[0];

@Injectable()
export class UpsertAuthUseCase implements IUpsertAuthUseCase {
  private readonly logger: Logger;
  private readonly loggingConfig: UseCaseLoggingConfig;

  constructor(
    @Inject(AUTH_READER_TOKEN)
    private readonly authReader: IAuthReader,
    @Inject(AUTH_WRITER_TOKEN)
    private readonly authWriter: IAuthWriter,
    private readonly foreignKeyValidator: AuthForeignKeyValidatorService,
    private readonly authorizationService: AuthAuthorizationAdapter,
    @Inject(APP_LOGGER)
    readonly moduleLogger: Logger,
    @Inject(CLOCK)
    private readonly clock: Clock,
    private readonly piiClassificationService: PIIClassificationService,
    private readonly piiProtectionService: PIIProtectionService,
    private readonly dataRetentionService: DataRetentionService,
  ) {
    this.loggingConfig = {
      serviceName: WebhookConfigServiceConstants.SERVICE_NAME,
      component: 'UpsertAuthUseCase',
      domain: 'webhook-config',
      entityType: 'auth',
    };
    this.logger = componentLogger(moduleLogger, this.loggingConfig.component);
  }
  async execute(params: {
    user: IUserToken;
    webhookId: string;
    props: UpsertAuthProps;
    correlationId: string;
    authorizationReason: string;
  }): Promise<Result<DetailAuthResponse, DomainError>> {
    const operation = 'upsert_auth';
    const startTime = this.clock.nowMs();

    // Create a command-like object for internal use
    const command = {
      user: params.user,
      webhookId: params.webhookId,
      props: params.props,
      correlationId: params.correlationId,
      authorizationReason: params.authorizationReason,
      securityContext: {
        tenant: params.user.tenant,
        userId: params.user.sub,
        roles: params.user.roles,
      },
      timestamp: this.clock.now(),
    };

    // Step 1: Validate command (before creating any log context to avoid PII logging)
    const validation = UseCaseLoggingUtil.validateCommand(
      this.logger,
      command,
      {}, // Empty context to avoid PII logging during validation
    );
    if (!validation.ok) {
      return err(validation.error);
    }

    // Step 2: Check PII compliance for input data with domain context
    const classification = this.piiClassificationService.classifyData(
      {
        signingSecret: command.props.signingSecret,

        username: command.props.username,

        password: command.props.password,

        apiKey: command.props.apiKey,

        clientSecret: command.props.clientSecret,

        cert: command.props.cert,

        key: command.props.key,

        ca: command.props.ca,
      },
      {
        domain: 'webhook-config',
        tenant: command.user.tenant,
        // entityType: 'Auth' // Future: for entity-level rules
      },
    );

    // Step 3: Create safe log context (no raw command that might contain PII)
    const safeLogContext = UseCaseLoggingUtil.createLogContext(
      this.loggingConfig,
      this.clock,
      operation,
      {
        correlationId: command.correlationId,
        user: command.user,
        securityContext: command.securityContext,
        timestamp: command.timestamp,
      },
      {
        authWebhookId: command.webhookId,
        operationRisk: UseCaseLoggingUtil.assessOperationRisk(operation),
      },
    );

    // Log compliance check with detailed audit trail
    UseCaseLoggingUtil.logComplianceCheck(
      this.logger,
      operation,
      safeLogContext,
      classification,
    );

    // Step 4: Mask payload for logging if PII detected (no domain mutation)
    const rawProps = command.props; // Keep original for domain processing

    if (classification.containsPII) {
      const maskedForLog = this.piiProtectionService.maskForLog(
        rawProps as unknown as Record<string, unknown>,
        classification,
      );
      this.logger.debug(
        { ...safeLogContext, payload: maskedForLog },
        'masked input for audit',
      );
    }

    // Step 5: Robust audit generation with error handling
    if (classification.containsPII) {
      try {
        this.piiProtectionService.generateProtectionAudit(
          [], // No protection log since we're not mutating domain data
          {
            userId: command.user.sub,
            tenant: command.user.tenant,
            operation: 'upsert_auth',
            domain: 'webhook-config',
            entityType: 'auth',
          },
        );
      } catch (e) {
        this.logger.warn(
          { err: e as Error, ...safeLogContext },
          'protection audit failed (non-fatal)',
        );
      }
    }

    // Step 6: Upsert aggregate with raw data (no domain mutation)
    const fieldsToUpdate = extractDefinedFields(rawProps || {});

    // Note: UpsertAuthProps approach provides cleaner validation semantics
    // The unified props structure eliminates complex type mappings and assertions

    // ---- UPSERT CORE ------------------------------------------------------
    // We first try to load; if not found, we'll "create" instead of erroring.

    // Discover existence ahead of time to configure auth intent correctly
    const codeR = AuthWebhookId.create(command.webhookId);
    if (!codeR.ok) return err(codeR.error);

    // Create actor context using the standard utility
    const actor: ActorContext = {
      tenant: command.user.tenant,
      userId: command.user.sub,
      tenant_userId: command.user.tenant_id || '',
      username: command.user.email,
      roles: command.user.roles,
    };

    const existsR = await this.authReader.exists(actor, codeR.value);
    if (!existsR.ok) return err(existsR.error);

    const isCreate = !existsR.value;
    const authType = isCreate ? 'create' : 'update';

    const aggregateResult = await runUseCaseWithSecurity<
      UpsertAuthCommand,
      AuthAggregate,
      AuthSnapshot
    >({
      serviceName: WebhookConfigServiceConstants.SERVICE_NAME,
      component: 'UpsertAuthUseCase',
      operation: isCreate ? 'create_auth' : 'update_auth',
      source: 'auth-config.application.upsert-auth',
      command,
      logger: this.logger,
      clock: this.clock,

      repo: {
        save: async (
          actor: ActorContext,
          auth: AuthAggregate,
          expectedVersion?: number,
        ) => {
          const result = await this.authWriter.save(
            actor,
            auth,
            expectedVersion,
          );
          return result.ok ? ok(undefined) : result;
        },
      },

      fkValidator: this.foreignKeyValidator,
      propsMissingError: AuthErrors.INVALID_AUTH_DATA,

      authorizationService: this.authorizationService,
      authorization: isCreate
        ? {
            type: 'create' as const,
            operation: 'create' as const,
          }
        : {
            type: 'update' as const,
            operation: 'update' as const,
            resourceId: command.webhookId,
            fields: fieldsToUpdate.map(String),
          },
      authContext: {
        userId: command.user.sub,
        tenant: command.user.tenant,
        tenant_userId: command.user.tenant_id || '',
        roles: command.user.roles,
        operationType: authType,
      },

      // Load (if exists) but DO NOT error on missing â†’ allow create path
      // For upsert operations, only load if we know it exists
      loadExisting: async () => {
        if (!isCreate) {
          // We know it exists, so load it for update
          const foundR = await this.authReader.findById(actor, codeR.value);
          if (!foundR.ok) return foundR;

          // Handle Option type - extract value from Some or treat None as undefined
          if (Option.isNone(foundR.value)) {
            return ok(undefined as unknown as AuthSnapshot);
          }

          return ok(foundR.value.value);
        }
        // Return ok with undefined for create path; runDomain will create
        return Promise.resolve(ok(undefined as unknown as AuthSnapshot));
      },

      // Merge/update when existing, otherwise create with props
      runDomain: ({ existing, metadata, clock }) => {
        // Enhance metadata with PII classification results
        const enhancedMetadata = {
          ...metadata,
          piiProtected: classification.containsPII,
          dataClassification: classification.containsPII
            ? ('confidential' as const)
            : ('internal' as const),
          encryptionRequired:
            classification.containsPII && classification.requiresEncryption,
        };

        if (existing) {
          // UPDATE path - use existing update logic with enhanced metadata
          return updateAuthAggregateFromSnapshot(
            existing,
            rawProps || {},
            enhancedMetadata,
            clock,
          );
        }
        // CREATE path - Validate and transform, no default creation
        const upsertProps = {
          ...(rawProps || {}),
          webhookId: command.webhookId,
        };

        const createProps = upsertProps as CreateAuthProps;
        return createAuthAggregateFromProps(
          createProps,
          enhancedMetadata,
          clock,
        );
      },
    });

    if (!aggregateResult.ok) {
      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        aggregateResult.error,
        'HIGH',
      );
      return aggregateResult;
    }

    const aggregate = aggregateResult.value;

    // Step 7: Generate retention metadata now that entityId is known
    if (classification.containsPII) {
      try {
        const retention =
          await this.dataRetentionService.generateRetentionMetadata(
            classification,
            {
              tenant: command.user.tenant,
              userId: command.user.sub,
              entityType: 'auth',
              entityId: aggregate.id.toString(), // Now we have the actual ID
              domain: 'webhook-config',
            },
          );

        // Log comprehensive compliance protection details
        UseCaseLoggingUtil.logComplianceProtection(
          this.logger,
          operation,
          safeLogContext,
          {
            fieldsProtected: 0, // No fields mutated at domain level
            strategiesUsed: ['classification-only'],
            auditGenerated: true,
            retentionApplied: true,
            retentionExpiry: new Date(retention.retentionExpiry),
            legalBasis: retention.legalBasis,
            automaticDeletion: retention.automaticDeletion,
            auditRecord: retention.auditRecord.tenant,
          },
        );
      } catch (e) {
        this.logger.warn(
          { err: e as Error, ...safeLogContext },
          'retention metadata generation failed (non-fatal)',
        );
      }
    }

    const domainState = aggregate.toDomainState();
    const dto = AuthDtoAssembler.toDetailResponse(domainState);

    const executionTime = this.clock.nowMs() - startTime;
    UseCaseLoggingUtil.logOperationSuccess(
      this.logger,
      operation,
      safeLogContext,
      {
        executionTimeMs: executionTime,
        aggregateVersion: aggregate.version,
        eventCount: aggregate.uncommittedEvents?.length ?? 0,
        businessData: {
          SigningSecret: dto.signingSecret,

          Username: dto.username,

          Password: dto.password,

          ApiKey: dto.apiKey,

          ClientSecret: dto.clientSecret,

          Cert: dto.cert,

          Key: dto.key,

          Ca: dto.ca,

          // ... other non-PII business fields
          complianceApplied: classification.containsPII,
          fieldsUpdated: Object.keys(fieldsToUpdate).length,
          upsertAction: isCreate ? 'created' : 'updated',
        },
      },
    );

    return ok(dto);
  }
}
