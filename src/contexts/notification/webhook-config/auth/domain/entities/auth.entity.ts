// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { EntityIdBase } from 'src/shared/domain/entities';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { AuthSnapshotProps } from '../props';
import { AuthDomainState } from '../state';
import { AuthErrors } from '../errors/auth.errors';
import {
  AuthApiKey,
  AuthApiKeyHeader,
  AuthApiKeyQueryParam,
  AuthCa,
  AuthCert,
  AuthClientId,
  AuthClientSecret,
  AuthCreatedAt,
  AuthUpdatedAt,
  AuthVersion,
  AuthKey,
  AuthPassword,
  AuthScope,
  AuthSignatureAlgorithm,
  AuthSignatureAlgorithmLogic,
  AuthSigningSecret,
  AuthTokenUrl,
  AuthType,
  AuthTypeLogic,
  AuthUsername,
  AuthVerifyTls,
  AuthWebhookId,
  createAuthSignatureAlgorithm,
  createAuthType,
} from '../value-objects';

/**
 * Domain Entity: Auth
 *
 * Represents the core Auth entity in the notification domain.
 * Encapsulates auth data, identity, and basic entity behavior.
 *
 * This entity follows DDD principles:
 * - Identity: WebhookId as unique identifier
 * - Immutability: Changes create new instances
 * - Encapsulation: Private state with controlled access
 * - Business validation: Domain rules enforced
 *
 * @domain Notification Context - Auth Entity
 * @layer Domain Entities
 */

/**
 * Auth Entity
 *
 * Core domain entity representing a auth in the notification.
 * Handles auth identity, validation, and state management.
 */
export class AuthEntity extends EntityIdBase<AuthDomainState, AuthWebhookId> {
  private static clock: { now: () => Date } = { now: () => new Date() };

  public static setClock(c: { now: () => Date }) {
    this.clock = c;
  }

  /**
   * Helper method to create updatedAt VO from date
   */
  private static createUpdatedAt(
    date?: Date,
  ): Result<AuthUpdatedAt, DomainError> {
    const targetDate = date || AuthEntity.clock.now();
    const result = AuthUpdatedAt.from(targetDate);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create version VO from number
   */
  private static createVersion(
    versionNumber?: number,
    currentVersion?: AuthVersion,
  ): Result<AuthVersion, DomainError> {
    const targetVersion = versionNumber ?? currentVersion?.value ?? 1;
    const result = AuthVersion.from(targetVersion);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create updated entity with common logic
   */
  private createUpdatedEntity(
    fieldUpdates: Partial<AuthDomainState>,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    const updatedAtResult = AuthEntity.createUpdatedAt(updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = AuthEntity.createVersion(version, this.props.version);
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const updatedProps: AuthDomainState = {
      ...this.props,
      ...fieldUpdates,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return AuthEntity.create(updatedProps);
  }

  private constructor(props: AuthDomainState) {
    super(props, props.webhookId);
  }

  /**
   * Factory method to create a new auth entity
   *
   * @param props - Auth properties
   * @returns Result containing AuthEntity or DomainError
   */
  public static create(
    props: AuthDomainState,
  ): Result<AuthEntity, DomainError> {
    // Validate required properties
    const validationResult = AuthEntity.validate(props);
    if (validationResult.ok === false) {
      return err(validationResult.error);
    }

    return ok(new AuthEntity(props));
  }

  /**
   * Factory method to reconstitute a auth entity from persistence
   *
   * @param props - Auth properties from database
   * @returns AuthEntity instance
   */
  public static reconstitute(props: AuthDomainState): AuthEntity {
    return new AuthEntity(props);
  }

  /**
   * Factory method to reconstitute entity from snapshot
   *
   * @param snapshot - Auth snapshot properties
   * @returns Result containing AuthEntity or DomainError
   */
  public static fromSnapshot(
    snapshot: AuthSnapshotProps,
  ): Result<AuthEntity, DomainError> {
    const webhookIdResult = AuthWebhookId.from(snapshot.webhookId);
    if (!webhookIdResult.ok) {
      return err(webhookIdResult.error);
    }
    const typeResult = createAuthType(snapshot.type);
    if (!typeResult.ok) {
      return err(typeResult.error);
    }
    const verifyTlsResult = AuthVerifyTls.from(snapshot.verifyTls);
    if (!verifyTlsResult.ok) {
      return err(verifyTlsResult.error);
    }
    const signingSecretResult = AuthSigningSecret.from(snapshot.signingSecret);
    if (!signingSecretResult.ok) {
      return err(signingSecretResult.error);
    }
    const signatureAlgorithmResult = createAuthSignatureAlgorithm(
      snapshot.signatureAlgorithm,
    );
    if (!signatureAlgorithmResult.ok) {
      return err(signatureAlgorithmResult.error);
    }
    const usernameResult = AuthUsername.from(snapshot.username);
    if (!usernameResult.ok) {
      return err(usernameResult.error);
    }
    const passwordResult = AuthPassword.from(snapshot.password);
    if (!passwordResult.ok) {
      return err(passwordResult.error);
    }
    const apiKeyResult = AuthApiKey.from(snapshot.apiKey);
    if (!apiKeyResult.ok) {
      return err(apiKeyResult.error);
    }
    const apiKeyHeaderResult = AuthApiKeyHeader.from(snapshot.apiKeyHeader);
    if (!apiKeyHeaderResult.ok) {
      return err(apiKeyHeaderResult.error);
    }
    const apiKeyQueryParamResult = AuthApiKeyQueryParam.from(
      snapshot.apiKeyQueryParam,
    );
    if (!apiKeyQueryParamResult.ok) {
      return err(apiKeyQueryParamResult.error);
    }
    const tokenUrlResult = AuthTokenUrl.from(snapshot.tokenUrl);
    if (!tokenUrlResult.ok) {
      return err(tokenUrlResult.error);
    }
    const clientIdResult = AuthClientId.from(snapshot.clientId);
    if (!clientIdResult.ok) {
      return err(clientIdResult.error);
    }
    const clientSecretResult = AuthClientSecret.from(snapshot.clientSecret);
    if (!clientSecretResult.ok) {
      return err(clientSecretResult.error);
    }
    const scopeResult = AuthScope.from(snapshot.scope);
    if (!scopeResult.ok) {
      return err(scopeResult.error);
    }
    const certResult = AuthCert.from(snapshot.cert);
    if (!certResult.ok) {
      return err(certResult.error);
    }
    const keyResult = AuthKey.from(snapshot.key);
    if (!keyResult.ok) {
      return err(keyResult.error);
    }
    const caResult = AuthCa.from(snapshot.ca);
    if (!caResult.ok) {
      return err(caResult.error);
    }
    const createdAtResult = AuthCreatedAt.from(snapshot.createdAt);
    if (!createdAtResult.ok) {
      return err(createdAtResult.error);
    }

    const updatedAtResult = AuthUpdatedAt.from(snapshot.updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = AuthVersion.from(snapshot.version);
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const props: AuthDomainState = {
      webhookId: webhookIdResult.value,
      type: typeResult.value,
      verifyTls: verifyTlsResult.value,
      signingSecret: signingSecretResult.value,
      signatureAlgorithm: signatureAlgorithmResult.value,
      username: usernameResult.value,
      password: passwordResult.value,
      apiKey: apiKeyResult.value,
      apiKeyHeader: apiKeyHeaderResult.value,
      apiKeyQueryParam: apiKeyQueryParamResult.value,
      tokenUrl: tokenUrlResult.value,
      clientId: clientIdResult.value,
      clientSecret: clientSecretResult.value,
      scope: scopeResult.value,
      cert: certResult.value,
      key: keyResult.value,
      ca: caResult.value,
      createdAt: createdAtResult.value,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return AuthEntity.create(props);
  }

  /**
   * Validates auth entity properties
   *
   * @param props - Properties to validate
   * @returns Validation result
   */
  private static validate(props: AuthDomainState): Result<void, DomainError> {
    // Basic validation
    if (!props.webhookId) {
      return err(AuthErrors.INVALID_WEBHOOK_ID_DATA);
    }
    if (!props.type) {
      return err(AuthErrors.INVALID_TYPE_DATA);
    }

    return ok(undefined);
  }

  // ======================
  // Getters (Public API)
  // ======================

  public get webhookId(): AuthWebhookId {
    return this.props.webhookId;
  }

  public get type(): AuthType {
    return this.props.type;
  }

  public get verifyTls(): AuthVerifyTls | undefined {
    return this.props.verifyTls;
  }

  public get signingSecret(): AuthSigningSecret | undefined {
    return this.props.signingSecret;
  }

  public get signatureAlgorithm(): AuthSignatureAlgorithm | undefined {
    return this.props.signatureAlgorithm;
  }

  public get username(): AuthUsername | undefined {
    return this.props.username;
  }

  public get password(): AuthPassword | undefined {
    return this.props.password;
  }

  public get apiKey(): AuthApiKey | undefined {
    return this.props.apiKey;
  }

  public get apiKeyHeader(): AuthApiKeyHeader | undefined {
    return this.props.apiKeyHeader;
  }

  public get apiKeyQueryParam(): AuthApiKeyQueryParam | undefined {
    return this.props.apiKeyQueryParam;
  }

  public get tokenUrl(): AuthTokenUrl | undefined {
    return this.props.tokenUrl;
  }

  public get clientId(): AuthClientId | undefined {
    return this.props.clientId;
  }

  public get clientSecret(): AuthClientSecret | undefined {
    return this.props.clientSecret;
  }

  public get scope(): AuthScope | undefined {
    return this.props.scope;
  }

  public get cert(): AuthCert | undefined {
    return this.props.cert;
  }

  public get key(): AuthKey | undefined {
    return this.props.key;
  }

  public get ca(): AuthCa | undefined {
    return this.props.ca;
  }

  public get createdAt(): AuthCreatedAt {
    return this.props.createdAt;
  }

  public get updatedAt(): AuthUpdatedAt {
    return this.props.updatedAt;
  }

  public get version(): AuthVersion {
    return this.props.version;
  }

  // ======================
  // Simple Update Methods (No Business Logic)
  // ======================

  /**
   * Creates a new entity with updated type (with basic transition validation)
   *
   * @param type - New type value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withType(
    type: AuthType,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    const currentStatus = this.props.type.value;
    const targetStatus = type.value;

    if (!AuthTypeLogic.canTransition(currentStatus, targetStatus)) {
      return err({
        ...AuthErrors.INVALID_TYPE_TRANSITION,
        context: {
          currentStatus,
          targetStatus,
          validTransitions: AuthTypeLogic.getValidTransitions(currentStatus),
        },
      });
    }

    return this.createUpdatedEntity({ type }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated verifyTls (pure state transition)
   *
   * @param verifyTls - New verifyTls value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withVerifyTls(
    verifyTls: AuthVerifyTls,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ verifyTls }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated signingSecret (pure state transition)
   *
   * @param signingSecret - New signingSecret value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withSigningSecret(
    signingSecret: AuthSigningSecret,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ signingSecret }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated signatureAlgorithm (with basic transition validation)
   *
   * @param signatureAlgorithm - New signatureAlgorithm value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withSignatureAlgorithm(
    signatureAlgorithm: AuthSignatureAlgorithm,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    if (this.props.signatureAlgorithm) {
      // If current status exists, validate transition
      const currentStatus = this.props.signatureAlgorithm.value;
      const targetStatus = signatureAlgorithm.value;

      if (
        !AuthSignatureAlgorithmLogic.canTransition(currentStatus, targetStatus)
      ) {
        return err({
          ...AuthErrors.INVALID_SIGNATURE_ALGORITHM_TRANSITION,
          context: {
            currentStatus,
            targetStatus,
            validTransitions:
              AuthSignatureAlgorithmLogic.getValidTransitions(currentStatus),
          },
        });
      }
    }

    return this.createUpdatedEntity({ signatureAlgorithm }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated username (pure state transition)
   *
   * @param username - New username value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withUsername(
    username: AuthUsername,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ username }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated password (pure state transition)
   *
   * @param password - New password value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withPassword(
    password: AuthPassword,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ password }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated apiKey (pure state transition)
   *
   * @param apiKey - New apiKey value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withApiKey(
    apiKey: AuthApiKey,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ apiKey }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated apiKeyHeader (pure state transition)
   *
   * @param apiKeyHeader - New apiKeyHeader value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withApiKeyHeader(
    apiKeyHeader: AuthApiKeyHeader,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ apiKeyHeader }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated apiKeyQueryParam (pure state transition)
   *
   * @param apiKeyQueryParam - New apiKeyQueryParam value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withApiKeyQueryParam(
    apiKeyQueryParam: AuthApiKeyQueryParam,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ apiKeyQueryParam }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated tokenUrl (pure state transition)
   *
   * @param tokenUrl - New tokenUrl value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withTokenUrl(
    tokenUrl: AuthTokenUrl,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ tokenUrl }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated clientId (pure state transition)
   *
   * @param clientId - New clientId value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withClientId(
    clientId: AuthClientId,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ clientId }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated clientSecret (pure state transition)
   *
   * @param clientSecret - New clientSecret value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withClientSecret(
    clientSecret: AuthClientSecret,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ clientSecret }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated scope (pure state transition)
   *
   * @param scope - New scope value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withScope(
    scope: AuthScope,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ scope }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated cert (pure state transition)
   *
   * @param cert - New cert value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withCert(
    cert: AuthCert,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ cert }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated key (pure state transition)
   *
   * @param key - New key value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withKey(
    key: AuthKey,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ key }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated ca (pure state transition)
   *
   * @param ca - New ca value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthEntity, DomainError>
   */
  public withCa(
    ca: AuthCa,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthEntity, DomainError> {
    return this.createUpdatedEntity({ ca }, updatedAt, version);
  }

  // ======================
  // Query Methods
  // ======================

  /**
   * Checks if two auths are the same entity
   *
   * @param other - Other auth to compare
   */
  public sameAs(other: AuthEntity): boolean {
    return this.props.webhookId.equals(other.props.webhookId);
  }

  /**
   * Gets a snapshot of current entity state for serialization
   */
  public toSnapshot(): AuthSnapshotProps {
    return {
      webhookId: this.props.webhookId.value,
      type: this.props.type.value,
      verifyTls: this.props.verifyTls?.value,
      signingSecret: this.props.signingSecret?.value,
      signatureAlgorithm: this.props.signatureAlgorithm?.value,
      username: this.props.username?.value,
      password: this.props.password?.value,
      apiKey: this.props.apiKey?.value,
      apiKeyHeader: this.props.apiKeyHeader?.value,
      apiKeyQueryParam: this.props.apiKeyQueryParam?.value,
      tokenUrl: this.props.tokenUrl?.value,
      clientId: this.props.clientId?.value,
      clientSecret: this.props.clientSecret?.value,
      scope: this.props.scope?.value,
      cert: this.props.cert?.value,
      key: this.props.key?.value,
      ca: this.props.ca?.value,
      createdAt: this.props.createdAt.value,
      updatedAt: this.props.updatedAt.value,
      version: this.props.version.value,
    };
  }

  /**
   * Gets the current domain state with value objects
   *
   * Provides access to the rich domain state for application layer
   * without requiring infrastructure mappers. Maintains clean architecture.
   *
   * @returns Current domain state with value objects
   */
  public getDomainState(): AuthDomainState {
    return this.props;
  }
}
