// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { AuthAggregate } from '../aggregates';
import { CreateAuthProps } from '../props';
import { AuthDomainState } from '../state';
import {
  AuthCreatedAt,
  AuthUpdatedAt,
  AuthVersion,
  AuthWebhookId,
  createAuthType,
  AuthVerifyTls,
  AuthSigningSecret,
  createAuthSignatureAlgorithm,
  AuthUsername,
  AuthPassword,
  AuthApiKey,
  AuthApiKeyHeader,
  AuthApiKeyQueryParam,
  AuthTokenUrl,
  AuthClientId,
  AuthClientSecret,
  AuthScope,
  AuthCert,
  AuthKey,
  AuthCa,
} from '../value-objects';

/**
 * Enhanced auth entity factory with comprehensive validation and security context
 * Moved from application layer to properly separate business concerns
 */
export function createAuthAggregateFromProps(
  props: CreateAuthProps,
  metadata: EventMetadata,
  clock: Clock,
  // validatedEntities?: {
  //  channels?: ChannelReference[];
  // },
): Result<AuthAggregate, DomainError> {
  // Validate each property by creating value objects
  const webhookIdResult = AuthWebhookId.from(props.webhookId);
  if (!webhookIdResult.ok) {
    return err(
      withContext(webhookIdResult.error, {
        ...webhookIdResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        webhookId: props.webhookId,
      }),
    );
  }

  const typeResult = createAuthType(props.type);
  if (!typeResult.ok) {
    return err(
      withContext(typeResult.error, {
        ...typeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        type: props.type,
      }),
    );
  }

  const verifyTlsResult = AuthVerifyTls.from(props.verifyTls);
  if (!verifyTlsResult.ok) {
    return err(
      withContext(verifyTlsResult.error, {
        ...verifyTlsResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        verifyTls: props.verifyTls,
      }),
    );
  }

  const signingSecretResult = AuthSigningSecret.from(props.signingSecret);
  if (!signingSecretResult.ok) {
    return err(
      withContext(signingSecretResult.error, {
        ...signingSecretResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        signingSecret: props.signingSecret,
      }),
    );
  }

  const signatureAlgorithmResult = createAuthSignatureAlgorithm(
    props.signatureAlgorithm,
  );
  if (!signatureAlgorithmResult.ok) {
    return err(
      withContext(signatureAlgorithmResult.error, {
        ...signatureAlgorithmResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        signatureAlgorithm: props.signatureAlgorithm,
      }),
    );
  }

  const usernameResult = AuthUsername.from(props.username);
  if (!usernameResult.ok) {
    return err(
      withContext(usernameResult.error, {
        ...usernameResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        username: props.username,
      }),
    );
  }

  const passwordResult = AuthPassword.from(props.password);
  if (!passwordResult.ok) {
    return err(
      withContext(passwordResult.error, {
        ...passwordResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        password: props.password,
      }),
    );
  }

  const apiKeyResult = AuthApiKey.from(props.apiKey);
  if (!apiKeyResult.ok) {
    return err(
      withContext(apiKeyResult.error, {
        ...apiKeyResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        apiKey: props.apiKey,
      }),
    );
  }

  const apiKeyHeaderResult = AuthApiKeyHeader.from(props.apiKeyHeader);
  if (!apiKeyHeaderResult.ok) {
    return err(
      withContext(apiKeyHeaderResult.error, {
        ...apiKeyHeaderResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        apiKeyHeader: props.apiKeyHeader,
      }),
    );
  }

  const apiKeyQueryParamResult = AuthApiKeyQueryParam.from(
    props.apiKeyQueryParam,
  );
  if (!apiKeyQueryParamResult.ok) {
    return err(
      withContext(apiKeyQueryParamResult.error, {
        ...apiKeyQueryParamResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        apiKeyQueryParam: props.apiKeyQueryParam,
      }),
    );
  }

  const tokenUrlResult = AuthTokenUrl.from(props.tokenUrl);
  if (!tokenUrlResult.ok) {
    return err(
      withContext(tokenUrlResult.error, {
        ...tokenUrlResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        tokenUrl: props.tokenUrl,
      }),
    );
  }

  const clientIdResult = AuthClientId.from(props.clientId);
  if (!clientIdResult.ok) {
    return err(
      withContext(clientIdResult.error, {
        ...clientIdResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        clientId: props.clientId,
      }),
    );
  }

  const clientSecretResult = AuthClientSecret.from(props.clientSecret);
  if (!clientSecretResult.ok) {
    return err(
      withContext(clientSecretResult.error, {
        ...clientSecretResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        clientSecret: props.clientSecret,
      }),
    );
  }

  const scopeResult = AuthScope.from(props.scope);
  if (!scopeResult.ok) {
    return err(
      withContext(scopeResult.error, {
        ...scopeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        scope: props.scope,
      }),
    );
  }

  const certResult = AuthCert.from(props.cert);
  if (!certResult.ok) {
    return err(
      withContext(certResult.error, {
        ...certResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        cert: props.cert,
      }),
    );
  }

  const keyResult = AuthKey.from(props.key);
  if (!keyResult.ok) {
    return err(
      withContext(keyResult.error, {
        ...keyResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        key: props.key,
      }),
    );
  }

  const caResult = AuthCa.from(props.ca);
  if (!caResult.ok) {
    return err(
      withContext(caResult.error, {
        ...caResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_auth',
        ca: props.ca,
      }),
    );
  }

  const createdAtResult = AuthCreatedAt.create(clock.now());
  if (!createdAtResult.ok) {
    return err(createdAtResult.error);
  }

  const updatedAtResult = AuthUpdatedAt.create(clock.now());
  if (!updatedAtResult.ok) {
    return err(updatedAtResult.error);
  }

  const versionResult = AuthVersion.create(1); // Initial version is 1
  if (!versionResult.ok) {
    return err(versionResult.error);
  }

  // Create the entity properties with validated value objects
  const entityProps: AuthDomainState = {
    webhookId: webhookIdResult.value,
    type: typeResult.value,
    verifyTls: verifyTlsResult.value,
    signingSecret: signingSecretResult.value,
    signatureAlgorithm: signatureAlgorithmResult.value,
    username: usernameResult.value,
    password: passwordResult.value,
    apiKey: apiKeyResult.value,
    apiKeyHeader: apiKeyHeaderResult.value,
    apiKeyQueryParam: apiKeyQueryParamResult.value,
    tokenUrl: tokenUrlResult.value,
    clientId: clientIdResult.value,
    clientSecret: clientSecretResult.value,
    scope: scopeResult.value,
    cert: certResult.value,
    key: keyResult.value,
    ca: caResult.value,
    createdAt: createdAtResult.value,
    updatedAt: updatedAtResult.value,
    version: versionResult.value,
  };

  // Create the entity using the constructor
  return AuthAggregate.create(entityProps, clock, metadata);
}
