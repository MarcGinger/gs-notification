// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, ok, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { AuthAggregate } from '../aggregates';
import { AuthEntity } from '../entities';
import { AuthSnapshotProps, UpdateAuthProps } from '../props';
import { ValidatedAuthUpdateFields } from '../types';
import {
  createAuthType,
  AuthVerifyTls,
  AuthSigningSecret,
  createAuthSignatureAlgorithm,
  AuthUsername,
  AuthPassword,
  AuthApiKey,
  AuthApiKeyHeader,
  AuthApiKeyQueryParam,
  AuthTokenUrl,
  AuthClientId,
  AuthClientSecret,
  AuthScope,
  AuthCert,
  AuthKey,
  AuthCa,
} from '../value-objects';

/**
 * Update Auth Aggregate Factory
 *
 * Handles the complete update flow for Auth aggregates:
 * 1. Loads existing aggregate from snapshot
 * 2. Validates update properties and creates value objects
 * 3. Applies updates with proper business rule enforcement
 * 4. Returns updated aggregate ready for persistence
 *
 * This factory provides:
 * - Consistent update pattern matching create operations
 * - Centralized validation and business logic
 * - Efficient batch updates vs field-by-field
 * - Proper error context and logging integration
 */
export function updateAuthAggregateFromSnapshot(
  existingSnapshot: AuthSnapshotProps,
  updateProps: UpdateAuthProps,
  metadata: EventMetadata,
  clock: Clock,
): Result<AuthAggregate, DomainError> {
  // 1. Reconstitute existing aggregate
  const entityResult = AuthEntity.fromSnapshot(existingSnapshot);
  if (!entityResult.ok) {
    return err(
      withContext(entityResult.error, {
        operation: 'update_auth_reconstitute',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
      }),
    );
  }

  const existingAggregate = AuthAggregate.reconstitute(
    entityResult.value,
    clock,
    metadata,
  );

  // 2. Validate and apply updates for each provided field
  const validatedFields: ValidatedAuthUpdateFields = {};

  // Validate type if provided
  if (updateProps.type !== undefined) {
    const typeResult = createAuthType(updateProps.type);
    if (!typeResult.ok) {
      return err(
        withContext(typeResult.error, {
          operation: 'update_auth_type_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedType: updateProps.type,
        }),
      );
    }
    validatedFields.type = typeResult.value;
  }

  // Validate verifyTls if provided
  if (updateProps.verifyTls !== undefined) {
    const verifyTlsResult = AuthVerifyTls.from(updateProps.verifyTls);
    if (!verifyTlsResult.ok) {
      return err(
        withContext(verifyTlsResult.error, {
          operation: 'update_auth_verify_tls_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedVerifyTls: updateProps.verifyTls,
        }),
      );
    }
    validatedFields.verifyTls = verifyTlsResult.value;
  }

  // Validate signingSecret if provided
  if (updateProps.signingSecret !== undefined) {
    const signingSecretResult = AuthSigningSecret.from(
      updateProps.signingSecret,
    );
    if (!signingSecretResult.ok) {
      return err(
        withContext(signingSecretResult.error, {
          operation: 'update_auth_signing_secret_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedSigningSecret: updateProps.signingSecret,
        }),
      );
    }
    validatedFields.signingSecret = signingSecretResult.value;
  }

  // Validate signatureAlgorithm if provided
  if (updateProps.signatureAlgorithm !== undefined) {
    const signatureAlgorithmResult = createAuthSignatureAlgorithm(
      updateProps.signatureAlgorithm,
    );
    if (!signatureAlgorithmResult.ok) {
      return err(
        withContext(signatureAlgorithmResult.error, {
          operation: 'update_auth_signature_algorithm_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedSignatureAlgorithm: updateProps.signatureAlgorithm,
        }),
      );
    }
    validatedFields.signatureAlgorithm = signatureAlgorithmResult.value;
  }

  // Validate username if provided
  if (updateProps.username !== undefined) {
    const usernameResult = AuthUsername.from(updateProps.username);
    if (!usernameResult.ok) {
      return err(
        withContext(usernameResult.error, {
          operation: 'update_auth_username_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedUsername: updateProps.username,
        }),
      );
    }
    validatedFields.username = usernameResult.value;
  }

  // Validate password if provided
  if (updateProps.password !== undefined) {
    const passwordResult = AuthPassword.from(updateProps.password);
    if (!passwordResult.ok) {
      return err(
        withContext(passwordResult.error, {
          operation: 'update_auth_password_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedPassword: updateProps.password,
        }),
      );
    }
    validatedFields.password = passwordResult.value;
  }

  // Validate apiKey if provided
  if (updateProps.apiKey !== undefined) {
    const apiKeyResult = AuthApiKey.from(updateProps.apiKey);
    if (!apiKeyResult.ok) {
      return err(
        withContext(apiKeyResult.error, {
          operation: 'update_auth_api_key_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedApiKey: updateProps.apiKey,
        }),
      );
    }
    validatedFields.apiKey = apiKeyResult.value;
  }

  // Validate apiKeyHeader if provided
  if (updateProps.apiKeyHeader !== undefined) {
    const apiKeyHeaderResult = AuthApiKeyHeader.from(updateProps.apiKeyHeader);
    if (!apiKeyHeaderResult.ok) {
      return err(
        withContext(apiKeyHeaderResult.error, {
          operation: 'update_auth_api_key_header_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedApiKeyHeader: updateProps.apiKeyHeader,
        }),
      );
    }
    validatedFields.apiKeyHeader = apiKeyHeaderResult.value;
  }

  // Validate apiKeyQueryParam if provided
  if (updateProps.apiKeyQueryParam !== undefined) {
    const apiKeyQueryParamResult = AuthApiKeyQueryParam.from(
      updateProps.apiKeyQueryParam,
    );
    if (!apiKeyQueryParamResult.ok) {
      return err(
        withContext(apiKeyQueryParamResult.error, {
          operation: 'update_auth_api_key_query_param_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedApiKeyQueryParam: updateProps.apiKeyQueryParam,
        }),
      );
    }
    validatedFields.apiKeyQueryParam = apiKeyQueryParamResult.value;
  }

  // Validate tokenUrl if provided
  if (updateProps.tokenUrl !== undefined) {
    const tokenUrlResult = AuthTokenUrl.from(updateProps.tokenUrl);
    if (!tokenUrlResult.ok) {
      return err(
        withContext(tokenUrlResult.error, {
          operation: 'update_auth_token_url_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedTokenUrl: updateProps.tokenUrl,
        }),
      );
    }
    validatedFields.tokenUrl = tokenUrlResult.value;
  }

  // Validate clientId if provided
  if (updateProps.clientId !== undefined) {
    const clientIdResult = AuthClientId.from(updateProps.clientId);
    if (!clientIdResult.ok) {
      return err(
        withContext(clientIdResult.error, {
          operation: 'update_auth_client_id_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedClientId: updateProps.clientId,
        }),
      );
    }
    validatedFields.clientId = clientIdResult.value;
  }

  // Validate clientSecret if provided
  if (updateProps.clientSecret !== undefined) {
    const clientSecretResult = AuthClientSecret.from(updateProps.clientSecret);
    if (!clientSecretResult.ok) {
      return err(
        withContext(clientSecretResult.error, {
          operation: 'update_auth_client_secret_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedClientSecret: updateProps.clientSecret,
        }),
      );
    }
    validatedFields.clientSecret = clientSecretResult.value;
  }

  // Validate scope if provided
  if (updateProps.scope !== undefined) {
    const scopeResult = AuthScope.from(updateProps.scope);
    if (!scopeResult.ok) {
      return err(
        withContext(scopeResult.error, {
          operation: 'update_auth_scope_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedScope: updateProps.scope,
        }),
      );
    }
    validatedFields.scope = scopeResult.value;
  }

  // Validate cert if provided
  if (updateProps.cert !== undefined) {
    const certResult = AuthCert.from(updateProps.cert);
    if (!certResult.ok) {
      return err(
        withContext(certResult.error, {
          operation: 'update_auth_cert_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedCert: updateProps.cert,
        }),
      );
    }
    validatedFields.cert = certResult.value;
  }

  // Validate key if provided
  if (updateProps.key !== undefined) {
    const keyResult = AuthKey.from(updateProps.key);
    if (!keyResult.ok) {
      return err(
        withContext(keyResult.error, {
          operation: 'update_auth_key_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedKey: updateProps.key,
        }),
      );
    }
    validatedFields.key = keyResult.value;
  }

  // Validate ca if provided
  if (updateProps.ca !== undefined) {
    const caResult = AuthCa.from(updateProps.ca);
    if (!caResult.ok) {
      return err(
        withContext(caResult.error, {
          operation: 'update_auth_ca_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedCa: updateProps.ca,
        }),
      );
    }
    validatedFields.ca = caResult.value;
  }

  // 3. Apply all validated changes in single atomic operation
  const batchUpdateResult = existingAggregate.updateBatch(validatedFields);
  if (!batchUpdateResult.ok) {
    return err(
      withContext(batchUpdateResult.error, {
        operation: 'update_product_batch_application',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        fieldsUpdated: Object.keys(validatedFields),
      }),
    );
  }

  return ok(existingAggregate);
}
