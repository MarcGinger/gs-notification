// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Inject } from '@nestjs/common';
import { Result, DomainError, ok, err, withContext } from 'src/shared/errors';
import { ActorContext } from 'src/shared/application/context';

// Shared utilities and infrastructure
import { APP_LOGGER, componentLogger, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import { Option } from 'src/shared/domain/types';
import { runUseCaseWithSecurity } from 'src/shared/application/utils';
import { IUserToken } from 'src/shared/security';
import {
  UseCaseLoggingUtil,
  UseCaseLoggingConfig,
} from 'src/shared/application/utils/use-case-logging.util';

// Service configuration
import { WebhookConfigServiceConstants } from '../../../service-constants';

// Domain types and errors
import { AuthtypeAggregate } from '../../domain/aggregates';
import { AuthtypeId } from '../../domain/value-objects';
import { deleteAuthtypeAggregateFromSnapshot } from '../../domain/factories';
import { AuthtypeErrors } from '../../domain/errors';
import { IDeleteAuthtypeUseCase } from './contracts';

// Application layer
import { DeleteAuthtypeCommand } from '../commands';
import {
  IAuthtypeReader,
  IAuthtypeWriter,
  AUTHTYPE_READER_TOKEN,
  AUTHTYPE_WRITER_TOKEN,
} from '../ports';
import {
  AuthtypeForeignKeyValidatorService,
  AuthtypeAuthorizationAdapter,
} from '../services';

// Shared compliance services
import {
  PIIClassificationService,
  PIIProtectionService,
  DataRetentionService,
} from 'src/shared/services/compliance';

type AuthtypeSnapshot = Parameters<
  typeof deleteAuthtypeAggregateFromSnapshot
>[0];

/**
 * Delete Authtype Use Case
 *
 * Handles the secure deletion of existing authtypes with comprehensive
 * compliance, authorization, and audit capabilities.
 *
 * Features:
 * - PII classification and data retention compliance
 * - Field-level authorization and audit trails
 * - Structured logging with correlation tracking
 * - Enhanced security validation
 * - Domain-driven design patterns
 *
 * @domain Notification Context - Authtype Use Cases
 * @layer Application Use Cases
 */
@Injectable()
export class DeleteAuthtypeUseCase implements IDeleteAuthtypeUseCase {
  private readonly logger: Logger;
  private readonly loggingConfig: UseCaseLoggingConfig;

  constructor(
    @Inject(AUTHTYPE_READER_TOKEN)
    private readonly authtypeReader: IAuthtypeReader,
    @Inject(AUTHTYPE_WRITER_TOKEN)
    private readonly authtypeWriter: IAuthtypeWriter,
    private readonly foreignKeyValidator: AuthtypeForeignKeyValidatorService,
    private readonly authorizationService: AuthtypeAuthorizationAdapter,
    @Inject(CLOCK) private readonly clock: Clock,
    @Inject(APP_LOGGER) moduleLogger: Logger,
    private readonly piiClassificationService: PIIClassificationService,
    private readonly piiProtectionService: PIIProtectionService,
    private readonly dataRetentionService: DataRetentionService,
  ) {
    this.loggingConfig = {
      serviceName: WebhookConfigServiceConstants.SERVICE_NAME,
      component: 'DeleteAuthtypeUseCase',
      domain: 'webhook-config',
      entityType: 'authtype',
    };
    this.logger = componentLogger(moduleLogger, this.loggingConfig.component);
  }

  /**
   * Execute the delete authtype use case with enhanced security and compliance
   * @param command - The delete command containing authtype identifier and context
   * @returns Result indicating success or domain error
   */
  async execute(params: {
    user: IUserToken;
    id: number;
    correlationId: string;
    authorizationReason: string;
  }): Promise<Result<void, DomainError>> {
    const operation = 'delete_authtype';
    const startTime = this.clock.nowMs();

    // Create a command-like object for internal use
    const command = {
      user: params.user,
      id: params.id,
      correlationId: params.correlationId,
      authorizationReason: params.authorizationReason,
      securityContext: {
        tenant: params.user.tenant,
        userId: params.user.sub,
        roles: params.user.roles,
      },
      timestamp: this.clock.now(),
    };

    // Step 1: Extract raw properties for domain logic (no PII protection at domain level)
    const rawProps = {
      // We'll classify based on the id since we need it for loading
      id: command.id,
    };

    // Step 2: Create safe logging context (no PII, deferred retention metadata)
    const safeLogContext = UseCaseLoggingUtil.createLogContext(
      this.loggingConfig,
      this.clock,
      operation,
      command,
      {
        authtypeId: rawProps.id,
        operationRisk: 'HIGH', // Deletion is always high risk
        dataImpact: 'PERMANENT',
      },
    );

    // Step 3: Validate command with enhanced logging
    const validation = UseCaseLoggingUtil.validateCommand(
      this.logger,
      command,
      safeLogContext,
    );
    if (!validation.ok) {
      return err(validation.error);
    }

    try {
      // Step 4: PII classification for compliance analysis (raw data for domain logic)

      const classification = this.piiClassificationService.classifyData(
        rawProps,
        {
          domain: 'webhook-config',
          tenant: command.user.tenant,
          // entityType: 'Authtype' // Future: for entity-level rules
        },
      );

      // Log compliance check with detailed audit trail
      UseCaseLoggingUtil.logComplianceCheck(
        this.logger,
        operation,
        safeLogContext,
        classification,
      );

      // Step 2: Execute deletion with domain factory using runUseCaseWithSecurity
      const aggregateResult = await runUseCaseWithSecurity<
        DeleteAuthtypeCommand,
        AuthtypeAggregate,
        AuthtypeSnapshot
      >({
        serviceName: WebhookConfigServiceConstants.SERVICE_NAME,
        component: 'DeleteAuthtypeUseCase',
        operation: 'delete_authtype',
        source: 'webhook-config.application.delete-authtype',
        command,
        logger: this.logger,
        clock: this.clock,
        repo: {
          save: async (
            actor: ActorContext,
            authtype: AuthtypeAggregate,
            expectedVersion?: number,
          ) => {
            // For deletion, save the aggregate with deletion events first
            const saveResult = await this.authtypeWriter.save(
              actor,
              authtype,
              expectedVersion,
            );
            if (!saveResult.ok) return saveResult;

            // Then execute the physical deletion
            const codeResult = AuthtypeId.create(rawProps.id);
            if (!codeResult.ok) return err(codeResult.error);

            const deleteResult = await this.authtypeWriter.delete(
              actor,
              codeResult.value,
            );
            return deleteResult.ok ? ok(undefined) : deleteResult;
          },
        },
        fkValidator: this.foreignKeyValidator,
        propsMissingError: AuthtypeErrors.INVALID_AUTHTYPE_DATA,

        // Security configuration
        authorizationService: this.authorizationService,
        authorization: {
          type: 'delete',
          operation: 'delete',
          resourceId: String(rawProps.id),
        },
        authContext: {
          userId: command.user.sub,
          tenant: command.user.tenant,
          roles: command.user.roles,
          operationType: 'delete',
        },

        // Load existing snapshot or return AUTHTYPE_NOT_FOUND with context
        loadExisting: async (actor, cmd) => {
          const codeR = AuthtypeId.create(rawProps.id);
          if (!codeR.ok) return err(codeR.error);

          const foundR = await this.authtypeReader.findById(actor, codeR.value);
          if (!foundR.ok) {
            return err(
              withContext(AuthtypeErrors.AUTHTYPE_NOT_FOUND, {
                correlationId: cmd.correlationId,
                userId: cmd.user.sub,
                operation: 'delete_authtype',
                id: cmd.id,
              }),
            );
          }

          if (Option.isNone(foundR.value)) {
            return err(
              withContext(AuthtypeErrors.AUTHTYPE_NOT_FOUND, {
                correlationId: cmd.correlationId,
                userId: cmd.user.sub,
                operation: 'delete_authtype',
                id: cmd.id,
              }),
            );
          }

          return ok(foundR.value.value); // snapshot
        },

        // Execute domain deletion logic via factory
        runDomain: ({ existing, metadata, clock }) => {
          // Enhance metadata with PII classification results
          const enhancedMetadata = {
            ...metadata,
            piiProtected: classification.containsPII,
            dataClassification: classification.containsPII
              ? ('confidential' as const)
              : ('internal' as const),
            securelyDeleted: true,
          };

          return deleteAuthtypeAggregateFromSnapshot(
            existing!,
            enhancedMetadata,
            clock,
          );
        },
      });

      if (!aggregateResult.ok) {
        UseCaseLoggingUtil.logOperationError(
          this.logger,
          operation,
          safeLogContext,
          aggregateResult.error,
          'HIGH',
        );
        return aggregateResult;
      }

      const aggregate = aggregateResult.value;

      // Step 3: Generate compliance audit trail for PII data if needed
      if (classification.containsPII) {
        const retentionMetadata =
          await this.dataRetentionService.generateRetentionMetadata(
            classification,
            {
              tenant: command.user.tenant,
              userId: command.user.sub,
              entityType: 'authtype',
              entityId: rawProps.id.toString(),
              domain: 'webhook-config',
            },
          );

        // Generate deletion audit trail using protection audit
        this.piiProtectionService.generateProtectionAudit([], {
          userId: command.user.sub,
          tenant: command.user.tenant,
          operation: 'delete_authtype',
          domain: 'webhook-config',
          entityType: 'authtype',
        });

        // Log comprehensive compliance deletion details
        UseCaseLoggingUtil.logComplianceProtection(
          this.logger,
          operation,
          safeLogContext,
          {
            fieldsProtected: 0, // No fields protected in deletion
            strategiesUsed: ['SECURE_DELETION'],
            auditGenerated: true,
            retentionApplied: true,
            retentionExpiry: new Date(retentionMetadata.retentionExpiry),
            legalBasis: retentionMetadata.legalBasis,
            automaticDeletion: retentionMetadata.automaticDeletion,
            auditRecord: retentionMetadata.auditRecord.tenant,
          },
        );
      }

      // Step 4: Log successful deletion with comprehensive metrics
      const executionTime = this.clock.nowMs() - startTime;
      UseCaseLoggingUtil.logOperationSuccess(
        this.logger,
        operation,
        safeLogContext,
        {
          executionTimeMs: executionTime,
          aggregateVersion: aggregate.version,
          eventCount: aggregate.uncommittedEvents?.length ?? 0,
          businessData: {
            AuthtypeId: rawProps.id,
            complianceApplied: classification.containsPII,
            securelyDeleted: true,
            domainEventsGenerated: true,
          },
        },
      );

      return ok(undefined);
    } catch (error) {
      const executionTime = this.clock.nowMs() - startTime;
      const domainError = withContext(
        AuthtypeErrors.CANNOT_DELETE_AUTHTYPE_WITH_DEPENDENCIES,
        {
          correlationId: command.correlationId,
          userId: command.user.sub,
          operation: 'delete_authtype',
          id: rawProps.id,
          error: error instanceof Error ? error.message : String(error),
          executionTimeMs: executionTime,
        },
      );

      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        domainError,
        'CRITICAL',
      );

      return err(domainError);
    }
  }
}
