// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, ok, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { AuthtypeAggregate } from '../aggregates';
import { AuthtypeEntity } from '../entities';
import { AuthtypeSnapshotProps, UpdateAuthtypeProps } from '../props';
import { ValidatedAuthtypeUpdateFields } from '../types';
import {
  AuthtypeWebhookId,
  createAuthtypeType,
  AuthtypeSigningSecretRef,
  createAuthtypeSignatureAlgorithm,
  AuthtypeUsernameRef,
  AuthtypePasswordRef,
  AuthtypeApiKeyRef,
  AuthtypeApiKeyHeader,
  AuthtypeApiKeyQueryParam,
  AuthtypeTokenUrl,
  AuthtypeClientIdRef,
  AuthtypeClientSecretRef,
  AuthtypeScope,
  AuthtypeCertRef,
  AuthtypeKeyRef,
  AuthtypeCaRef,
} from '../value-objects';

/**
 * Update Authtype Aggregate Factory
 *
 * Handles the complete update flow for Authtype aggregates:
 * 1. Loads existing aggregate from snapshot
 * 2. Validates update properties and creates value objects
 * 3. Applies updates with proper business rule enforcement
 * 4. Returns updated aggregate ready for persistence
 *
 * This factory provides:
 * - Consistent update pattern matching create operations
 * - Centralized validation and business logic
 * - Efficient batch updates vs field-by-field
 * - Proper error context and logging integration
 */
export function updateAuthtypeAggregateFromSnapshot(
  existingSnapshot: AuthtypeSnapshotProps,
  updateProps: UpdateAuthtypeProps,
  metadata: EventMetadata,
  clock: Clock,
): Result<AuthtypeAggregate, DomainError> {
  // 1. Reconstitute existing aggregate
  const entityResult = AuthtypeEntity.fromSnapshot(existingSnapshot);
  if (!entityResult.ok) {
    return err(
      withContext(entityResult.error, {
        operation: 'update_authtype_reconstitute',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
      }),
    );
  }

  const existingAggregate = AuthtypeAggregate.reconstitute(
    entityResult.value,
    clock,
    metadata,
  );

  // 2. Validate and apply updates for each provided field
  const validatedFields: ValidatedAuthtypeUpdateFields = {};

  // Validate webhookId if provided
  if (updateProps.webhookId !== undefined) {
    const webhookIdResult = AuthtypeWebhookId.from(updateProps.webhookId);
    if (!webhookIdResult.ok) {
      return err(
        withContext(webhookIdResult.error, {
          operation: 'update_authtype_webhook_id_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedWebhookId: updateProps.webhookId,
        }),
      );
    }
    validatedFields.webhookId = webhookIdResult.value;
  }

  // Validate type if provided
  if (updateProps.type !== undefined) {
    const typeResult = createAuthtypeType(updateProps.type);
    if (!typeResult.ok) {
      return err(
        withContext(typeResult.error, {
          operation: 'update_authtype_type_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedType: updateProps.type,
        }),
      );
    }
    validatedFields.type = typeResult.value;
  }

  // Validate signingSecretRef if provided
  if (updateProps.signingSecretRef !== undefined) {
    const signingSecretRefResult = AuthtypeSigningSecretRef.from(
      updateProps.signingSecretRef,
    );
    if (!signingSecretRefResult.ok) {
      return err(
        withContext(signingSecretRefResult.error, {
          operation: 'update_authtype_signing_secret_ref_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedSigningSecretRef: updateProps.signingSecretRef,
        }),
      );
    }
    validatedFields.signingSecretRef = signingSecretRefResult.value;
  }

  // Validate signatureAlgorithm if provided
  if (updateProps.signatureAlgorithm !== undefined) {
    const signatureAlgorithmResult = createAuthtypeSignatureAlgorithm(
      updateProps.signatureAlgorithm,
    );
    if (!signatureAlgorithmResult.ok) {
      return err(
        withContext(signatureAlgorithmResult.error, {
          operation: 'update_authtype_signature_algorithm_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedSignatureAlgorithm: updateProps.signatureAlgorithm,
        }),
      );
    }
    validatedFields.signatureAlgorithm = signatureAlgorithmResult.value;
  }

  // Validate usernameRef if provided
  if (updateProps.usernameRef !== undefined) {
    const usernameRefResult = AuthtypeUsernameRef.from(updateProps.usernameRef);
    if (!usernameRefResult.ok) {
      return err(
        withContext(usernameRefResult.error, {
          operation: 'update_authtype_username_ref_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedUsernameRef: updateProps.usernameRef,
        }),
      );
    }
    validatedFields.usernameRef = usernameRefResult.value;
  }

  // Validate passwordRef if provided
  if (updateProps.passwordRef !== undefined) {
    const passwordRefResult = AuthtypePasswordRef.from(updateProps.passwordRef);
    if (!passwordRefResult.ok) {
      return err(
        withContext(passwordRefResult.error, {
          operation: 'update_authtype_password_ref_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedPasswordRef: updateProps.passwordRef,
        }),
      );
    }
    validatedFields.passwordRef = passwordRefResult.value;
  }

  // Validate apiKeyRef if provided
  if (updateProps.apiKeyRef !== undefined) {
    const apiKeyRefResult = AuthtypeApiKeyRef.from(updateProps.apiKeyRef);
    if (!apiKeyRefResult.ok) {
      return err(
        withContext(apiKeyRefResult.error, {
          operation: 'update_authtype_api_key_ref_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedApiKeyRef: updateProps.apiKeyRef,
        }),
      );
    }
    validatedFields.apiKeyRef = apiKeyRefResult.value;
  }

  // Validate apiKeyHeader if provided
  if (updateProps.apiKeyHeader !== undefined) {
    const apiKeyHeaderResult = AuthtypeApiKeyHeader.from(
      updateProps.apiKeyHeader,
    );
    if (!apiKeyHeaderResult.ok) {
      return err(
        withContext(apiKeyHeaderResult.error, {
          operation: 'update_authtype_api_key_header_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedApiKeyHeader: updateProps.apiKeyHeader,
        }),
      );
    }
    validatedFields.apiKeyHeader = apiKeyHeaderResult.value;
  }

  // Validate apiKeyQueryParam if provided
  if (updateProps.apiKeyQueryParam !== undefined) {
    const apiKeyQueryParamResult = AuthtypeApiKeyQueryParam.from(
      updateProps.apiKeyQueryParam,
    );
    if (!apiKeyQueryParamResult.ok) {
      return err(
        withContext(apiKeyQueryParamResult.error, {
          operation: 'update_authtype_api_key_query_param_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedApiKeyQueryParam: updateProps.apiKeyQueryParam,
        }),
      );
    }
    validatedFields.apiKeyQueryParam = apiKeyQueryParamResult.value;
  }

  // Validate tokenUrl if provided
  if (updateProps.tokenUrl !== undefined) {
    const tokenUrlResult = AuthtypeTokenUrl.from(updateProps.tokenUrl);
    if (!tokenUrlResult.ok) {
      return err(
        withContext(tokenUrlResult.error, {
          operation: 'update_authtype_token_url_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedTokenUrl: updateProps.tokenUrl,
        }),
      );
    }
    validatedFields.tokenUrl = tokenUrlResult.value;
  }

  // Validate clientIdRef if provided
  if (updateProps.clientIdRef !== undefined) {
    const clientIdRefResult = AuthtypeClientIdRef.from(updateProps.clientIdRef);
    if (!clientIdRefResult.ok) {
      return err(
        withContext(clientIdRefResult.error, {
          operation: 'update_authtype_client_id_ref_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedClientIdRef: updateProps.clientIdRef,
        }),
      );
    }
    validatedFields.clientIdRef = clientIdRefResult.value;
  }

  // Validate clientSecretRef if provided
  if (updateProps.clientSecretRef !== undefined) {
    const clientSecretRefResult = AuthtypeClientSecretRef.from(
      updateProps.clientSecretRef,
    );
    if (!clientSecretRefResult.ok) {
      return err(
        withContext(clientSecretRefResult.error, {
          operation: 'update_authtype_client_secret_ref_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedClientSecretRef: updateProps.clientSecretRef,
        }),
      );
    }
    validatedFields.clientSecretRef = clientSecretRefResult.value;
  }

  // Validate scope if provided
  if (updateProps.scope !== undefined) {
    const scopeResult = AuthtypeScope.from(updateProps.scope);
    if (!scopeResult.ok) {
      return err(
        withContext(scopeResult.error, {
          operation: 'update_authtype_scope_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedScope: updateProps.scope,
        }),
      );
    }
    validatedFields.scope = scopeResult.value;
  }

  // Validate certRef if provided
  if (updateProps.certRef !== undefined) {
    const certRefResult = AuthtypeCertRef.from(updateProps.certRef);
    if (!certRefResult.ok) {
      return err(
        withContext(certRefResult.error, {
          operation: 'update_authtype_cert_ref_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedCertRef: updateProps.certRef,
        }),
      );
    }
    validatedFields.certRef = certRefResult.value;
  }

  // Validate keyRef if provided
  if (updateProps.keyRef !== undefined) {
    const keyRefResult = AuthtypeKeyRef.from(updateProps.keyRef);
    if (!keyRefResult.ok) {
      return err(
        withContext(keyRefResult.error, {
          operation: 'update_authtype_key_ref_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedKeyRef: updateProps.keyRef,
        }),
      );
    }
    validatedFields.keyRef = keyRefResult.value;
  }

  // Validate caRef if provided
  if (updateProps.caRef !== undefined) {
    const caRefResult = AuthtypeCaRef.from(updateProps.caRef);
    if (!caRefResult.ok) {
      return err(
        withContext(caRefResult.error, {
          operation: 'update_authtype_ca_ref_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedCaRef: updateProps.caRef,
        }),
      );
    }
    validatedFields.caRef = caRefResult.value;
  }

  // 3. Apply all validated changes in single atomic operation
  const batchUpdateResult = existingAggregate.updateBatch(validatedFields);
  if (!batchUpdateResult.ok) {
    return err(
      withContext(batchUpdateResult.error, {
        operation: 'update_product_batch_application',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        fieldsUpdated: Object.keys(validatedFields),
      }),
    );
  }

  return ok(existingAggregate);
}
