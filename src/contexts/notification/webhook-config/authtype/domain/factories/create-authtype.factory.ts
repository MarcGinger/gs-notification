// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { AuthtypeAggregate } from '../aggregates';
import { CreateAuthtypeProps } from '../props';
import { AuthtypeDomainState } from '../state';
import {
  AuthtypeCreatedAt,
  AuthtypeUpdatedAt,
  AuthtypeVersion,
  AuthtypeId,
  AuthtypeWebhookId,
  createAuthtypeType,
  AuthtypeSigningSecretRef,
  createAuthtypeSignatureAlgorithm,
  AuthtypeUsernameRef,
  AuthtypePasswordRef,
  AuthtypeApiKeyRef,
  AuthtypeApiKeyHeader,
  AuthtypeApiKeyQueryParam,
  AuthtypeTokenUrl,
  AuthtypeClientIdRef,
  AuthtypeClientSecretRef,
  AuthtypeScope,
  AuthtypeCertRef,
  AuthtypeKeyRef,
  AuthtypeCaRef,
} from '../value-objects';

/**
 * Enhanced authtype entity factory with comprehensive validation and security context
 * Moved from application layer to properly separate business concerns
 */
export function createAuthtypeAggregateFromProps(
  props: CreateAuthtypeProps,
  metadata: EventMetadata,
  clock: Clock,
  // validatedEntities?: {
  //  channels?: ChannelReference[];
  // },
): Result<AuthtypeAggregate, DomainError> {
  // Validate each property by creating value objects
  const idResult = AuthtypeId.from(props.id);
  if (!idResult.ok) {
    return err(
      withContext(idResult.error, {
        ...idResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        id: props.id,
      }),
    );
  }

  const webhookIdResult = AuthtypeWebhookId.from(props.webhookId);
  if (!webhookIdResult.ok) {
    return err(
      withContext(webhookIdResult.error, {
        ...webhookIdResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        webhookId: props.webhookId,
      }),
    );
  }

  const typeResult = createAuthtypeType(props.type);
  if (!typeResult.ok) {
    return err(
      withContext(typeResult.error, {
        ...typeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        type: props.type,
      }),
    );
  }

  const signingSecretRefResult = AuthtypeSigningSecretRef.from(
    props.signingSecretRef,
  );
  if (!signingSecretRefResult.ok) {
    return err(
      withContext(signingSecretRefResult.error, {
        ...signingSecretRefResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        signingSecretRef: props.signingSecretRef,
      }),
    );
  }

  const signatureAlgorithmResult = createAuthtypeSignatureAlgorithm(
    props.signatureAlgorithm,
  );
  if (!signatureAlgorithmResult.ok) {
    return err(
      withContext(signatureAlgorithmResult.error, {
        ...signatureAlgorithmResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        signatureAlgorithm: props.signatureAlgorithm,
      }),
    );
  }

  const usernameRefResult = AuthtypeUsernameRef.from(props.usernameRef);
  if (!usernameRefResult.ok) {
    return err(
      withContext(usernameRefResult.error, {
        ...usernameRefResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        usernameRef: props.usernameRef,
      }),
    );
  }

  const passwordRefResult = AuthtypePasswordRef.from(props.passwordRef);
  if (!passwordRefResult.ok) {
    return err(
      withContext(passwordRefResult.error, {
        ...passwordRefResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        passwordRef: props.passwordRef,
      }),
    );
  }

  const apiKeyRefResult = AuthtypeApiKeyRef.from(props.apiKeyRef);
  if (!apiKeyRefResult.ok) {
    return err(
      withContext(apiKeyRefResult.error, {
        ...apiKeyRefResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        apiKeyRef: props.apiKeyRef,
      }),
    );
  }

  const apiKeyHeaderResult = AuthtypeApiKeyHeader.from(props.apiKeyHeader);
  if (!apiKeyHeaderResult.ok) {
    return err(
      withContext(apiKeyHeaderResult.error, {
        ...apiKeyHeaderResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        apiKeyHeader: props.apiKeyHeader,
      }),
    );
  }

  const apiKeyQueryParamResult = AuthtypeApiKeyQueryParam.from(
    props.apiKeyQueryParam,
  );
  if (!apiKeyQueryParamResult.ok) {
    return err(
      withContext(apiKeyQueryParamResult.error, {
        ...apiKeyQueryParamResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        apiKeyQueryParam: props.apiKeyQueryParam,
      }),
    );
  }

  const tokenUrlResult = AuthtypeTokenUrl.from(props.tokenUrl);
  if (!tokenUrlResult.ok) {
    return err(
      withContext(tokenUrlResult.error, {
        ...tokenUrlResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        tokenUrl: props.tokenUrl,
      }),
    );
  }

  const clientIdRefResult = AuthtypeClientIdRef.from(props.clientIdRef);
  if (!clientIdRefResult.ok) {
    return err(
      withContext(clientIdRefResult.error, {
        ...clientIdRefResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        clientIdRef: props.clientIdRef,
      }),
    );
  }

  const clientSecretRefResult = AuthtypeClientSecretRef.from(
    props.clientSecretRef,
  );
  if (!clientSecretRefResult.ok) {
    return err(
      withContext(clientSecretRefResult.error, {
        ...clientSecretRefResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        clientSecretRef: props.clientSecretRef,
      }),
    );
  }

  const scopeResult = AuthtypeScope.from(props.scope);
  if (!scopeResult.ok) {
    return err(
      withContext(scopeResult.error, {
        ...scopeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        scope: props.scope,
      }),
    );
  }

  const certRefResult = AuthtypeCertRef.from(props.certRef);
  if (!certRefResult.ok) {
    return err(
      withContext(certRefResult.error, {
        ...certRefResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        certRef: props.certRef,
      }),
    );
  }

  const keyRefResult = AuthtypeKeyRef.from(props.keyRef);
  if (!keyRefResult.ok) {
    return err(
      withContext(keyRefResult.error, {
        ...keyRefResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        keyRef: props.keyRef,
      }),
    );
  }

  const caRefResult = AuthtypeCaRef.from(props.caRef);
  if (!caRefResult.ok) {
    return err(
      withContext(caRefResult.error, {
        ...caRefResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_authtype',
        caRef: props.caRef,
      }),
    );
  }

  const createdAtResult = AuthtypeCreatedAt.create(clock.now());
  if (!createdAtResult.ok) {
    return err(createdAtResult.error);
  }

  const updatedAtResult = AuthtypeUpdatedAt.create(clock.now());
  if (!updatedAtResult.ok) {
    return err(updatedAtResult.error);
  }

  const versionResult = AuthtypeVersion.create(1); // Initial version is 1
  if (!versionResult.ok) {
    return err(versionResult.error);
  }

  // Create the entity properties with validated value objects
  const entityProps: AuthtypeDomainState = {
    id: idResult.value,
    webhookId: webhookIdResult.value,
    type: typeResult.value,
    signingSecretRef: signingSecretRefResult.value,
    signatureAlgorithm: signatureAlgorithmResult.value,
    usernameRef: usernameRefResult.value,
    passwordRef: passwordRefResult.value,
    apiKeyRef: apiKeyRefResult.value,
    apiKeyHeader: apiKeyHeaderResult.value,
    apiKeyQueryParam: apiKeyQueryParamResult.value,
    tokenUrl: tokenUrlResult.value,
    clientIdRef: clientIdRefResult.value,
    clientSecretRef: clientSecretRefResult.value,
    scope: scopeResult.value,
    certRef: certRefResult.value,
    keyRef: keyRefResult.value,
    caRef: caRefResult.value,
    createdAt: createdAtResult.value,
    updatedAt: updatedAtResult.value,
    version: versionResult.value,
  };

  // Create the entity using the constructor
  return AuthtypeAggregate.create(entityProps, clock, metadata);
}
