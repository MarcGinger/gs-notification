// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { EntityIdBase } from 'src/shared/domain/entities';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { AuthtypeSnapshotProps } from '../props';
import { AuthtypeDomainState } from '../state';
import { AuthtypeErrors } from '../errors/authtype.errors';
import {
  AuthtypeApiKeyHeader,
  AuthtypeApiKeyQueryParam,
  AuthtypeApiKeyRef,
  AuthtypeCaRef,
  AuthtypeCertRef,
  AuthtypeClientIdRef,
  AuthtypeClientSecretRef,
  AuthtypeCreatedAt,
  AuthtypeUpdatedAt,
  AuthtypeVersion,
  AuthtypeId,
  AuthtypeKeyRef,
  AuthtypePasswordRef,
  AuthtypeScope,
  AuthtypeSignatureAlgorithm,
  AuthtypeSignatureAlgorithmLogic,
  AuthtypeSigningSecretRef,
  AuthtypeTokenUrl,
  AuthtypeType,
  AuthtypeTypeLogic,
  AuthtypeUsernameRef,
  AuthtypeWebhookId,
  createAuthtypeSignatureAlgorithm,
  createAuthtypeType,
} from '../value-objects';

/**
 * Domain Entity: Authtype
 *
 * Represents the core Authtype entity in the notification domain.
 * Encapsulates authtype data, identity, and basic entity behavior.
 *
 * This entity follows DDD principles:
 * - Identity: Id as unique identifier
 * - Immutability: Changes create new instances
 * - Encapsulation: Private state with controlled access
 * - Business validation: Domain rules enforced
 *
 * @domain Notification Context - Authtype Entity
 * @layer Domain Entities
 */

/**
 * Authtype Entity
 *
 * Core domain entity representing a authtype in the notification.
 * Handles authtype identity, validation, and state management.
 */
export class AuthtypeEntity extends EntityIdBase<
  AuthtypeDomainState,
  AuthtypeId
> {
  private static clock: { now: () => Date } = { now: () => new Date() };

  public static setClock(c: { now: () => Date }) {
    this.clock = c;
  }

  /**
   * Helper method to create updatedAt VO from date
   */
  private static createUpdatedAt(
    date?: Date,
  ): Result<AuthtypeUpdatedAt, DomainError> {
    const targetDate = date || AuthtypeEntity.clock.now();
    const result = AuthtypeUpdatedAt.from(targetDate);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create version VO from number
   */
  private static createVersion(
    versionNumber?: number,
    currentVersion?: AuthtypeVersion,
  ): Result<AuthtypeVersion, DomainError> {
    const targetVersion = versionNumber ?? currentVersion?.value ?? 1;
    const result = AuthtypeVersion.from(targetVersion);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create updated entity with common logic
   */
  private createUpdatedEntity(
    fieldUpdates: Partial<AuthtypeDomainState>,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    const updatedAtResult = AuthtypeEntity.createUpdatedAt(updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = AuthtypeEntity.createVersion(
      version,
      this.props.version,
    );
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const updatedProps: AuthtypeDomainState = {
      ...this.props,
      ...fieldUpdates,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return AuthtypeEntity.create(updatedProps);
  }

  private constructor(props: AuthtypeDomainState) {
    super(props, props.id);
  }

  /**
   * Factory method to create a new authtype entity
   *
   * @param props - Authtype properties
   * @returns Result containing AuthtypeEntity or DomainError
   */
  public static create(
    props: AuthtypeDomainState,
  ): Result<AuthtypeEntity, DomainError> {
    // Validate required properties
    const validationResult = AuthtypeEntity.validate(props);
    if (validationResult.ok === false) {
      return err(validationResult.error);
    }

    return ok(new AuthtypeEntity(props));
  }

  /**
   * Factory method to reconstitute a authtype entity from persistence
   *
   * @param props - Authtype properties from database
   * @returns AuthtypeEntity instance
   */
  public static reconstitute(props: AuthtypeDomainState): AuthtypeEntity {
    return new AuthtypeEntity(props);
  }

  /**
   * Factory method to reconstitute entity from snapshot
   *
   * @param snapshot - Authtype snapshot properties
   * @returns Result containing AuthtypeEntity or DomainError
   */
  public static fromSnapshot(
    snapshot: AuthtypeSnapshotProps,
  ): Result<AuthtypeEntity, DomainError> {
    const idResult = AuthtypeId.from(snapshot.id);
    if (!idResult.ok) {
      return err(idResult.error);
    }
    const webhookIdResult = AuthtypeWebhookId.from(snapshot.webhookId);
    if (!webhookIdResult.ok) {
      return err(webhookIdResult.error);
    }
    const typeResult = createAuthtypeType(snapshot.type);
    if (!typeResult.ok) {
      return err(typeResult.error);
    }
    const signingSecretRefResult = AuthtypeSigningSecretRef.from(
      snapshot.signingSecretRef,
    );
    if (!signingSecretRefResult.ok) {
      return err(signingSecretRefResult.error);
    }
    const signatureAlgorithmResult = createAuthtypeSignatureAlgorithm(
      snapshot.signatureAlgorithm,
    );
    if (!signatureAlgorithmResult.ok) {
      return err(signatureAlgorithmResult.error);
    }
    const usernameRefResult = AuthtypeUsernameRef.from(snapshot.usernameRef);
    if (!usernameRefResult.ok) {
      return err(usernameRefResult.error);
    }
    const passwordRefResult = AuthtypePasswordRef.from(snapshot.passwordRef);
    if (!passwordRefResult.ok) {
      return err(passwordRefResult.error);
    }
    const apiKeyRefResult = AuthtypeApiKeyRef.from(snapshot.apiKeyRef);
    if (!apiKeyRefResult.ok) {
      return err(apiKeyRefResult.error);
    }
    const apiKeyHeaderResult = AuthtypeApiKeyHeader.from(snapshot.apiKeyHeader);
    if (!apiKeyHeaderResult.ok) {
      return err(apiKeyHeaderResult.error);
    }
    const apiKeyQueryParamResult = AuthtypeApiKeyQueryParam.from(
      snapshot.apiKeyQueryParam,
    );
    if (!apiKeyQueryParamResult.ok) {
      return err(apiKeyQueryParamResult.error);
    }
    const tokenUrlResult = AuthtypeTokenUrl.from(snapshot.tokenUrl);
    if (!tokenUrlResult.ok) {
      return err(tokenUrlResult.error);
    }
    const clientIdRefResult = AuthtypeClientIdRef.from(snapshot.clientIdRef);
    if (!clientIdRefResult.ok) {
      return err(clientIdRefResult.error);
    }
    const clientSecretRefResult = AuthtypeClientSecretRef.from(
      snapshot.clientSecretRef,
    );
    if (!clientSecretRefResult.ok) {
      return err(clientSecretRefResult.error);
    }
    const scopeResult = AuthtypeScope.from(snapshot.scope);
    if (!scopeResult.ok) {
      return err(scopeResult.error);
    }
    const certRefResult = AuthtypeCertRef.from(snapshot.certRef);
    if (!certRefResult.ok) {
      return err(certRefResult.error);
    }
    const keyRefResult = AuthtypeKeyRef.from(snapshot.keyRef);
    if (!keyRefResult.ok) {
      return err(keyRefResult.error);
    }
    const caRefResult = AuthtypeCaRef.from(snapshot.caRef);
    if (!caRefResult.ok) {
      return err(caRefResult.error);
    }
    const createdAtResult = AuthtypeCreatedAt.from(snapshot.createdAt);
    if (!createdAtResult.ok) {
      return err(createdAtResult.error);
    }

    const updatedAtResult = AuthtypeUpdatedAt.from(snapshot.updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = AuthtypeVersion.from(snapshot.version);
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const props: AuthtypeDomainState = {
      id: idResult.value,
      webhookId: webhookIdResult.value,
      type: typeResult.value,
      signingSecretRef: signingSecretRefResult.value,
      signatureAlgorithm: signatureAlgorithmResult.value,
      usernameRef: usernameRefResult.value,
      passwordRef: passwordRefResult.value,
      apiKeyRef: apiKeyRefResult.value,
      apiKeyHeader: apiKeyHeaderResult.value,
      apiKeyQueryParam: apiKeyQueryParamResult.value,
      tokenUrl: tokenUrlResult.value,
      clientIdRef: clientIdRefResult.value,
      clientSecretRef: clientSecretRefResult.value,
      scope: scopeResult.value,
      certRef: certRefResult.value,
      keyRef: keyRefResult.value,
      caRef: caRefResult.value,
      createdAt: createdAtResult.value,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return AuthtypeEntity.create(props);
  }

  /**
   * Validates authtype entity properties
   *
   * @param props - Properties to validate
   * @returns Validation result
   */
  private static validate(
    props: AuthtypeDomainState,
  ): Result<void, DomainError> {
    // Basic validation
    if (!props.id) {
      return err(AuthtypeErrors.INVALID_ID_DATA);
    }
    if (!props.webhookId) {
      return err(AuthtypeErrors.INVALID_WEBHOOK_ID_DATA);
    }
    if (!props.type) {
      return err(AuthtypeErrors.INVALID_TYPE_DATA);
    }

    return ok(undefined);
  }

  // ======================
  // Getters (Public API)
  // ======================

  public get id(): AuthtypeId {
    return this.props.id;
  }

  public get webhookId(): AuthtypeWebhookId {
    return this.props.webhookId;
  }

  public get type(): AuthtypeType {
    return this.props.type;
  }

  public get signingSecretRef(): AuthtypeSigningSecretRef | undefined {
    return this.props.signingSecretRef;
  }

  public get signatureAlgorithm(): AuthtypeSignatureAlgorithm | undefined {
    return this.props.signatureAlgorithm;
  }

  public get usernameRef(): AuthtypeUsernameRef | undefined {
    return this.props.usernameRef;
  }

  public get passwordRef(): AuthtypePasswordRef | undefined {
    return this.props.passwordRef;
  }

  public get apiKeyRef(): AuthtypeApiKeyRef | undefined {
    return this.props.apiKeyRef;
  }

  public get apiKeyHeader(): AuthtypeApiKeyHeader | undefined {
    return this.props.apiKeyHeader;
  }

  public get apiKeyQueryParam(): AuthtypeApiKeyQueryParam | undefined {
    return this.props.apiKeyQueryParam;
  }

  public get tokenUrl(): AuthtypeTokenUrl | undefined {
    return this.props.tokenUrl;
  }

  public get clientIdRef(): AuthtypeClientIdRef | undefined {
    return this.props.clientIdRef;
  }

  public get clientSecretRef(): AuthtypeClientSecretRef | undefined {
    return this.props.clientSecretRef;
  }

  public get scope(): AuthtypeScope | undefined {
    return this.props.scope;
  }

  public get certRef(): AuthtypeCertRef | undefined {
    return this.props.certRef;
  }

  public get keyRef(): AuthtypeKeyRef | undefined {
    return this.props.keyRef;
  }

  public get caRef(): AuthtypeCaRef | undefined {
    return this.props.caRef;
  }

  public get createdAt(): AuthtypeCreatedAt {
    return this.props.createdAt;
  }

  public get updatedAt(): AuthtypeUpdatedAt {
    return this.props.updatedAt;
  }

  public get version(): AuthtypeVersion {
    return this.props.version;
  }

  // ======================
  // Simple Update Methods (No Business Logic)
  // ======================

  /**
   * Creates a new entity with updated webhookId (pure state transition)
   *
   * @param webhookId - New webhook_id value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withWebhookId(
    webhookId: AuthtypeWebhookId,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ webhookId }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated type (with basic transition validation)
   *
   * @param type - New type value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withType(
    type: AuthtypeType,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    const currentStatus = this.props.type.value;
    const targetStatus = type.value;

    if (!AuthtypeTypeLogic.canTransition(currentStatus, targetStatus)) {
      return err({
        ...AuthtypeErrors.INVALID_TYPE_TRANSITION,
        context: {
          currentStatus,
          targetStatus,
          validTransitions:
            AuthtypeTypeLogic.getValidTransitions(currentStatus),
        },
      });
    }

    return this.createUpdatedEntity({ type }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated signingSecretRef (pure state transition)
   *
   * @param signingSecretRef - New signingSecretRef value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withSigningSecretRef(
    signingSecretRef: AuthtypeSigningSecretRef,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ signingSecretRef }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated signatureAlgorithm (with basic transition validation)
   *
   * @param signatureAlgorithm - New signatureAlgorithm value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withSignatureAlgorithm(
    signatureAlgorithm: AuthtypeSignatureAlgorithm,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    if (this.props.signatureAlgorithm) {
      // If current status exists, validate transition
      const currentStatus = this.props.signatureAlgorithm.value;
      const targetStatus = signatureAlgorithm.value;

      if (
        !AuthtypeSignatureAlgorithmLogic.canTransition(
          currentStatus,
          targetStatus,
        )
      ) {
        return err({
          ...AuthtypeErrors.INVALID_SIGNATURE_ALGORITHM_TRANSITION,
          context: {
            currentStatus,
            targetStatus,
            validTransitions:
              AuthtypeSignatureAlgorithmLogic.getValidTransitions(
                currentStatus,
              ),
          },
        });
      }
    }

    return this.createUpdatedEntity({ signatureAlgorithm }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated usernameRef (pure state transition)
   *
   * @param usernameRef - New usernameRef value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withUsernameRef(
    usernameRef: AuthtypeUsernameRef,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ usernameRef }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated passwordRef (pure state transition)
   *
   * @param passwordRef - New passwordRef value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withPasswordRef(
    passwordRef: AuthtypePasswordRef,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ passwordRef }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated apiKeyRef (pure state transition)
   *
   * @param apiKeyRef - New apiKeyRef value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withApiKeyRef(
    apiKeyRef: AuthtypeApiKeyRef,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ apiKeyRef }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated apiKeyHeader (pure state transition)
   *
   * @param apiKeyHeader - New apiKeyHeader value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withApiKeyHeader(
    apiKeyHeader: AuthtypeApiKeyHeader,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ apiKeyHeader }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated apiKeyQueryParam (pure state transition)
   *
   * @param apiKeyQueryParam - New apiKeyQueryParam value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withApiKeyQueryParam(
    apiKeyQueryParam: AuthtypeApiKeyQueryParam,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ apiKeyQueryParam }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated tokenUrl (pure state transition)
   *
   * @param tokenUrl - New tokenUrl value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withTokenUrl(
    tokenUrl: AuthtypeTokenUrl,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ tokenUrl }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated clientIdRef (pure state transition)
   *
   * @param clientIdRef - New clientIdRef value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withClientIdRef(
    clientIdRef: AuthtypeClientIdRef,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ clientIdRef }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated clientSecretRef (pure state transition)
   *
   * @param clientSecretRef - New clientSecretRef value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withClientSecretRef(
    clientSecretRef: AuthtypeClientSecretRef,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ clientSecretRef }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated scope (pure state transition)
   *
   * @param scope - New scope value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withScope(
    scope: AuthtypeScope,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ scope }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated certRef (pure state transition)
   *
   * @param certRef - New certRef value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withCertRef(
    certRef: AuthtypeCertRef,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ certRef }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated keyRef (pure state transition)
   *
   * @param keyRef - New keyRef value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withKeyRef(
    keyRef: AuthtypeKeyRef,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ keyRef }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated caRef (pure state transition)
   *
   * @param caRef - New caRef value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AuthtypeEntity, DomainError>
   */
  public withCaRef(
    caRef: AuthtypeCaRef,
    updatedAt?: Date,
    version?: number,
  ): Result<AuthtypeEntity, DomainError> {
    return this.createUpdatedEntity({ caRef }, updatedAt, version);
  }

  // ======================
  // Query Methods
  // ======================

  /**
   * Checks if two authtypes are the same entity
   *
   * @param other - Other authtype to compare
   */
  public sameAs(other: AuthtypeEntity): boolean {
    return this.props.id.equals(other.props.id);
  }

  /**
   * Gets a snapshot of current entity state for serialization
   */
  public toSnapshot(): AuthtypeSnapshotProps {
    return {
      id: this.props.id.value,
      webhookId: this.props.webhookId.value,
      type: this.props.type.value,
      signingSecretRef: this.props.signingSecretRef?.value,
      signatureAlgorithm: this.props.signatureAlgorithm?.value,
      usernameRef: this.props.usernameRef?.value,
      passwordRef: this.props.passwordRef?.value,
      apiKeyRef: this.props.apiKeyRef?.value,
      apiKeyHeader: this.props.apiKeyHeader?.value,
      apiKeyQueryParam: this.props.apiKeyQueryParam?.value,
      tokenUrl: this.props.tokenUrl?.value,
      clientIdRef: this.props.clientIdRef?.value,
      clientSecretRef: this.props.clientSecretRef?.value,
      scope: this.props.scope?.value,
      certRef: this.props.certRef?.value,
      keyRef: this.props.keyRef?.value,
      caRef: this.props.caRef?.value,
      createdAt: this.props.createdAt.value,
      updatedAt: this.props.updatedAt.value,
      version: this.props.version.value,
    };
  }

  /**
   * Gets the current domain state with value objects
   *
   * Provides access to the rich domain state for application layer
   * without requiring infrastructure mappers. Maintains clean architecture.
   *
   * @returns Current domain state with value objects
   */
  public getDomainState(): AuthtypeDomainState {
    return this.props;
  }
}
