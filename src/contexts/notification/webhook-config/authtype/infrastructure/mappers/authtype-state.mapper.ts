// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

/**
 * Authtype State Infrastructure Mappers
 *
 * Bidirectional mapping between pure VO domain state and primitive persistence snapshot.
 * Handles conversion between rich domain objects and raw database data.
 */

import {
  AuthtypeCreatedAt,
  AuthtypeUpdatedAt,
  AuthtypeVersion,
  AuthtypeId,
  AuthtypeWebhookId,
  createAuthtypeType,
  AuthtypeSigningSecretRef,
  createAuthtypeSignatureAlgorithm,
  AuthtypeUsernameRef,
  AuthtypePasswordRef,
  AuthtypeApiKeyRef,
  AuthtypeApiKeyHeader,
  AuthtypeApiKeyQueryParam,
  AuthtypeTokenUrl,
  AuthtypeClientIdRef,
  AuthtypeClientSecretRef,
  AuthtypeScope,
  AuthtypeCertRef,
  AuthtypeKeyRef,
  AuthtypeCaRef,
} from '../../domain/value-objects';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { AuthtypeDomainState } from '../../domain/state/authtype.state';
import { AuthtypeSnapshotProps } from '../../domain/props';

/**
 * Infrastructure State Mapper
 *
 * Handles conversion between domain VOs and persistence primitives.
 * This is where primitive obsession is eliminated - converting between
 * rich domain objects and raw database data.
 */
export class AuthtypeStateMapper {
  /**
   * Convert primitive persistence snapshot to rich domain state
   *
   * @param snapshot - Raw database/persistence data
   * @returns Rich domain state with VOs or error
   */
  static toDomain(
    snapshot: AuthtypeSnapshotProps,
  ): Result<AuthtypeDomainState, DomainError> {
    const errors: Array<{ field: string; error: DomainError }> = [];

    // Helper function to validate and collect errors
    const validateField = <T>(
      fieldName: string,
      result: Result<T, DomainError>,
    ): T | null => {
      if (!result.ok) {
        errors.push({ field: fieldName, error: result.error });
        return null;
      }
      return result.value;
    };

    // Convert each primitive to its corresponding VO with error collection
    const id = validateField('id', AuthtypeId.from(snapshot.id));
    const webhookId = validateField(
      'webhookId',
      AuthtypeWebhookId.from(snapshot.webhookId),
    );
    const type = validateField('type', createAuthtypeType(snapshot.type));
    const signingSecretRef = snapshot.signingSecretRef
      ? validateField(
          'signingSecretRef',
          AuthtypeSigningSecretRef.from(snapshot.signingSecretRef),
        )
      : undefined;
    const signatureAlgorithm = validateField(
      'signatureAlgorithm',
      createAuthtypeSignatureAlgorithm(snapshot.signatureAlgorithm),
    );
    const usernameRef = snapshot.usernameRef
      ? validateField(
          'usernameRef',
          AuthtypeUsernameRef.from(snapshot.usernameRef),
        )
      : undefined;
    const passwordRef = snapshot.passwordRef
      ? validateField(
          'passwordRef',
          AuthtypePasswordRef.from(snapshot.passwordRef),
        )
      : undefined;
    const apiKeyRef = snapshot.apiKeyRef
      ? validateField('apiKeyRef', AuthtypeApiKeyRef.from(snapshot.apiKeyRef))
      : undefined;
    const apiKeyHeader = snapshot.apiKeyHeader
      ? validateField(
          'apiKeyHeader',
          AuthtypeApiKeyHeader.from(snapshot.apiKeyHeader),
        )
      : undefined;
    const apiKeyQueryParam = snapshot.apiKeyQueryParam
      ? validateField(
          'apiKeyQueryParam',
          AuthtypeApiKeyQueryParam.from(snapshot.apiKeyQueryParam),
        )
      : undefined;
    const tokenUrl = snapshot.tokenUrl
      ? validateField('tokenUrl', AuthtypeTokenUrl.from(snapshot.tokenUrl))
      : undefined;
    const clientIdRef = snapshot.clientIdRef
      ? validateField(
          'clientIdRef',
          AuthtypeClientIdRef.from(snapshot.clientIdRef),
        )
      : undefined;
    const clientSecretRef = snapshot.clientSecretRef
      ? validateField(
          'clientSecretRef',
          AuthtypeClientSecretRef.from(snapshot.clientSecretRef),
        )
      : undefined;
    const scope = snapshot.scope
      ? validateField('scope', AuthtypeScope.from(snapshot.scope))
      : undefined;
    const certRef = snapshot.certRef
      ? validateField('certRef', AuthtypeCertRef.from(snapshot.certRef))
      : undefined;
    const keyRef = snapshot.keyRef
      ? validateField('keyRef', AuthtypeKeyRef.from(snapshot.keyRef))
      : undefined;
    const caRef = snapshot.caRef
      ? validateField('caRef', AuthtypeCaRef.from(snapshot.caRef))
      : undefined;
    const version = validateField(
      'version',
      AuthtypeVersion.from(snapshot.version),
    );
    const createdAt = validateField(
      'createdAt',
      AuthtypeCreatedAt.from(snapshot.createdAt),
    );
    const updatedAt = validateField(
      'updatedAt',
      AuthtypeUpdatedAt.from(snapshot.updatedAt),
    );

    // If any validations failed, return aggregated error
    if (errors.length > 0) {
      return err({
        code: 'AUTHTYPE.MAPPER_VALIDATION_FAILED',
        title: 'Domain State Mapping Failed',
        detail: `Failed to create domain state from persistence snapshot. ${errors.length} validation error(s) occurred.`,
        category: 'infrastructure',
        retryable: false,
        context: {
          validationErrors: errors.map((e) => ({
            field: e.field,
            errorCode: e.error.code,
            errorMessage: e.error.detail,
          })),
          snapshotCode: snapshot.id,
        },
      });
    }

    // All validations passed, construct the rich domain state
    const domainState: AuthtypeDomainState = {
      id: id!,
      webhookId: webhookId!,
      type: type!,
      signingSecretRef: signingSecretRef || undefined,
      signatureAlgorithm: signatureAlgorithm || undefined,
      usernameRef: usernameRef || undefined,
      passwordRef: passwordRef || undefined,
      apiKeyRef: apiKeyRef || undefined,
      apiKeyHeader: apiKeyHeader || undefined,
      apiKeyQueryParam: apiKeyQueryParam || undefined,
      tokenUrl: tokenUrl || undefined,
      clientIdRef: clientIdRef || undefined,
      clientSecretRef: clientSecretRef || undefined,
      scope: scope || undefined,
      certRef: certRef || undefined,
      keyRef: keyRef || undefined,
      caRef: caRef || undefined,
      version: version!,
      createdAt: createdAt!,
      updatedAt: updatedAt!,
    };

    return ok(domainState);
  }

  /**
   * Convert rich domain state to primitive persistence snapshot
   *
   * @param domainState - Rich domain state with VOs
   * @returns Raw persistence data for database storage
   */
  static toSnapshot(domainState: AuthtypeDomainState): AuthtypeSnapshotProps {
    return {
      // Extract primitive values from VOs
      id: domainState.id.value,
      webhookId: domainState.webhookId.value,
      type: domainState.type.value,
      signingSecretRef: domainState.signingSecretRef?.value,
      signatureAlgorithm: domainState.signatureAlgorithm?.value,
      usernameRef: domainState.usernameRef?.value,
      passwordRef: domainState.passwordRef?.value,
      apiKeyRef: domainState.apiKeyRef?.value,
      apiKeyHeader: domainState.apiKeyHeader?.value,
      apiKeyQueryParam: domainState.apiKeyQueryParam?.value,
      tokenUrl: domainState.tokenUrl?.value,
      clientIdRef: domainState.clientIdRef?.value,
      clientSecretRef: domainState.clientSecretRef?.value,
      scope: domainState.scope?.value,
      certRef: domainState.certRef?.value,
      keyRef: domainState.keyRef?.value,
      caRef: domainState.caRef?.value,
      version: domainState.version.value,
      createdAt: domainState.createdAt.value,
      updatedAt: domainState.updatedAt.value,
    };
  }
}
