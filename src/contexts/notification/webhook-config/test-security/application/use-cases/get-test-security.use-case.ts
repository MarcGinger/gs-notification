// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Inject } from '@nestjs/common';
import {
  Result,
  ok,
  err,
  DomainError,
  isOk,
  withContext,
} from 'src/shared/errors';

// Shared utilities and infrastructure
import { APP_LOGGER, componentLogger, Logger } from 'src/shared/logging';
import { CACHE_TTL } from 'src/shared/application/caching/cache.config';
import { RepositoryOptions } from 'src/shared/infrastructure/repositories/repository.types';
import { Option } from 'src/shared/domain/types';
import { ActorContextUtil } from 'src/shared/utilities/actor-context.util';
import { IUserToken } from 'src/shared/security';

// Application layer
import { ITestSecurityQuery, TEST_SECURITY_QUERY_TOKEN } from '../ports';
import { DetailTestSecurityResponse } from '../dtos';
import { IGetTestSecurityUseCase } from './contracts';
import { TestSecurityErrors } from '../../domain/errors';

/**
 * Get TestSecurity Use Case - Simplified CQRS Read Side Implementation
 *
 * Simple use case that queries for testSecurity data by id.
 * Authorization is handled at the service layer.
 */

@Injectable()
export class GetTestSecurityUseCase implements IGetTestSecurityUseCase {
  private readonly logger: Logger;

  constructor(
    @Inject(TEST_SECURITY_QUERY_TOKEN)
    private readonly query: ITestSecurityQuery,
    @Inject(APP_LOGGER) moduleLogger: Logger,
  ) {
    this.logger = componentLogger(moduleLogger, 'GetTestSecurityUseCase');
  }

  async execute(params: {
    user: IUserToken;
    id: string;
    correlationId: string;
  }): Promise<Result<DetailTestSecurityResponse, DomainError>> {
    const { user, id, correlationId } = params;

    // Simple input validation
    if (!id?.trim()) {
      return err({
        code: 'TEST_SECURITY.INVALID_ID' as const,
        title: 'Invalid id',
        category: 'validation' as const,
        context: { id, correlationId, userId: user.sub },
      });
    }

    // Setup repository options with caching
    const repositoryOptions: RepositoryOptions = {
      cache: {
        ttl: CACHE_TTL.STANDARD,
        refreshCache: false,
      },
      correlationId,
      requestId: user.sub,
    };

    // Convert user token to actor context
    const actorResult = ActorContextUtil.fromUserTokenSafe(user);
    if (!isOk(actorResult)) {
      return err(
        withContext(actorResult.error, {
          correlationId,
          userId: user.sub,
          operation: 'get_test_security',
          id,
        }),
      );
    }

    // Query for the testSecurity data
    const queryResult = await this.query.findById(
      actorResult.value,
      id,
      repositoryOptions,
    );

    if (!isOk(queryResult)) {
      return err(
        withContext(queryResult.error, {
          correlationId,
          userId: user.sub,
          operation: 'get_test_security',
          id,
        }),
      );
    }

    // Handle Option<DetailTestSecurityResponse>
    const testSecurityDto = Option.isNone(queryResult.value)
      ? null
      : queryResult.value.value;

    if (!testSecurityDto) {
      return err(
        withContext(TestSecurityErrors.TEST_SECURITY_NOT_FOUND, {
          id,
          correlationId,
          userId: user.sub,
          operation: 'get_test_security',
        }),
      );
    }

    // Success - no logging needed as this is handled at service layer

    return ok(testSecurityDto);
  }
}
