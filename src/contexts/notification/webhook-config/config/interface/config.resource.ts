// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

/**
 * Config Resource Decorators - Domain-Driven Authorization
 *
 * Clean integration with domain-driven permissions infrastructure.
 * All business rules and risk assessments come from the domain layer.
 *
 * ARCHITECTURAL PRINCIPLE: No business logic duplication
 * ✅ Risk levels: ConfigPermissionHelpers.getRiskLevel()
 * ✅ Justification rules: ConfigPermissionHelpers.requiresJustification()
 * ✅ Categories: ConfigPermissionRegistry[permission].category
 * ✅ Policy paths: ConfigPermissionHelpers.getPolicyPath()
 * ✅ Audit requirements: ConfigPermissionRegistry[permission].auditRequired
 *
 * This keeps the HTTP layer thin and ensures business rules
 * live in the domain where they belong.
 */

import { Resource } from 'src/shared/security/opa';
import { Request } from 'express';
import {
  ConfigPermission,
  ConfigPermissionHelpers,
  ConfigPermissionRegistry,
} from '../domain/permissions';

/**
 * Domain-driven Config resource decorator
 *
 * All business rules come from the domain layer - no duplication!
 */
export const ConfigResource = (permission: ConfigPermission) =>
  Resource({
    type: 'config',
    action: permission,
    extractId: (req: Request) => req.params?.id || req.params?.id,
    extractAttributes: (req: Request) => {
      const body = req.body as Record<string, unknown> | undefined;
      const query = req.query as Record<string, unknown> | undefined;

      // Business data extraction
      const webhookId = body?.webhookId || query?.webhookId;
      const tenantId = body?.tenantId || query?.tenantId;
      const strategy = body?.strategy || query?.strategy;
      const maxRetryAttempts =
        body?.maxRetryAttempts || query?.maxRetryAttempts;
      const retryBackoffSeconds =
        body?.retryBackoffSeconds || query?.retryBackoffSeconds;
      const retryStrategy = body?.retryStrategy || query?.retryStrategy;
      const backoffJitterPct =
        body?.backoffJitterPct || query?.backoffJitterPct;
      const requestTimeoutMs =
        body?.requestTimeoutMs || query?.requestTimeoutMs;
      const connectTimeoutMs =
        body?.connectTimeoutMs || query?.connectTimeoutMs;
      const signatureAlgorithm =
        body?.signatureAlgorithm || query?.signatureAlgorithm;
      const includeTimestampHeader =
        body?.includeTimestampHeader || query?.includeTimestampHeader;
      const maxConcurrent = body?.maxConcurrent || query?.maxConcurrent;
      const dlqEnabled = body?.dlqEnabled || query?.dlqEnabled;
      const dlqMaxAgeSeconds =
        body?.dlqMaxAgeSeconds || query?.dlqMaxAgeSeconds;
      const ordering = body?.ordering || query?.ordering;
      const defaultLocale = body?.defaultLocale || query?.defaultLocale;

      const baseAttributes = {
        webhookId,
        tenantId,
        strategy,
        maxRetryAttempts,
        retryBackoffSeconds,
        retryStrategy,
        backoffJitterPct,
        requestTimeoutMs,
        connectTimeoutMs,
        signatureAlgorithm,
        includeTimestampHeader,
        maxConcurrent,
        dlqEnabled,
        dlqMaxAgeSeconds,
        ordering,
        defaultLocale,
      };

      // Domain-driven permission context (no hardcoded business rules!)
      const permissionMeta = ConfigPermissionRegistry[permission];
      const permissionContext = {
        permission,
        riskLevel: ConfigPermissionHelpers.getRiskLevel(permission),
        requiresJustification:
          ConfigPermissionHelpers.requiresJustification(permission),
        category: permissionMeta?.category as string,
        policyPath: ConfigPermissionHelpers.getPolicyPath(permission),
        auditRequired: ConfigPermissionHelpers.requiresAudit(permission),
      };

      return {
        ...baseAttributes,
        _permissionContext: permissionContext,
      };
    },
  });

/**
 * Specialized decorators for high-risk operations
 */
export const ConfigDeleteResource = () =>
  ConfigResource(ConfigPermission.DOMAIN_CONFIG_DELETE);

export const ConfigCreateResource = () =>
  ConfigResource(ConfigPermission.DOMAIN_CONFIG_CREATE);

export const ConfigUpdateResource = () =>
  ConfigResource(ConfigPermission.DOMAIN_CONFIG_UPDATE);

export const ConfigReadResource = () =>
  ConfigResource(ConfigPermission.DOMAIN_CONFIG_READ);
