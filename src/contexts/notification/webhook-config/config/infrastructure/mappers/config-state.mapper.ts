// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

/**
 * Config State Infrastructure Mappers
 *
 * Bidirectional mapping between pure VO domain state and primitive persistence snapshot.
 * Handles conversion between rich domain objects and raw database data.
 */

import {
  ConfigCreatedAt,
  ConfigUpdatedAt,
  ConfigVersion,
  ConfigWebhookId,
  createConfigStrategy,
  ConfigMaxRetryAttempts,
  ConfigRetryBackoffSeconds,
  createConfigRetryStrategy,
  ConfigBackoffJitterPct,
  ConfigRequestTimeoutMs,
  ConfigConnectTimeoutMs,
  createConfigSignatureAlgorithm,
  ConfigIncludeTimestampHeader,
  ConfigMaxConcurrent,
  ConfigDlqEnabled,
  ConfigDlqMaxAgeSeconds,
  createConfigOrdering,
  ConfigDefaultLocale,
  ConfigMetadata,
} from '../../domain/value-objects';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { ConfigDomainState } from '../../domain/state/config.state';
import { ConfigSnapshotProps } from '../../domain/props';

/**
 * Infrastructure State Mapper
 *
 * Handles conversion between domain VOs and persistence primitives.
 * This is where primitive obsession is eliminated - converting between
 * rich domain objects and raw database data.
 */
export class ConfigStateMapper {
  /**
   * Convert primitive persistence snapshot to rich domain state
   *
   * @param snapshot - Raw database/persistence data
   * @returns Rich domain state with VOs or error
   */
  static toDomain(
    snapshot: ConfigSnapshotProps,
  ): Result<ConfigDomainState, DomainError> {
    const errors: Array<{ field: string; error: DomainError }> = [];

    // Helper function to validate and collect errors
    const validateField = <T>(
      fieldName: string,
      result: Result<T, DomainError>,
    ): T | null => {
      if (!result.ok) {
        errors.push({ field: fieldName, error: result.error });
        return null;
      }
      return result.value;
    };

    // Convert each primitive to its corresponding VO with error collection
    const webhookId = validateField(
      'webhookId',
      ConfigWebhookId.from(snapshot.webhookId),
    );
    const strategy = validateField(
      'strategy',
      createConfigStrategy(snapshot.strategy),
    );
    const maxRetryAttempts = validateField(
      'maxRetryAttempts',
      ConfigMaxRetryAttempts.from(snapshot.maxRetryAttempts),
    );
    const retryBackoffSeconds = validateField(
      'retryBackoffSeconds',
      ConfigRetryBackoffSeconds.from(snapshot.retryBackoffSeconds),
    );
    const retryStrategy = validateField(
      'retryStrategy',
      createConfigRetryStrategy(snapshot.retryStrategy),
    );
    const backoffJitterPct = snapshot.backoffJitterPct
      ? validateField(
          'backoffJitterPct',
          ConfigBackoffJitterPct.from(snapshot.backoffJitterPct),
        )
      : undefined;
    const requestTimeoutMs = snapshot.requestTimeoutMs
      ? validateField(
          'requestTimeoutMs',
          ConfigRequestTimeoutMs.from(snapshot.requestTimeoutMs),
        )
      : undefined;
    const connectTimeoutMs = snapshot.connectTimeoutMs
      ? validateField(
          'connectTimeoutMs',
          ConfigConnectTimeoutMs.from(snapshot.connectTimeoutMs),
        )
      : undefined;
    const signatureAlgorithm = validateField(
      'signatureAlgorithm',
      createConfigSignatureAlgorithm(snapshot.signatureAlgorithm),
    );
    const includeTimestampHeader = snapshot.includeTimestampHeader
      ? validateField(
          'includeTimestampHeader',
          ConfigIncludeTimestampHeader.from(snapshot.includeTimestampHeader),
        )
      : undefined;
    const maxConcurrent = snapshot.maxConcurrent
      ? validateField(
          'maxConcurrent',
          ConfigMaxConcurrent.from(snapshot.maxConcurrent),
        )
      : undefined;
    const dlqEnabled = snapshot.dlqEnabled
      ? validateField('dlqEnabled', ConfigDlqEnabled.from(snapshot.dlqEnabled))
      : undefined;
    const dlqMaxAgeSeconds = snapshot.dlqMaxAgeSeconds
      ? validateField(
          'dlqMaxAgeSeconds',
          ConfigDlqMaxAgeSeconds.from(snapshot.dlqMaxAgeSeconds),
        )
      : undefined;
    const ordering = validateField(
      'ordering',
      createConfigOrdering(snapshot.ordering),
    );
    const defaultLocale = validateField(
      'defaultLocale',
      ConfigDefaultLocale.from(snapshot.defaultLocale),
    );
    const metadata = snapshot.metadata
      ? validateField('metadata', ConfigMetadata.from(snapshot.metadata))
      : undefined;
    const version = validateField(
      'version',
      ConfigVersion.from(snapshot.version),
    );
    const createdAt = validateField(
      'createdAt',
      ConfigCreatedAt.from(snapshot.createdAt),
    );
    const updatedAt = validateField(
      'updatedAt',
      ConfigUpdatedAt.from(snapshot.updatedAt),
    );

    // If any validations failed, return aggregated error
    if (errors.length > 0) {
      return err({
        code: 'CONFIG.MAPPER_VALIDATION_FAILED',
        title: 'Domain State Mapping Failed',
        detail: `Failed to create domain state from persistence snapshot. ${errors.length} validation error(s) occurred.`,
        category: 'infrastructure',
        retryable: false,
        context: {
          validationErrors: errors.map((e) => ({
            field: e.field,
            errorCode: e.error.code,
            errorMessage: e.error.detail,
          })),
          snapshotCode: snapshot.webhookId,
        },
      });
    }

    // All validations passed, construct the rich domain state
    const domainState: ConfigDomainState = {
      webhookId: webhookId!,
      strategy: strategy!,
      maxRetryAttempts: maxRetryAttempts!,
      retryBackoffSeconds: retryBackoffSeconds!,
      retryStrategy: retryStrategy || undefined,
      backoffJitterPct: backoffJitterPct || undefined,
      requestTimeoutMs: requestTimeoutMs || undefined,
      connectTimeoutMs: connectTimeoutMs || undefined,
      signatureAlgorithm: signatureAlgorithm || undefined,
      includeTimestampHeader: includeTimestampHeader || undefined,
      maxConcurrent: maxConcurrent || undefined,
      dlqEnabled: dlqEnabled || undefined,
      dlqMaxAgeSeconds: dlqMaxAgeSeconds || undefined,
      ordering: ordering || undefined,
      defaultLocale: defaultLocale!,
      metadata: metadata || undefined,
      version: version!,
      createdAt: createdAt!,
      updatedAt: updatedAt!,
    };

    return ok(domainState);
  }

  /**
   * Convert rich domain state to primitive persistence snapshot
   *
   * @param domainState - Rich domain state with VOs
   * @returns Raw persistence data for database storage
   */
  static toSnapshot(domainState: ConfigDomainState): ConfigSnapshotProps {
    return {
      // Extract primitive values from VOs
      webhookId: domainState.webhookId.value,
      strategy: domainState.strategy.value,
      maxRetryAttempts: domainState.maxRetryAttempts.value,
      retryBackoffSeconds: domainState.retryBackoffSeconds.value,
      retryStrategy: domainState.retryStrategy?.value,
      backoffJitterPct: domainState.backoffJitterPct?.value,
      requestTimeoutMs: domainState.requestTimeoutMs?.value,
      connectTimeoutMs: domainState.connectTimeoutMs?.value,
      signatureAlgorithm: domainState.signatureAlgorithm?.value,
      includeTimestampHeader: domainState.includeTimestampHeader?.value,
      maxConcurrent: domainState.maxConcurrent?.value,
      dlqEnabled: domainState.dlqEnabled?.value,
      dlqMaxAgeSeconds: domainState.dlqMaxAgeSeconds?.value,
      ordering: domainState.ordering?.value,
      defaultLocale: domainState.defaultLocale.value,
      metadata: domainState.metadata?.value,
      version: domainState.version.value,
      createdAt: domainState.createdAt.value,
      updatedAt: domainState.updatedAt.value,
    };
  }
}
