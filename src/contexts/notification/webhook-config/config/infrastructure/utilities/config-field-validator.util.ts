// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import {
  safeParseJSON,
  safeParseJSONArray,
} from 'src/shared/infrastructure/repositories';
import { EventDataProcessingUtils } from 'src/shared/infrastructure/events/utilities/event-data-processing.utils';
import {
  ConfigOrderingValue,
  ConfigRetryStrategyValue,
  ConfigSignatureAlgorithmValue,
  ConfigStrategyValue,
} from '../../application/dtos';

/**
 * Config Field Validator Utility
 *
 * Centralized utility for parsing and validating Config aggregate data from EventStore events.
 * Provides consistent field validation patterns that can be reused across repositories
 * and projectors for Config domain operations.
 *
 * @domain Notification Context - Config Field Validation Utility
 * @layer Infrastructure
 * @pattern Utility Pattern + Field Validation
 */
export class ConfigFieldValidatorUtil {
  /**
   * Create projector data with SecretRef objects for Redis storage
   *
   * This method extracts SecretRef objects from event data and serializes them
   * as JSON strings for storage in Redis. The reader repository will deserialize
   * and resolve these SecretRef objects back to actual secret values.
   *
   * @param aggregateData - Raw event data from EventStore containing SecretRef objects
   * @returns Projector data object with SecretRef fields as JSON strings
   */
  static createConfigProjectorDataFromEventData(
    aggregateData: Record<string, any>,
  ): {
    id: string;
    webhookId?: string;
    tenantId: string;
    strategy: ConfigStrategyValue;
    maxRetryAttempts: number;
    retryBackoffSeconds: number;
    retryStrategy?: ConfigRetryStrategyValue;
    backoffJitterPct?: number;
    requestTimeoutMs?: number;
    connectTimeoutMs?: number;
    signatureAlgorithm?: ConfigSignatureAlgorithmValue;
    includeTimestampHeader?: boolean;
    maxConcurrent?: number;
    dlqEnabled?: boolean;
    dlqMaxAgeSeconds?: number;
    ordering?: ConfigOrderingValue;
    defaultLocale: string;
    metadata?: Record<string, unknown>;
    version: number;
    createdAt: Date;
    updatedAt: Date;
  } {
    // Parse array fields using safeParseJSONArray utility
    const metadata = safeParseJSON<Record<string, unknown>>(
      aggregateData.metadata,
      'metadata',
    );
    // Extract simple fields directly from event data
    const id = aggregateData.id as string;
    const webhookId = aggregateData.webhookId as string;
    const tenantId = aggregateData.tenantId as string;
    const strategy = aggregateData.strategy as ConfigStrategyValue;
    const maxRetryAttempts =
      typeof aggregateData.maxRetryAttempts === 'string'
        ? parseInt(aggregateData.maxRetryAttempts, 10)
        : (aggregateData.maxRetryAttempts as number);
    const retryBackoffSeconds =
      typeof aggregateData.retryBackoffSeconds === 'string'
        ? parseInt(aggregateData.retryBackoffSeconds, 10)
        : (aggregateData.retryBackoffSeconds as number);
    const retryStrategy =
      aggregateData.retryStrategy as ConfigRetryStrategyValue;
    const backoffJitterPct =
      typeof aggregateData.backoffJitterPct === 'string'
        ? parseInt(aggregateData.backoffJitterPct, 10)
        : (aggregateData.backoffJitterPct as number);
    const requestTimeoutMs =
      typeof aggregateData.requestTimeoutMs === 'string'
        ? parseInt(aggregateData.requestTimeoutMs, 10)
        : (aggregateData.requestTimeoutMs as number);
    const connectTimeoutMs =
      typeof aggregateData.connectTimeoutMs === 'string'
        ? parseInt(aggregateData.connectTimeoutMs, 10)
        : (aggregateData.connectTimeoutMs as number);
    const signatureAlgorithm =
      aggregateData.signatureAlgorithm as ConfigSignatureAlgorithmValue;
    const includeTimestampHeader =
      aggregateData.includeTimestampHeader === 'true' ||
      aggregateData.includeTimestampHeader === true;
    const maxConcurrent =
      typeof aggregateData.maxConcurrent === 'string'
        ? parseInt(aggregateData.maxConcurrent, 10)
        : (aggregateData.maxConcurrent as number);
    const dlqEnabled =
      aggregateData.dlqEnabled === 'true' || aggregateData.dlqEnabled === true;
    const dlqMaxAgeSeconds =
      typeof aggregateData.dlqMaxAgeSeconds === 'string'
        ? parseInt(aggregateData.dlqMaxAgeSeconds, 10)
        : (aggregateData.dlqMaxAgeSeconds as number);
    const ordering = aggregateData.ordering as ConfigOrderingValue;
    const defaultLocale = aggregateData.defaultLocale as string;

    // Store plain text values directly for now (not encrypted)
    // This preserves the user-provided values per record
    // Extract credentials for validation (they're handled via Config below)

    // Extract version and timestamps with proper type conversion
    const version = EventDataProcessingUtils.extractVersion(aggregateData);
    const { createdAt, updatedAt } =
      EventDataProcessingUtils.extractTimestamps(aggregateData);

    // safeParseJSON utilities provide error handling for invalid JSON,
    // direct field access provides type safety and truthful representation
    return {
      id,
      webhookId,
      tenantId,
      strategy,
      maxRetryAttempts,
      retryBackoffSeconds,
      retryStrategy,
      backoffJitterPct,
      requestTimeoutMs,
      connectTimeoutMs,
      signatureAlgorithm,
      includeTimestampHeader,
      maxConcurrent,
      dlqEnabled,
      dlqMaxAgeSeconds,
      ordering,
      defaultLocale,
      metadata,
      version,
      createdAt,
      updatedAt,
    };
  }
}
