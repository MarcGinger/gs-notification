// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, ok, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { ConfigAggregate } from '../aggregates';
import { ConfigEntity } from '../entities';
import { ConfigSnapshotProps, UpdateConfigProps } from '../props';
import { ValidatedConfigUpdateFields } from '../types';
import {
  ConfigWebhookId,
  ConfigTenantId,
  createConfigStrategy,
  ConfigMaxRetryAttempts,
  ConfigRetryBackoffSeconds,
  createConfigRetryStrategy,
  ConfigBackoffJitterPct,
  ConfigRequestTimeoutMs,
  ConfigConnectTimeoutMs,
  createConfigSignatureAlgorithm,
  ConfigIncludeTimestampHeader,
  ConfigMaxConcurrent,
  ConfigDlqEnabled,
  ConfigDlqMaxAgeSeconds,
  createConfigOrdering,
  ConfigDefaultLocale,
  ConfigMetadata,
} from '../value-objects';

/**
 * Update Config Aggregate Factory
 *
 * Handles the complete update flow for Config aggregates:
 * 1. Loads existing aggregate from snapshot
 * 2. Validates update properties and creates value objects
 * 3. Applies updates with proper business rule enforcement
 * 4. Returns updated aggregate ready for persistence
 *
 * This factory provides:
 * - Consistent update pattern matching create operations
 * - Centralized validation and business logic
 * - Efficient batch updates vs field-by-field
 * - Proper error context and logging integration
 */
export function updateConfigAggregateFromSnapshot(
  existingSnapshot: ConfigSnapshotProps,
  updateProps: UpdateConfigProps,
  metadata: EventMetadata,
  clock: Clock,
): Result<ConfigAggregate, DomainError> {
  // 1. Reconstitute existing aggregate
  const entityResult = ConfigEntity.fromSnapshot(existingSnapshot);
  if (!entityResult.ok) {
    return err(
      withContext(entityResult.error, {
        operation: 'update_config_reconstitute',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
      }),
    );
  }

  const existingAggregate = ConfigAggregate.reconstitute(
    entityResult.value,
    clock,
    metadata,
  );

  // 2. Validate and apply updates for each provided field
  const validatedFields: ValidatedConfigUpdateFields = {};

  // Validate webhookId if provided
  if (updateProps.webhookId !== undefined) {
    const webhookIdResult = ConfigWebhookId.from(updateProps.webhookId);
    if (!webhookIdResult.ok) {
      return err(
        withContext(webhookIdResult.error, {
          operation: 'update_config_webhook_id_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedWebhookId: updateProps.webhookId,
        }),
      );
    }
    validatedFields.webhookId = webhookIdResult.value;
  }

  // Validate tenantId if provided
  if (updateProps.tenantId !== undefined) {
    const tenantIdResult = ConfigTenantId.from(updateProps.tenantId);
    if (!tenantIdResult.ok) {
      return err(
        withContext(tenantIdResult.error, {
          operation: 'update_config_tenant_id_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedTenantId: updateProps.tenantId,
        }),
      );
    }
    validatedFields.tenantId = tenantIdResult.value;
  }

  // Validate strategy if provided
  if (updateProps.strategy !== undefined) {
    const strategyResult = createConfigStrategy(updateProps.strategy);
    if (!strategyResult.ok) {
      return err(
        withContext(strategyResult.error, {
          operation: 'update_config_strategy_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedStrategy: updateProps.strategy,
        }),
      );
    }
    validatedFields.strategy = strategyResult.value;
  }

  // Validate maxRetryAttempts if provided
  if (updateProps.maxRetryAttempts !== undefined) {
    const maxRetryAttemptsResult = ConfigMaxRetryAttempts.from(
      updateProps.maxRetryAttempts,
    );
    if (!maxRetryAttemptsResult.ok) {
      return err(
        withContext(maxRetryAttemptsResult.error, {
          operation: 'update_config_max_retry_attempts_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedMaxRetryAttempts: updateProps.maxRetryAttempts,
        }),
      );
    }
    validatedFields.maxRetryAttempts = maxRetryAttemptsResult.value;
  }

  // Validate retryBackoffSeconds if provided
  if (updateProps.retryBackoffSeconds !== undefined) {
    const retryBackoffSecondsResult = ConfigRetryBackoffSeconds.from(
      updateProps.retryBackoffSeconds,
    );
    if (!retryBackoffSecondsResult.ok) {
      return err(
        withContext(retryBackoffSecondsResult.error, {
          operation: 'update_config_retry_backoff_seconds_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedRetryBackoffSeconds: updateProps.retryBackoffSeconds,
        }),
      );
    }
    validatedFields.retryBackoffSeconds = retryBackoffSecondsResult.value;
  }

  // Validate retryStrategy if provided
  if (updateProps.retryStrategy !== undefined) {
    const retryStrategyResult = createConfigRetryStrategy(
      updateProps.retryStrategy,
    );
    if (!retryStrategyResult.ok) {
      return err(
        withContext(retryStrategyResult.error, {
          operation: 'update_config_retry_strategy_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedRetryStrategy: updateProps.retryStrategy,
        }),
      );
    }
    validatedFields.retryStrategy = retryStrategyResult.value;
  }

  // Validate backoffJitterPct if provided
  if (updateProps.backoffJitterPct !== undefined) {
    const backoffJitterPctResult = ConfigBackoffJitterPct.from(
      updateProps.backoffJitterPct,
    );
    if (!backoffJitterPctResult.ok) {
      return err(
        withContext(backoffJitterPctResult.error, {
          operation: 'update_config_backoff_jitter_pct_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedBackoffJitterPct: updateProps.backoffJitterPct,
        }),
      );
    }
    validatedFields.backoffJitterPct = backoffJitterPctResult.value;
  }

  // Validate requestTimeoutMs if provided
  if (updateProps.requestTimeoutMs !== undefined) {
    const requestTimeoutMsResult = ConfigRequestTimeoutMs.from(
      updateProps.requestTimeoutMs,
    );
    if (!requestTimeoutMsResult.ok) {
      return err(
        withContext(requestTimeoutMsResult.error, {
          operation: 'update_config_request_timeout_ms_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedRequestTimeoutMs: updateProps.requestTimeoutMs,
        }),
      );
    }
    validatedFields.requestTimeoutMs = requestTimeoutMsResult.value;
  }

  // Validate connectTimeoutMs if provided
  if (updateProps.connectTimeoutMs !== undefined) {
    const connectTimeoutMsResult = ConfigConnectTimeoutMs.from(
      updateProps.connectTimeoutMs,
    );
    if (!connectTimeoutMsResult.ok) {
      return err(
        withContext(connectTimeoutMsResult.error, {
          operation: 'update_config_connect_timeout_ms_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedConnectTimeoutMs: updateProps.connectTimeoutMs,
        }),
      );
    }
    validatedFields.connectTimeoutMs = connectTimeoutMsResult.value;
  }

  // Validate signatureAlgorithm if provided
  if (updateProps.signatureAlgorithm !== undefined) {
    const signatureAlgorithmResult = createConfigSignatureAlgorithm(
      updateProps.signatureAlgorithm,
    );
    if (!signatureAlgorithmResult.ok) {
      return err(
        withContext(signatureAlgorithmResult.error, {
          operation: 'update_config_signature_algorithm_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedSignatureAlgorithm: updateProps.signatureAlgorithm,
        }),
      );
    }
    validatedFields.signatureAlgorithm = signatureAlgorithmResult.value;
  }

  // Validate includeTimestampHeader if provided
  if (updateProps.includeTimestampHeader !== undefined) {
    const includeTimestampHeaderResult = ConfigIncludeTimestampHeader.from(
      updateProps.includeTimestampHeader,
    );
    if (!includeTimestampHeaderResult.ok) {
      return err(
        withContext(includeTimestampHeaderResult.error, {
          operation: 'update_config_include_timestamp_header_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedIncludeTimestampHeader: updateProps.includeTimestampHeader,
        }),
      );
    }
    validatedFields.includeTimestampHeader = includeTimestampHeaderResult.value;
  }

  // Validate maxConcurrent if provided
  if (updateProps.maxConcurrent !== undefined) {
    const maxConcurrentResult = ConfigMaxConcurrent.from(
      updateProps.maxConcurrent,
    );
    if (!maxConcurrentResult.ok) {
      return err(
        withContext(maxConcurrentResult.error, {
          operation: 'update_config_max_concurrent_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedMaxConcurrent: updateProps.maxConcurrent,
        }),
      );
    }
    validatedFields.maxConcurrent = maxConcurrentResult.value;
  }

  // Validate dlqEnabled if provided
  if (updateProps.dlqEnabled !== undefined) {
    const dlqEnabledResult = ConfigDlqEnabled.from(updateProps.dlqEnabled);
    if (!dlqEnabledResult.ok) {
      return err(
        withContext(dlqEnabledResult.error, {
          operation: 'update_config_dlq_enabled_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedDlqEnabled: updateProps.dlqEnabled,
        }),
      );
    }
    validatedFields.dlqEnabled = dlqEnabledResult.value;
  }

  // Validate dlqMaxAgeSeconds if provided
  if (updateProps.dlqMaxAgeSeconds !== undefined) {
    const dlqMaxAgeSecondsResult = ConfigDlqMaxAgeSeconds.from(
      updateProps.dlqMaxAgeSeconds,
    );
    if (!dlqMaxAgeSecondsResult.ok) {
      return err(
        withContext(dlqMaxAgeSecondsResult.error, {
          operation: 'update_config_dlq_max_age_seconds_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedDlqMaxAgeSeconds: updateProps.dlqMaxAgeSeconds,
        }),
      );
    }
    validatedFields.dlqMaxAgeSeconds = dlqMaxAgeSecondsResult.value;
  }

  // Validate ordering if provided
  if (updateProps.ordering !== undefined) {
    const orderingResult = createConfigOrdering(updateProps.ordering);
    if (!orderingResult.ok) {
      return err(
        withContext(orderingResult.error, {
          operation: 'update_config_ordering_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedOrdering: updateProps.ordering,
        }),
      );
    }
    validatedFields.ordering = orderingResult.value;
  }

  // Validate defaultLocale if provided
  if (updateProps.defaultLocale !== undefined) {
    const defaultLocaleResult = ConfigDefaultLocale.from(
      updateProps.defaultLocale,
    );
    if (!defaultLocaleResult.ok) {
      return err(
        withContext(defaultLocaleResult.error, {
          operation: 'update_config_default_locale_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedDefaultLocale: updateProps.defaultLocale,
        }),
      );
    }
    validatedFields.defaultLocale = defaultLocaleResult.value;
  }

  // Validate metadata if provided
  if (updateProps.metadata !== undefined) {
    const metadataResult = ConfigMetadata.from(updateProps.metadata);
    if (!metadataResult.ok) {
      return err(
        withContext(metadataResult.error, {
          operation: 'update_config_metadata_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedMetadata: updateProps.metadata,
        }),
      );
    }
    validatedFields.metadata = metadataResult.value;
  }

  // 3. Apply all validated changes in single atomic operation
  const batchUpdateResult = existingAggregate.updateBatch(validatedFields);
  if (!batchUpdateResult.ok) {
    return err(
      withContext(batchUpdateResult.error, {
        operation: 'update_product_batch_application',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        fieldsUpdated: Object.keys(validatedFields),
      }),
    );
  }

  return ok(existingAggregate);
}
