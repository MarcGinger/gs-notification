// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, withContext, ok } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { ConfigAggregate } from '../aggregates';
import { CreateConfigProps } from '../props';
import { ConfigDomainState } from '../state';
import {
  ConfigCreatedAt,
  ConfigUpdatedAt,
  ConfigVersion,
  ConfigWebhookId,
  createConfigStrategy,
  ConfigMaxRetryAttempts,
  ConfigRetryBackoffSeconds,
  createConfigRetryStrategy,
  ConfigBackoffJitterPct,
  ConfigRequestTimeoutMs,
  ConfigConnectTimeoutMs,
  createConfigSignatureAlgorithm,
  ConfigIncludeTimestampHeader,
  ConfigMaxConcurrent,
  ConfigDlqEnabled,
  ConfigDlqMaxAgeSeconds,
  createConfigOrdering,
  ConfigDefaultLocale,
  ConfigMetadata,
} from '../value-objects';

/**
 * Enhanced config entity factory with comprehensive validation and security context
 * Moved from application layer to properly separate business concerns
 */
export function createConfigAggregateFromProps(
  props: CreateConfigProps,
  metadata: EventMetadata,
  clock: Clock,
  // validatedEntities?: {
  //  channels?: ChannelReference[];
  // },
): Result<ConfigAggregate, DomainError> {
  // Validate each property by creating value objects
  const webhookIdResult = ConfigWebhookId.from(props.webhookId);
  if (!webhookIdResult.ok) {
    return err(
      withContext(webhookIdResult.error, {
        ...webhookIdResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        webhookId: props.webhookId,
      }),
    );
  }

  const strategyResult = createConfigStrategy(props.strategy);
  if (!strategyResult.ok) {
    return err(
      withContext(strategyResult.error, {
        ...strategyResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        strategy: props.strategy,
      }),
    );
  }

  const maxRetryAttemptsResult = ConfigMaxRetryAttempts.from(
    props.maxRetryAttempts,
  );
  if (!maxRetryAttemptsResult.ok) {
    return err(
      withContext(maxRetryAttemptsResult.error, {
        ...maxRetryAttemptsResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        maxRetryAttempts: props.maxRetryAttempts,
      }),
    );
  }

  const retryBackoffSecondsResult = ConfigRetryBackoffSeconds.from(
    props.retryBackoffSeconds,
  );
  if (!retryBackoffSecondsResult.ok) {
    return err(
      withContext(retryBackoffSecondsResult.error, {
        ...retryBackoffSecondsResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        retryBackoffSeconds: props.retryBackoffSeconds,
      }),
    );
  }

  const retryStrategyResult = createConfigRetryStrategy(props.retryStrategy);
  if (!retryStrategyResult.ok) {
    return err(
      withContext(retryStrategyResult.error, {
        ...retryStrategyResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        retryStrategy: props.retryStrategy,
      }),
    );
  }

  const backoffJitterPctResult = ConfigBackoffJitterPct.from(
    props.backoffJitterPct,
  );
  if (!backoffJitterPctResult.ok) {
    return err(
      withContext(backoffJitterPctResult.error, {
        ...backoffJitterPctResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        backoffJitterPct: props.backoffJitterPct,
      }),
    );
  }

  const requestTimeoutMsResult = ConfigRequestTimeoutMs.from(
    props.requestTimeoutMs,
  );
  if (!requestTimeoutMsResult.ok) {
    return err(
      withContext(requestTimeoutMsResult.error, {
        ...requestTimeoutMsResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        requestTimeoutMs: props.requestTimeoutMs,
      }),
    );
  }

  const connectTimeoutMsResult = ConfigConnectTimeoutMs.from(
    props.connectTimeoutMs,
  );
  if (!connectTimeoutMsResult.ok) {
    return err(
      withContext(connectTimeoutMsResult.error, {
        ...connectTimeoutMsResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        connectTimeoutMs: props.connectTimeoutMs,
      }),
    );
  }

  const signatureAlgorithmResult = createConfigSignatureAlgorithm(
    props.signatureAlgorithm,
  );
  if (!signatureAlgorithmResult.ok) {
    return err(
      withContext(signatureAlgorithmResult.error, {
        ...signatureAlgorithmResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        signatureAlgorithm: props.signatureAlgorithm,
      }),
    );
  }

  const includeTimestampHeaderResult = ConfigIncludeTimestampHeader.from(
    props.includeTimestampHeader,
  );
  if (!includeTimestampHeaderResult.ok) {
    return err(
      withContext(includeTimestampHeaderResult.error, {
        ...includeTimestampHeaderResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        includeTimestampHeader: props.includeTimestampHeader,
      }),
    );
  }

  const maxConcurrentResult = ConfigMaxConcurrent.from(props.maxConcurrent);
  if (!maxConcurrentResult.ok) {
    return err(
      withContext(maxConcurrentResult.error, {
        ...maxConcurrentResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        maxConcurrent: props.maxConcurrent,
      }),
    );
  }

  const dlqEnabledResult = ConfigDlqEnabled.from(props.dlqEnabled);
  if (!dlqEnabledResult.ok) {
    return err(
      withContext(dlqEnabledResult.error, {
        ...dlqEnabledResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        dlqEnabled: props.dlqEnabled,
      }),
    );
  }

  const dlqMaxAgeSecondsResult = ConfigDlqMaxAgeSeconds.from(
    props.dlqMaxAgeSeconds,
  );
  if (!dlqMaxAgeSecondsResult.ok) {
    return err(
      withContext(dlqMaxAgeSecondsResult.error, {
        ...dlqMaxAgeSecondsResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        dlqMaxAgeSeconds: props.dlqMaxAgeSeconds,
      }),
    );
  }

  const orderingResult = createConfigOrdering(props.ordering);
  if (!orderingResult.ok) {
    return err(
      withContext(orderingResult.error, {
        ...orderingResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        ordering: props.ordering,
      }),
    );
  }

  const defaultLocaleResult = ConfigDefaultLocale.from(props.defaultLocale);
  if (!defaultLocaleResult.ok) {
    return err(
      withContext(defaultLocaleResult.error, {
        ...defaultLocaleResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        defaultLocale: props.defaultLocale,
      }),
    );
  }

  const metadataResult = ConfigMetadata.from(props.metadata);
  if (!metadataResult.ok) {
    return err(
      withContext(metadataResult.error, {
        ...metadataResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_config',
        metadata: props.metadata,
      }),
    );
  }

  const createdAtResult = ConfigCreatedAt.create(clock.now());
  if (!createdAtResult.ok) {
    return err(createdAtResult.error);
  }

  const updatedAtResult = ConfigUpdatedAt.create(clock.now());
  if (!updatedAtResult.ok) {
    return err(updatedAtResult.error);
  }

  const versionResult = ConfigVersion.create(1); // Initial version is 1
  if (!versionResult.ok) {
    return err(versionResult.error);
  }

  // Create the entity properties with validated value objects
  const entityProps: ConfigDomainState = {
    webhookId: webhookIdResult.value,
    strategy: strategyResult.value,
    maxRetryAttempts: maxRetryAttemptsResult.value,
    retryBackoffSeconds: retryBackoffSecondsResult.value,
    retryStrategy: retryStrategyResult.value,
    backoffJitterPct: backoffJitterPctResult.value,
    requestTimeoutMs: requestTimeoutMsResult.value,
    connectTimeoutMs: connectTimeoutMsResult.value,
    signatureAlgorithm: signatureAlgorithmResult.value,
    includeTimestampHeader: includeTimestampHeaderResult.value,
    maxConcurrent: maxConcurrentResult.value,
    dlqEnabled: dlqEnabledResult.value,
    dlqMaxAgeSeconds: dlqMaxAgeSecondsResult.value,
    ordering: orderingResult.value,
    defaultLocale: defaultLocaleResult.value,
    metadata: metadataResult.value,
    createdAt: createdAtResult.value,
    updatedAt: updatedAtResult.value,
    version: versionResult.value,
  };

  // Create the entity using the constructor
  return ConfigAggregate.create(entityProps, clock, metadata);
}
