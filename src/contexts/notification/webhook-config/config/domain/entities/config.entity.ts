// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { EntityIdBase } from 'src/shared/domain/entities';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { ConfigSnapshotProps } from '../props';
import { ConfigDomainState } from '../state';
import { ConfigErrors } from '../errors/config.errors';
import {
  ConfigBackoffJitterPct,
  ConfigConnectTimeoutMs,
  ConfigCreatedAt,
  ConfigUpdatedAt,
  ConfigVersion,
  ConfigDefaultLocale,
  ConfigDlqEnabled,
  ConfigDlqMaxAgeSeconds,
  ConfigIncludeTimestampHeader,
  ConfigMaxConcurrent,
  ConfigMaxRetryAttempts,
  ConfigMetadata,
  ConfigOrdering,
  ConfigOrderingLogic,
  ConfigRateLimitPerMinute,
  ConfigRequestTimeoutMs,
  ConfigRetryBackoffSeconds,
  ConfigRetryStrategy,
  ConfigRetryStrategyLogic,
  ConfigSignatureAlgorithm,
  ConfigSignatureAlgorithmLogic,
  ConfigWebhookId,
  createConfigOrdering,
  createConfigRetryStrategy,
  createConfigSignatureAlgorithm,
} from '../value-objects';

/**
 * Domain Entity: Config
 *
 * Represents the core Config entity in the notification domain.
 * Encapsulates config data, identity, and basic entity behavior.
 *
 * This entity follows DDD principles:
 * - Identity: WebhookId as unique identifier
 * - Immutability: Changes create new instances
 * - Encapsulation: Private state with controlled access
 * - Business validation: Domain rules enforced
 *
 * @domain Notification Context - Config Entity
 * @layer Domain Entities
 */

/**
 * Config Entity
 *
 * Core domain entity representing a config in the notification.
 * Handles config identity, validation, and state management.
 */
export class ConfigEntity extends EntityIdBase<
  ConfigDomainState,
  ConfigWebhookId
> {
  private static clock: { now: () => Date } = { now: () => new Date() };

  public static setClock(c: { now: () => Date }) {
    this.clock = c;
  }

  /**
   * Helper method to create updatedAt VO from date
   */
  private static createUpdatedAt(
    date?: Date,
  ): Result<ConfigUpdatedAt, DomainError> {
    const targetDate = date || ConfigEntity.clock.now();
    const result = ConfigUpdatedAt.from(targetDate);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create version VO from number
   */
  private static createVersion(
    versionNumber?: number,
    currentVersion?: ConfigVersion,
  ): Result<ConfigVersion, DomainError> {
    const targetVersion = versionNumber ?? currentVersion?.value ?? 1;
    const result = ConfigVersion.from(targetVersion);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create updated entity with common logic
   */
  private createUpdatedEntity(
    fieldUpdates: Partial<ConfigDomainState>,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    const updatedAtResult = ConfigEntity.createUpdatedAt(updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = ConfigEntity.createVersion(
      version,
      this.props.version,
    );
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const updatedProps: ConfigDomainState = {
      ...this.props,
      ...fieldUpdates,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return ConfigEntity.create(updatedProps);
  }

  private constructor(props: ConfigDomainState) {
    super(props, props.webhookId);
  }

  /**
   * Factory method to create a new config entity
   *
   * @param props - Config properties
   * @returns Result containing ConfigEntity or DomainError
   */
  public static create(
    props: ConfigDomainState,
  ): Result<ConfigEntity, DomainError> {
    // Validate required properties
    const validationResult = ConfigEntity.validate(props);
    if (validationResult.ok === false) {
      return err(validationResult.error);
    }

    return ok(new ConfigEntity(props));
  }

  /**
   * Factory method to reconstitute a config entity from persistence
   *
   * @param props - Config properties from database
   * @returns ConfigEntity instance
   */
  public static reconstitute(props: ConfigDomainState): ConfigEntity {
    return new ConfigEntity(props);
  }

  /**
   * Factory method to reconstitute entity from snapshot
   *
   * @param snapshot - Config snapshot properties
   * @returns Result containing ConfigEntity or DomainError
   */
  public static fromSnapshot(
    snapshot: ConfigSnapshotProps,
  ): Result<ConfigEntity, DomainError> {
    const webhookIdResult = ConfigWebhookId.from(snapshot.webhookId);
    if (!webhookIdResult.ok) {
      return err(webhookIdResult.error);
    }
    const rateLimitPerMinuteResult = ConfigRateLimitPerMinute.from(
      snapshot.rateLimitPerMinute,
    );
    if (!rateLimitPerMinuteResult.ok) {
      return err(rateLimitPerMinuteResult.error);
    }
    const maxRetryAttemptsResult = ConfigMaxRetryAttempts.from(
      snapshot.maxRetryAttempts,
    );
    if (!maxRetryAttemptsResult.ok) {
      return err(maxRetryAttemptsResult.error);
    }
    const retryBackoffSecondsResult = ConfigRetryBackoffSeconds.from(
      snapshot.retryBackoffSeconds,
    );
    if (!retryBackoffSecondsResult.ok) {
      return err(retryBackoffSecondsResult.error);
    }
    const retryStrategyResult = createConfigRetryStrategy(
      snapshot.retryStrategy,
    );
    if (!retryStrategyResult.ok) {
      return err(retryStrategyResult.error);
    }
    const backoffJitterPctResult = ConfigBackoffJitterPct.from(
      snapshot.backoffJitterPct,
    );
    if (!backoffJitterPctResult.ok) {
      return err(backoffJitterPctResult.error);
    }
    const requestTimeoutMsResult = ConfigRequestTimeoutMs.from(
      snapshot.requestTimeoutMs,
    );
    if (!requestTimeoutMsResult.ok) {
      return err(requestTimeoutMsResult.error);
    }
    const connectTimeoutMsResult = ConfigConnectTimeoutMs.from(
      snapshot.connectTimeoutMs,
    );
    if (!connectTimeoutMsResult.ok) {
      return err(connectTimeoutMsResult.error);
    }
    const signatureAlgorithmResult = createConfigSignatureAlgorithm(
      snapshot.signatureAlgorithm,
    );
    if (!signatureAlgorithmResult.ok) {
      return err(signatureAlgorithmResult.error);
    }
    const includeTimestampHeaderResult = ConfigIncludeTimestampHeader.from(
      snapshot.includeTimestampHeader,
    );
    if (!includeTimestampHeaderResult.ok) {
      return err(includeTimestampHeaderResult.error);
    }
    const maxConcurrentResult = ConfigMaxConcurrent.from(
      snapshot.maxConcurrent,
    );
    if (!maxConcurrentResult.ok) {
      return err(maxConcurrentResult.error);
    }
    const dlqEnabledResult = ConfigDlqEnabled.from(snapshot.dlqEnabled);
    if (!dlqEnabledResult.ok) {
      return err(dlqEnabledResult.error);
    }
    const dlqMaxAgeSecondsResult = ConfigDlqMaxAgeSeconds.from(
      snapshot.dlqMaxAgeSeconds,
    );
    if (!dlqMaxAgeSecondsResult.ok) {
      return err(dlqMaxAgeSecondsResult.error);
    }
    const orderingResult = createConfigOrdering(snapshot.ordering);
    if (!orderingResult.ok) {
      return err(orderingResult.error);
    }
    const defaultLocaleResult = ConfigDefaultLocale.from(
      snapshot.defaultLocale,
    );
    if (!defaultLocaleResult.ok) {
      return err(defaultLocaleResult.error);
    }
    const metadataResult = ConfigMetadata.from(snapshot.metadata);
    if (!metadataResult.ok) {
      return err(metadataResult.error);
    }
    const createdAtResult = ConfigCreatedAt.from(snapshot.createdAt);
    if (!createdAtResult.ok) {
      return err(createdAtResult.error);
    }

    const updatedAtResult = ConfigUpdatedAt.from(snapshot.updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = ConfigVersion.from(snapshot.version);
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const props: ConfigDomainState = {
      webhookId: webhookIdResult.value,
      rateLimitPerMinute: rateLimitPerMinuteResult.value,
      maxRetryAttempts: maxRetryAttemptsResult.value,
      retryBackoffSeconds: retryBackoffSecondsResult.value,
      retryStrategy: retryStrategyResult.value,
      backoffJitterPct: backoffJitterPctResult.value,
      requestTimeoutMs: requestTimeoutMsResult.value,
      connectTimeoutMs: connectTimeoutMsResult.value,
      signatureAlgorithm: signatureAlgorithmResult.value,
      includeTimestampHeader: includeTimestampHeaderResult.value,
      maxConcurrent: maxConcurrentResult.value,
      dlqEnabled: dlqEnabledResult.value,
      dlqMaxAgeSeconds: dlqMaxAgeSecondsResult.value,
      ordering: orderingResult.value,
      defaultLocale: defaultLocaleResult.value,
      metadata: metadataResult.value,
      createdAt: createdAtResult.value,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return ConfigEntity.create(props);
  }

  /**
   * Validates config entity properties
   *
   * @param props - Properties to validate
   * @returns Validation result
   */
  private static validate(props: ConfigDomainState): Result<void, DomainError> {
    // Basic validation
    if (!props.webhookId) {
      return err(ConfigErrors.INVALID_WEBHOOK_ID_DATA);
    }
    if (!props.maxRetryAttempts) {
      return err(ConfigErrors.INVALID_MAX_RETRY_ATTEMPTS_DATA);
    }
    if (!props.retryBackoffSeconds) {
      return err(ConfigErrors.INVALID_RETRY_BACKOFF_SECONDS_DATA);
    }
    if (!props.defaultLocale) {
      return err(ConfigErrors.INVALID_DEFAULT_LOCALE_DATA);
    }

    return ok(undefined);
  }

  // ======================
  // Getters (Public API)
  // ======================

  public get webhookId(): ConfigWebhookId {
    return this.props.webhookId;
  }

  public get rateLimitPerMinute(): ConfigRateLimitPerMinute | undefined {
    return this.props.rateLimitPerMinute;
  }

  public get maxRetryAttempts(): ConfigMaxRetryAttempts {
    return this.props.maxRetryAttempts;
  }

  public get retryBackoffSeconds(): ConfigRetryBackoffSeconds {
    return this.props.retryBackoffSeconds;
  }

  public get retryStrategy(): ConfigRetryStrategy | undefined {
    return this.props.retryStrategy;
  }

  public get backoffJitterPct(): ConfigBackoffJitterPct | undefined {
    return this.props.backoffJitterPct;
  }

  public get requestTimeoutMs(): ConfigRequestTimeoutMs | undefined {
    return this.props.requestTimeoutMs;
  }

  public get connectTimeoutMs(): ConfigConnectTimeoutMs | undefined {
    return this.props.connectTimeoutMs;
  }

  public get signatureAlgorithm(): ConfigSignatureAlgorithm | undefined {
    return this.props.signatureAlgorithm;
  }

  public get includeTimestampHeader():
    | ConfigIncludeTimestampHeader
    | undefined {
    return this.props.includeTimestampHeader;
  }

  public get maxConcurrent(): ConfigMaxConcurrent | undefined {
    return this.props.maxConcurrent;
  }

  public get dlqEnabled(): ConfigDlqEnabled | undefined {
    return this.props.dlqEnabled;
  }

  public get dlqMaxAgeSeconds(): ConfigDlqMaxAgeSeconds | undefined {
    return this.props.dlqMaxAgeSeconds;
  }

  public get ordering(): ConfigOrdering | undefined {
    return this.props.ordering;
  }

  public get defaultLocale(): ConfigDefaultLocale {
    return this.props.defaultLocale;
  }

  public get metadata(): ConfigMetadata | undefined {
    return this.props.metadata;
  }

  public get createdAt(): ConfigCreatedAt {
    return this.props.createdAt;
  }

  public get updatedAt(): ConfigUpdatedAt {
    return this.props.updatedAt;
  }

  public get version(): ConfigVersion {
    return this.props.version;
  }

  // ======================
  // Simple Update Methods (No Business Logic)
  // ======================

  /**
   * Creates a new entity with updated rateLimitPerMinute (pure state transition)
   *
   * @param rateLimitPerMinute - New rateLimitPerMinute value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withRateLimitPerMinute(
    rateLimitPerMinute: ConfigRateLimitPerMinute,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ rateLimitPerMinute }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated maxRetryAttempts (pure state transition)
   *
   * @param maxRetryAttempts - New maxRetryAttempts value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withMaxRetryAttempts(
    maxRetryAttempts: ConfigMaxRetryAttempts,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ maxRetryAttempts }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated retryBackoffSeconds (pure state transition)
   *
   * @param retryBackoffSeconds - New retryBackoffSeconds value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withRetryBackoffSeconds(
    retryBackoffSeconds: ConfigRetryBackoffSeconds,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity(
      { retryBackoffSeconds },
      updatedAt,
      version,
    );
  }

  /**
   * Creates a new entity with updated retryStrategy (with basic transition validation)
   *
   * @param retryStrategy - New retryStrategy value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withRetryStrategy(
    retryStrategy: ConfigRetryStrategy,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    if (this.props.retryStrategy) {
      // If current status exists, validate transition
      const currentStatus = this.props.retryStrategy.value;
      const targetStatus = retryStrategy.value;

      if (
        !ConfigRetryStrategyLogic.canTransition(currentStatus, targetStatus)
      ) {
        return err({
          ...ConfigErrors.INVALID_RETRY_STRATEGY_TRANSITION,
          context: {
            currentStatus,
            targetStatus,
            validTransitions:
              ConfigRetryStrategyLogic.getValidTransitions(currentStatus),
          },
        });
      }
    }

    return this.createUpdatedEntity({ retryStrategy }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated backoffJitterPct (pure state transition)
   *
   * @param backoffJitterPct - New backoffJitterPct value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withBackoffJitterPct(
    backoffJitterPct: ConfigBackoffJitterPct,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ backoffJitterPct }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated requestTimeoutMs (pure state transition)
   *
   * @param requestTimeoutMs - New requestTimeoutMs value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withRequestTimeoutMs(
    requestTimeoutMs: ConfigRequestTimeoutMs,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ requestTimeoutMs }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated connectTimeoutMs (pure state transition)
   *
   * @param connectTimeoutMs - New connectTimeoutMs value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withConnectTimeoutMs(
    connectTimeoutMs: ConfigConnectTimeoutMs,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ connectTimeoutMs }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated signatureAlgorithm (with basic transition validation)
   *
   * @param signatureAlgorithm - New signatureAlgorithm value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withSignatureAlgorithm(
    signatureAlgorithm: ConfigSignatureAlgorithm,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    if (this.props.signatureAlgorithm) {
      // If current status exists, validate transition
      const currentStatus = this.props.signatureAlgorithm.value;
      const targetStatus = signatureAlgorithm.value;

      if (
        !ConfigSignatureAlgorithmLogic.canTransition(
          currentStatus,
          targetStatus,
        )
      ) {
        return err({
          ...ConfigErrors.INVALID_SIGNATURE_ALGORITHM_TRANSITION,
          context: {
            currentStatus,
            targetStatus,
            validTransitions:
              ConfigSignatureAlgorithmLogic.getValidTransitions(currentStatus),
          },
        });
      }
    }

    return this.createUpdatedEntity({ signatureAlgorithm }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated includeTimestampHeader (pure state transition)
   *
   * @param includeTimestampHeader - New includeTimestampHeader value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withIncludeTimestampHeader(
    includeTimestampHeader: ConfigIncludeTimestampHeader,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity(
      { includeTimestampHeader },
      updatedAt,
      version,
    );
  }

  /**
   * Creates a new entity with updated maxConcurrent (pure state transition)
   *
   * @param maxConcurrent - New maxConcurrent value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withMaxConcurrent(
    maxConcurrent: ConfigMaxConcurrent,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ maxConcurrent }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated dlqEnabled (pure state transition)
   *
   * @param dlqEnabled - New dlqEnabled value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withDlqEnabled(
    dlqEnabled: ConfigDlqEnabled,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ dlqEnabled }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated dlqMaxAgeSeconds (pure state transition)
   *
   * @param dlqMaxAgeSeconds - New dlqMaxAgeSeconds value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withDlqMaxAgeSeconds(
    dlqMaxAgeSeconds: ConfigDlqMaxAgeSeconds,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ dlqMaxAgeSeconds }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated ordering (with basic transition validation)
   *
   * @param ordering - New ordering value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withOrdering(
    ordering: ConfigOrdering,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    if (this.props.ordering) {
      // If current status exists, validate transition
      const currentStatus = this.props.ordering.value;
      const targetStatus = ordering.value;

      if (!ConfigOrderingLogic.canTransition(currentStatus, targetStatus)) {
        return err({
          ...ConfigErrors.INVALID_ORDERING_TRANSITION,
          context: {
            currentStatus,
            targetStatus,
            validTransitions:
              ConfigOrderingLogic.getValidTransitions(currentStatus),
          },
        });
      }
    }

    return this.createUpdatedEntity({ ordering }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated defaultLocale (pure state transition)
   *
   * @param defaultLocale - New defaultLocale value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withDefaultLocale(
    defaultLocale: ConfigDefaultLocale,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ defaultLocale }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated metadata (pure state transition)
   *
   * @param metadata - New metadata value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withMetadata(
    metadata: ConfigMetadata,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ metadata }, updatedAt, version);
  }

  // ======================
  // Query Methods
  // ======================

  /**
   * Checks if two configs are the same entity
   *
   * @param other - Other config to compare
   */
  public sameAs(other: ConfigEntity): boolean {
    return this.props.webhookId.equals(other.props.webhookId);
  }

  /**
   * Gets a snapshot of current entity state for serialization
   */
  public toSnapshot(): ConfigSnapshotProps {
    return {
      webhookId: this.props.webhookId.value,
      rateLimitPerMinute: this.props.rateLimitPerMinute?.value,
      maxRetryAttempts: this.props.maxRetryAttempts.value,
      retryBackoffSeconds: this.props.retryBackoffSeconds.value,
      retryStrategy: this.props.retryStrategy?.value,
      backoffJitterPct: this.props.backoffJitterPct?.value,
      requestTimeoutMs: this.props.requestTimeoutMs?.value,
      connectTimeoutMs: this.props.connectTimeoutMs?.value,
      signatureAlgorithm: this.props.signatureAlgorithm?.value,
      includeTimestampHeader: this.props.includeTimestampHeader?.value,
      maxConcurrent: this.props.maxConcurrent?.value,
      dlqEnabled: this.props.dlqEnabled?.value,
      dlqMaxAgeSeconds: this.props.dlqMaxAgeSeconds?.value,
      ordering: this.props.ordering?.value,
      defaultLocale: this.props.defaultLocale.value,
      metadata: this.props.metadata?.value,
      createdAt: this.props.createdAt.value,
      updatedAt: this.props.updatedAt.value,
      version: this.props.version.value,
    };
  }

  /**
   * Gets the current domain state with value objects
   *
   * Provides access to the rich domain state for application layer
   * without requiring infrastructure mappers. Maintains clean architecture.
   *
   * @returns Current domain state with value objects
   */
  public getDomainState(): ConfigDomainState {
    return this.props;
  }
}
