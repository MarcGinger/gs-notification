// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { EntityIdBase } from 'src/shared/domain/entities';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { ConfigSnapshotProps } from '../props';
import { ConfigDomainState } from '../state';
import { ConfigErrors } from '../errors/config.errors';
import {
  ConfigCreatedAt,
  ConfigUpdatedAt,
  ConfigVersion,
  ConfigDefaultLocale,
  ConfigMaxRetryAttempts,
  ConfigMetadata,
  ConfigRetryBackoffSeconds,
  ConfigStrategy,
  ConfigStrategyLogic,
  ConfigWebhookId,
  createConfigStrategy,
} from '../value-objects';

/**
 * Domain Entity: Config
 *
 * Represents the core Config entity in the notification domain.
 * Encapsulates config data, identity, and basic entity behavior.
 *
 * This entity follows DDD principles:
 * - Identity: WebhookId as unique identifier
 * - Immutability: Changes create new instances
 * - Encapsulation: Private state with controlled access
 * - Business validation: Domain rules enforced
 *
 * @domain Notification Context - Config Entity
 * @layer Domain Entities
 */

/**
 * Config Entity
 *
 * Core domain entity representing a config in the notification.
 * Handles config identity, validation, and state management.
 */
export class ConfigEntity extends EntityIdBase<
  ConfigDomainState,
  ConfigWebhookId
> {
  private static clock: { now: () => Date } = { now: () => new Date() };

  public static setClock(c: { now: () => Date }) {
    this.clock = c;
  }

  /**
   * Helper method to create updatedAt VO from date
   */
  private static createUpdatedAt(
    date?: Date,
  ): Result<ConfigUpdatedAt, DomainError> {
    const targetDate = date || ConfigEntity.clock.now();
    const result = ConfigUpdatedAt.from(targetDate);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create version VO from number
   */
  private static createVersion(
    versionNumber?: number,
    currentVersion?: ConfigVersion,
  ): Result<ConfigVersion, DomainError> {
    const targetVersion = versionNumber ?? currentVersion?.value ?? 1;
    const result = ConfigVersion.from(targetVersion);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create updated entity with common logic
   */
  private createUpdatedEntity(
    fieldUpdates: Partial<ConfigDomainState>,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    const updatedAtResult = ConfigEntity.createUpdatedAt(updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = ConfigEntity.createVersion(
      version,
      this.props.version,
    );
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const updatedProps: ConfigDomainState = {
      ...this.props,
      ...fieldUpdates,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return ConfigEntity.create(updatedProps);
  }

  private constructor(props: ConfigDomainState) {
    super(props, props.webhookId);
  }

  /**
   * Factory method to create a new config entity
   *
   * @param props - Config properties
   * @returns Result containing ConfigEntity or DomainError
   */
  public static create(
    props: ConfigDomainState,
  ): Result<ConfigEntity, DomainError> {
    // Validate required properties
    const validationResult = ConfigEntity.validate(props);
    if (validationResult.ok === false) {
      return err(validationResult.error);
    }

    return ok(new ConfigEntity(props));
  }

  /**
   * Factory method to reconstitute a config entity from persistence
   *
   * @param props - Config properties from database
   * @returns ConfigEntity instance
   */
  public static reconstitute(props: ConfigDomainState): ConfigEntity {
    return new ConfigEntity(props);
  }

  /**
   * Factory method to reconstitute entity from snapshot
   *
   * @param snapshot - Config snapshot properties
   * @returns Result containing ConfigEntity or DomainError
   */
  public static fromSnapshot(
    snapshot: ConfigSnapshotProps,
  ): Result<ConfigEntity, DomainError> {
    const webhookIdResult = ConfigWebhookId.from(snapshot.webhookId);
    if (!webhookIdResult.ok) {
      return err(webhookIdResult.error);
    }
    const maxRetryAttemptsResult = ConfigMaxRetryAttempts.from(
      snapshot.maxRetryAttempts,
    );
    if (!maxRetryAttemptsResult.ok) {
      return err(maxRetryAttemptsResult.error);
    }
    const retryBackoffSecondsResult = ConfigRetryBackoffSeconds.from(
      snapshot.retryBackoffSeconds,
    );
    if (!retryBackoffSecondsResult.ok) {
      return err(retryBackoffSecondsResult.error);
    }
    const defaultLocaleResult = ConfigDefaultLocale.from(
      snapshot.defaultLocale,
    );
    if (!defaultLocaleResult.ok) {
      return err(defaultLocaleResult.error);
    }
    const strategyResult = createConfigStrategy(snapshot.strategy);
    if (!strategyResult.ok) {
      return err(strategyResult.error);
    }
    const metadataResult = ConfigMetadata.from(snapshot.metadata);
    if (!metadataResult.ok) {
      return err(metadataResult.error);
    }
    const createdAtResult = ConfigCreatedAt.from(snapshot.createdAt);
    if (!createdAtResult.ok) {
      return err(createdAtResult.error);
    }

    const updatedAtResult = ConfigUpdatedAt.from(snapshot.updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = ConfigVersion.from(snapshot.version);
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const props: ConfigDomainState = {
      webhookId: webhookIdResult.value,
      maxRetryAttempts: maxRetryAttemptsResult.value,
      retryBackoffSeconds: retryBackoffSecondsResult.value,
      defaultLocale: defaultLocaleResult.value,
      strategy: strategyResult.value,
      metadata: metadataResult.value,
      createdAt: createdAtResult.value,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return ConfigEntity.create(props);
  }

  /**
   * Validates config entity properties
   *
   * @param props - Properties to validate
   * @returns Validation result
   */
  private static validate(props: ConfigDomainState): Result<void, DomainError> {
    // Basic validation
    if (!props.webhookId) {
      return err(ConfigErrors.INVALID_WEBHOOK_ID_DATA);
    }
    if (!props.maxRetryAttempts) {
      return err(ConfigErrors.INVALID_MAX_RETRY_ATTEMPTS_DATA);
    }
    if (!props.retryBackoffSeconds) {
      return err(ConfigErrors.INVALID_RETRY_BACKOFF_SECONDS_DATA);
    }
    if (!props.defaultLocale) {
      return err(ConfigErrors.INVALID_DEFAULT_LOCALE_DATA);
    }
    if (!props.strategy) {
      return err(ConfigErrors.INVALID_STRATEGY_DATA);
    }

    return ok(undefined);
  }

  // ======================
  // Getters (Public API)
  // ======================

  public get webhookId(): ConfigWebhookId {
    return this.props.webhookId;
  }

  public get maxRetryAttempts(): ConfigMaxRetryAttempts {
    return this.props.maxRetryAttempts;
  }

  public get retryBackoffSeconds(): ConfigRetryBackoffSeconds {
    return this.props.retryBackoffSeconds;
  }

  public get defaultLocale(): ConfigDefaultLocale {
    return this.props.defaultLocale;
  }

  public get strategy(): ConfigStrategy {
    return this.props.strategy;
  }

  public get metadata(): ConfigMetadata | undefined {
    return this.props.metadata;
  }

  public get createdAt(): ConfigCreatedAt {
    return this.props.createdAt;
  }

  public get updatedAt(): ConfigUpdatedAt {
    return this.props.updatedAt;
  }

  public get version(): ConfigVersion {
    return this.props.version;
  }

  // ======================
  // Simple Update Methods (No Business Logic)
  // ======================

  /**
   * Creates a new entity with updated maxRetryAttempts (pure state transition)
   *
   * @param maxRetryAttempts - New max_retry_attempts value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withMaxRetryAttempts(
    maxRetryAttempts: ConfigMaxRetryAttempts,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ maxRetryAttempts }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated retryBackoffSeconds (pure state transition)
   *
   * @param retryBackoffSeconds - New retry_backoff_seconds value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withRetryBackoffSeconds(
    retryBackoffSeconds: ConfigRetryBackoffSeconds,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity(
      { retryBackoffSeconds },
      updatedAt,
      version,
    );
  }

  /**
   * Creates a new entity with updated defaultLocale (pure state transition)
   *
   * @param defaultLocale - New default_locale value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withDefaultLocale(
    defaultLocale: ConfigDefaultLocale,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ defaultLocale }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated strategy (with basic transition validation)
   *
   * @param strategy - New strategy value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withStrategy(
    strategy: ConfigStrategy,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    const currentStatus = this.props.strategy.value;
    const targetStatus = strategy.value;

    if (!ConfigStrategyLogic.canTransition(currentStatus, targetStatus)) {
      return err({
        ...ConfigErrors.INVALID_STRATEGY_TRANSITION,
        context: {
          currentStatus,
          targetStatus,
          validTransitions:
            ConfigStrategyLogic.getValidTransitions(currentStatus),
        },
      });
    }

    return this.createUpdatedEntity({ strategy }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated metadata (pure state transition)
   *
   * @param metadata - New metadata value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<ConfigEntity, DomainError>
   */
  public withMetadata(
    metadata: ConfigMetadata,
    updatedAt?: Date,
    version?: number,
  ): Result<ConfigEntity, DomainError> {
    return this.createUpdatedEntity({ metadata }, updatedAt, version);
  }

  // ======================
  // Query Methods
  // ======================

  /**
   * Checks if two configs are the same entity
   *
   * @param other - Other config to compare
   */
  public sameAs(other: ConfigEntity): boolean {
    return this.props.webhookId.equals(other.props.webhookId);
  }

  /**
   * Gets a snapshot of current entity state for serialization
   */
  public toSnapshot(): ConfigSnapshotProps {
    return {
      webhookId: this.props.webhookId.value,
      maxRetryAttempts: this.props.maxRetryAttempts.value,
      retryBackoffSeconds: this.props.retryBackoffSeconds.value,
      defaultLocale: this.props.defaultLocale.value,
      strategy: this.props.strategy.value,
      metadata: this.props.metadata?.value,
      createdAt: this.props.createdAt.value,
      updatedAt: this.props.updatedAt.value,
      version: this.props.version.value,
    };
  }

  /**
   * Gets the current domain state with value objects
   *
   * Provides access to the rich domain state for application layer
   * without requiring infrastructure mappers. Maintains clean architecture.
   *
   * @returns Current domain state with value objects
   */
  public getDomainState(): ConfigDomainState {
    return this.props;
  }
}
