// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { AggregateRootBase } from 'src/shared/domain/aggregates';
import { DomainEvent, EventMetadata } from 'src/shared/domain/events';
import { DomainError, Result, ok, err } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { hasValueChanged } from 'src/shared/utilities';
import { ConfigEntity } from '../entities';
import { ConfigSnapshotProps } from '../props';
import { ValidatedConfigUpdateFields } from '../types';
import {
  ConfigId,
  ConfigStrategyValue,
  createConfigStrategy,
  ConfigRetryStrategyValue,
  createConfigRetryStrategy,
  ConfigSignatureAlgorithmValue,
  createConfigSignatureAlgorithm,
  ConfigOrderingValue,
  createConfigOrdering,
  createConfigCreatedAt,
  createConfigUpdatedAt,
  createdAtNow,
  updatedAtNow,
  validateMonotonicTime,
  bumpVersion,
  initialVersion,
  createConfigVersion,
  ConfigVersion,
} from '../value-objects';
import { ConfigCreatedEvent, ConfigUpdatedEvent } from '../events';
import { ConfigErrors } from '../errors';
import { ConfigDomainState } from '../state';

/**
 * Domain Aggregate Root: Config
 *
 * Represents the Config aggregate root in the notification domain.
 * Encapsulates config business logic, state management, and domain invariants.
 *
 * This aggregate follows DDD principles:
 * - Aggregate Root: Central entity that controls access to the aggregate
 * - Consistency Boundary: Ensures all business rules are enforced
 * - Domain Events: Publishes events for state changes
 * - Encapsulation: Private state with controlled access through behavior
 *
 * @domain Notification Context - Config Aggregate
 * @layer Domain Aggregates
 */

/**
 * Config Aggregate Root
 *
 * Central aggregate root that coordinates config business operations.
 * Manages consistency across the aggregate boundary and publishes domain events.
 */
export class ConfigAggregate extends AggregateRootBase {
  private _entity: ConfigEntity;
  private readonly clock: Clock;
  private readonly eventMetadata: EventMetadata;

  private constructor(
    entity: ConfigEntity,
    clock: Clock,
    eventMetadata: EventMetadata,
  ) {
    super();
    this._entity = entity;
    this.clock = clock;
    this.eventMetadata = eventMetadata;
  }

  /**
   * Factory method to create a new Config aggregate
   *
   * @param props - Config entity properties (should include createdAt, version)
   * @param clock - Clock instance for time operations
   * @param eventMetadata - Event metadata for domain events
   * @returns Result containing ConfigAggregate or DomainError
   */
  public static create(
    props: ConfigDomainState,
    clock: Clock,
    eventMetadata: EventMetadata,
  ): Result<ConfigAggregate, DomainError> {
    // Create timestamp VOs for lifecycle fields using Clock injection
    const createdAtResult = props.createdAt
      ? createConfigCreatedAt(props.createdAt.value) // Extract Date from existing VO
      : createdAtNow(clock);

    if (!createdAtResult.ok) {
      return err(createdAtResult.error);
    }

    const updatedAtResult = props.updatedAt
      ? createConfigUpdatedAt(props.updatedAt.value) // Extract Date from existing VO
      : updatedAtNow(clock);

    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    // Validate monotonic time constraint
    const monotonicTimeResult = validateMonotonicTime(
      createdAtResult.value,
      updatedAtResult.value,
    );
    if (!monotonicTimeResult.ok) {
      return err(monotonicTimeResult.error);
    }

    // Create version VO for lifecycle management
    const versionResult =
      props.version !== undefined
        ? ConfigVersion.create(props.version.value) // Extract number from existing VO
        : initialVersion();

    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    // Ensure props have required lifecycle fields with VOs for proper domain state
    const entityProps: ConfigDomainState = {
      ...props,
      createdAt: createdAtResult.value, // Keep as VO
      updatedAt: updatedAtResult.value, // Keep as VO
      version: versionResult.value, // Keep as VO
    };

    // Create the entity first
    const entityResult = ConfigEntity.create(entityProps);
    if (!entityResult.ok) {
      return err(entityResult.error);
    }

    // Create the aggregate
    const aggregate = new ConfigAggregate(
      entityResult.value,
      clock,
      eventMetadata,
    );

    // Create typed ConfigCreatedEvent with only business data
    const createdEvent = ConfigCreatedEvent.create({
      id: entityProps.id.value,
      webhookId: entityProps.webhookId?.value,
      tenantId: entityProps.tenantId.value,
      strategy: entityProps.strategy.value,
      maxRetryAttempts: entityProps.maxRetryAttempts.value,
      retryBackoffSeconds: entityProps.retryBackoffSeconds.value,
      retryStrategy: entityProps.retryStrategy?.value,
      backoffJitterPct: entityProps.backoffJitterPct?.value,
      requestTimeoutMs: entityProps.requestTimeoutMs?.value,
      connectTimeoutMs: entityProps.connectTimeoutMs?.value,
      signatureAlgorithm: entityProps.signatureAlgorithm?.value,
      includeTimestampHeader: entityProps.includeTimestampHeader?.value,
      maxConcurrent: entityProps.maxConcurrent?.value,
      dlqEnabled: entityProps.dlqEnabled?.value,
      dlqMaxAgeSeconds: entityProps.dlqMaxAgeSeconds?.value,
      ordering: entityProps.ordering?.value,
      defaultLocale: entityProps.defaultLocale.value,
      metadata: entityProps.metadata?.value,
    });

    // Apply as domain event with clean business data
    const domainEvent: DomainEvent = {
      type: createdEvent.eventType,
      version: Number(createdEvent.eventVersion),
      occurredAt: clock.now(),
      aggregateId: entityProps.id.value,
      aggregateType: 'Config',
      data: createdEvent.payload,
      metadata: eventMetadata,
    };

    aggregate.apply(domainEvent);

    return ok(aggregate);
  }

  /**
   * Factory method to reconstitute aggregate from persistence
   *
   * @param entity - Reconstituted entity
   * @param clock - Clock instance
   * @param eventMetadata - Event metadata for domain events
   * @returns ConfigAggregate
   */
  public static reconstitute(
    entity: ConfigEntity,
    clock: Clock,
    eventMetadata: EventMetadata,
  ): ConfigAggregate {
    const aggregate = new ConfigAggregate(entity, clock, eventMetadata);
    // Set version based on entity state for proper aggregate versioning
    aggregate._version = entity.version.value;
    return aggregate;
  }
  /**
   * Event handler for domain events
   * Updates aggregate state based on events for proper rehydration
   */
  protected when(event: DomainEvent): void {
    switch (event.type) {
      case 'NotificationWebhookConfigConfigCreated.v1':
      case 'NotificationWebhookConfigConfigUpdated.v1': {
        // Both events now have the same domain shape - simple merge
        const d = event.data as {
          id: string;
          webhookId?: string;
          tenantId: string;
          strategy: ConfigStrategyValue;
          maxRetryAttempts: number;
          retryBackoffSeconds: number;
          retryStrategy?: ConfigRetryStrategyValue;
          backoffJitterPct?: number;
          requestTimeoutMs?: number;
          connectTimeoutMs?: number;
          signatureAlgorithm?: ConfigSignatureAlgorithmValue;
          includeTimestampHeader?: boolean;
          maxConcurrent?: number;
          dlqEnabled?: boolean;
          dlqMaxAgeSeconds?: number;
          ordering?: ConfigOrderingValue;
          defaultLocale: string;
          metadata?: Record<string, unknown>;
        };

        // For event replay, we need to reconstruct the full snapshot
        // Note: credentialsRef is a reference - actual secrets would be retrieved separately
        const currentSnapshot = this._entity?.toSnapshot() || {};

        const entityResult = ConfigEntity.fromSnapshot({
          id: d.id,
          webhookId: d.webhookId,
          tenantId: d.tenantId,
          strategy: d.strategy,
          maxRetryAttempts: d.maxRetryAttempts,
          retryBackoffSeconds: d.retryBackoffSeconds,
          retryStrategy: d.retryStrategy,
          backoffJitterPct: d.backoffJitterPct,
          requestTimeoutMs: d.requestTimeoutMs,
          connectTimeoutMs: d.connectTimeoutMs,
          signatureAlgorithm: d.signatureAlgorithm,
          includeTimestampHeader: d.includeTimestampHeader,
          maxConcurrent: d.maxConcurrent,
          dlqEnabled: d.dlqEnabled,
          dlqMaxAgeSeconds: d.dlqMaxAgeSeconds,
          ordering: d.ordering,
          defaultLocale: d.defaultLocale,
          metadata: d.metadata,
          createdAt: currentSnapshot.createdAt || event.occurredAt,
          updatedAt: event.occurredAt, // Always update the timestamp
          version: currentSnapshot.version + 1 || 1,
        });

        if (entityResult.ok) {
          this._entity = entityResult.value;
        }
        break;
      }
      case 'ConfigDeleted': {
        // Optional: add a flag to track deletion state
        // this._isDeleted = true;
        break;
      }
      default:
        // Unknown event type - log or handle gracefully
        break;
    }
  }

  /**
   * Apply snapshot to restore aggregate state
   */
  protected applySnapshot(
    snapshot: ConfigSnapshotProps,
  ): Result<void, DomainError> {
    // Use the entity's fromSnapshot method to handle all VO creation and validation
    const entityResult = ConfigEntity.fromSnapshot(snapshot);

    if (!entityResult.ok) {
      return err({
        code: 'CONFIG.SNAPSHOT_APPLICATION_FAILED',
        title: 'Snapshot Application Failed',
        detail: 'Failed to apply snapshot due to invalid data',
        category: 'domain',
        retryable: false,
        context: {
          originalError: entityResult.error,
          snapshotCode: snapshot.id,
        },
      });
    }

    // Entity is valid and fully reconstituted
    this._entity = entityResult.value;
    return ok(undefined);
  }

  /**
   * Create snapshot of current aggregate state
   */
  public createSnapshot(): ConfigSnapshotProps {
    return this._entity.toSnapshot();
  }

  /**
   * Get current domain state for application layer
   *
   * This method provides access to the rich domain state without
   * requiring the application layer to depend on infrastructure mappers.
   * Maintains clean architecture by keeping dependencies pointing inward.
   *
   * @returns Current domain state with value objects
   */
  public toDomainState(): ConfigDomainState {
    return this._entity.getDomainState();
  }

  // ======================
  // Entity Access
  // ======================

  /**
   * Get the aggregate ID (required for aggregate identity)
   */
  public get id(): ConfigId {
    return this._entity.id;
  }

  /**
   * Get the underlying entity for data access
   * Use this for all data queries and getter access
   */
  public get entity(): ConfigEntity {
    return this._entity;
  }

  // ======================
  // Private Helpers
  // ======================

  /**
   * Detects if any field values have actually changed
   * @param validatedFields - New field values to check
   * @returns true if any changes detected, false otherwise
   */
  private detectChanges(validatedFields: ValidatedConfigUpdateFields): boolean {
    // Check each field for actual value changes using value object equality
    if (validatedFields.webhookId !== undefined) {
      if (hasValueChanged(this._entity.webhookId, validatedFields.webhookId)) {
        return true;
      }
    }
    if (validatedFields.tenantId !== undefined) {
      if (hasValueChanged(this._entity.tenantId, validatedFields.tenantId)) {
        return true;
      }
    }
    if (validatedFields.strategy !== undefined) {
      if (hasValueChanged(this._entity.strategy, validatedFields.strategy)) {
        return true;
      }
    }
    if (validatedFields.maxRetryAttempts !== undefined) {
      if (
        hasValueChanged(
          this._entity.maxRetryAttempts,
          validatedFields.maxRetryAttempts,
        )
      ) {
        return true;
      }
    }
    if (validatedFields.retryBackoffSeconds !== undefined) {
      if (
        hasValueChanged(
          this._entity.retryBackoffSeconds,
          validatedFields.retryBackoffSeconds,
        )
      ) {
        return true;
      }
    }
    if (validatedFields.retryStrategy !== undefined) {
      if (
        hasValueChanged(
          this._entity.retryStrategy,
          validatedFields.retryStrategy,
        )
      ) {
        return true;
      }
    }
    if (validatedFields.backoffJitterPct !== undefined) {
      if (
        hasValueChanged(
          this._entity.backoffJitterPct,
          validatedFields.backoffJitterPct,
        )
      ) {
        return true;
      }
    }
    if (validatedFields.requestTimeoutMs !== undefined) {
      if (
        hasValueChanged(
          this._entity.requestTimeoutMs,
          validatedFields.requestTimeoutMs,
        )
      ) {
        return true;
      }
    }
    if (validatedFields.connectTimeoutMs !== undefined) {
      if (
        hasValueChanged(
          this._entity.connectTimeoutMs,
          validatedFields.connectTimeoutMs,
        )
      ) {
        return true;
      }
    }
    if (validatedFields.signatureAlgorithm !== undefined) {
      if (
        hasValueChanged(
          this._entity.signatureAlgorithm,
          validatedFields.signatureAlgorithm,
        )
      ) {
        return true;
      }
    }
    if (validatedFields.includeTimestampHeader !== undefined) {
      if (
        hasValueChanged(
          this._entity.includeTimestampHeader,
          validatedFields.includeTimestampHeader,
        )
      ) {
        return true;
      }
    }
    if (validatedFields.maxConcurrent !== undefined) {
      if (
        hasValueChanged(
          this._entity.maxConcurrent,
          validatedFields.maxConcurrent,
        )
      ) {
        return true;
      }
    }
    if (validatedFields.dlqEnabled !== undefined) {
      if (
        hasValueChanged(this._entity.dlqEnabled, validatedFields.dlqEnabled)
      ) {
        return true;
      }
    }
    if (validatedFields.dlqMaxAgeSeconds !== undefined) {
      if (
        hasValueChanged(
          this._entity.dlqMaxAgeSeconds,
          validatedFields.dlqMaxAgeSeconds,
        )
      ) {
        return true;
      }
    }
    if (validatedFields.ordering !== undefined) {
      if (hasValueChanged(this._entity.ordering, validatedFields.ordering)) {
        return true;
      }
    }
    if (validatedFields.defaultLocale !== undefined) {
      if (
        hasValueChanged(
          this._entity.defaultLocale,
          validatedFields.defaultLocale,
        )
      ) {
        return true;
      }
    }
    if (validatedFields.metadata !== undefined) {
      if (hasValueChanged(this._entity.metadata, validatedFields.metadata)) {
        return true;
      }
    }
    // No changes detected
    return false;
  }

  // ======================
  // Business Operations (Event Publishing)
  // ======================

  /**
   * Batch update multiple properties atomically
   *
   * This method eliminates the logic overlap between factory and individual update methods:
   * - Single optimistic concurrency check
   * - Single version bump
   * - Single domain event published
   * - Atomic transaction for all field changes
   *
   * @param validatedFields - Pre-validated field values (factory responsibility)
   * @param expectedVersion - Optional version for optimistic concurrency control
   * @returns Result indicating success or failure
   */
  public updateBatch(
    validatedFields: ValidatedConfigUpdateFields,
    expectedVersion?: number,
  ): Result<void, DomainError> {
    // Single optimistic concurrency check (not per field like individual methods)
    if (
      expectedVersion != null &&
      expectedVersion !== this._entity.version.value
    ) {
      return err({
        ...ConfigErrors.CONCURRENCY_CONFLICT,
        context: {
          expected: expectedVersion,
          actual: this._entity.version.value,
          aggregateId: this._entity.id.value,
        },
      });
    }

    const before = this._entity.toSnapshot();

    // Check if any field actually changed by comparing values
    const hasChanges = this.detectChanges(validatedFields);

    // If no changes detected, return success without creating events
    if (!hasChanges) {
      return ok(undefined);
    }

    // Single version bump for entire batch (not per field)
    const currentVersionResult = createConfigVersion(before.version);
    if (!currentVersionResult.ok) {
      return err(currentVersionResult.error);
    }

    const nextVersionResult = bumpVersion(currentVersionResult.value);
    if (!nextVersionResult.ok) {
      return err(nextVersionResult.error);
    }

    const nextVersion = nextVersionResult.value.value;

    // Single timestamp for entire batch operation
    const updatedAtResult = updatedAtNow(this.clock);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const updatedAt = updatedAtResult.value.value;

    // Apply all field changes atomically through entity
    let currentEntity = this._entity;

    // Apply each validated field change with type safety
    if (validatedFields.webhookId !== undefined) {
      const entityResult = currentEntity.withWebhookId(
        validatedFields.webhookId,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.tenantId !== undefined) {
      const entityResult = currentEntity.withTenantId(
        validatedFields.tenantId,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.strategy !== undefined) {
      const entityResult = currentEntity.withStrategy(
        validatedFields.strategy,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.maxRetryAttempts !== undefined) {
      const entityResult = currentEntity.withMaxRetryAttempts(
        validatedFields.maxRetryAttempts,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.retryBackoffSeconds !== undefined) {
      const entityResult = currentEntity.withRetryBackoffSeconds(
        validatedFields.retryBackoffSeconds,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.retryStrategy !== undefined) {
      const entityResult = currentEntity.withRetryStrategy(
        validatedFields.retryStrategy,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.backoffJitterPct !== undefined) {
      const entityResult = currentEntity.withBackoffJitterPct(
        validatedFields.backoffJitterPct,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.requestTimeoutMs !== undefined) {
      const entityResult = currentEntity.withRequestTimeoutMs(
        validatedFields.requestTimeoutMs,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.connectTimeoutMs !== undefined) {
      const entityResult = currentEntity.withConnectTimeoutMs(
        validatedFields.connectTimeoutMs,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.signatureAlgorithm !== undefined) {
      const entityResult = currentEntity.withSignatureAlgorithm(
        validatedFields.signatureAlgorithm,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.includeTimestampHeader !== undefined) {
      const entityResult = currentEntity.withIncludeTimestampHeader(
        validatedFields.includeTimestampHeader,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.maxConcurrent !== undefined) {
      const entityResult = currentEntity.withMaxConcurrent(
        validatedFields.maxConcurrent,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.dlqEnabled !== undefined) {
      const entityResult = currentEntity.withDlqEnabled(
        validatedFields.dlqEnabled,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.dlqMaxAgeSeconds !== undefined) {
      const entityResult = currentEntity.withDlqMaxAgeSeconds(
        validatedFields.dlqMaxAgeSeconds,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.ordering !== undefined) {
      const entityResult = currentEntity.withOrdering(
        validatedFields.ordering,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.defaultLocale !== undefined) {
      const entityResult = currentEntity.withDefaultLocale(
        validatedFields.defaultLocale,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    if (validatedFields.metadata !== undefined) {
      const entityResult = currentEntity.withMetadata(
        validatedFields.metadata,
        updatedAt,
        nextVersion,
      );
      if (!entityResult.ok) return err(entityResult.error);
      currentEntity = entityResult.value;
    }

    // Commit the batched changes
    this._entity = currentEntity;

    // Create domain-shaped update event (same structure as created event)
    const updatedEvent = ConfigUpdatedEvent.create({
      id: this._entity.id.value,
      webhookId: this._entity.webhookId?.value,
      tenantId: this._entity.tenantId.value,
      strategy: this._entity.strategy.value,
      maxRetryAttempts: this._entity.maxRetryAttempts.value,
      retryBackoffSeconds: this._entity.retryBackoffSeconds.value,
      retryStrategy: this._entity.retryStrategy?.value,
      backoffJitterPct: this._entity.backoffJitterPct?.value,
      requestTimeoutMs: this._entity.requestTimeoutMs?.value,
      connectTimeoutMs: this._entity.connectTimeoutMs?.value,
      signatureAlgorithm: this._entity.signatureAlgorithm?.value,
      includeTimestampHeader: this._entity.includeTimestampHeader?.value,
      maxConcurrent: this._entity.maxConcurrent?.value,
      dlqEnabled: this._entity.dlqEnabled?.value,
      dlqMaxAgeSeconds: this._entity.dlqMaxAgeSeconds?.value,
      ordering: this._entity.ordering?.value,
      defaultLocale: this._entity.defaultLocale.value,
      metadata: this._entity.metadata?.value,
    });

    // Apply as domain event with clean business data
    const domainEvent: DomainEvent = {
      type: updatedEvent.eventType,
      version: Number(updatedEvent.eventVersion),
      occurredAt: updatedAt,
      aggregateId: this._entity.id.value,
      aggregateType: 'Config',
      data: updatedEvent.payload,
      metadata: this.eventMetadata,
    };

    this.apply(domainEvent);

    return ok(undefined);
  }

  /**
   * Set entity to per-webhook
   */
  public perWebhook(): Result<void, DomainError> {
    const strategyResult = createConfigStrategy('per-webhook');
    if (!strategyResult.ok) return err(strategyResult.error);
    return this.updateBatch({ strategy: strategyResult.value });
  }

  /**
   * Set entity to per-tenant
   */
  public perTenant(): Result<void, DomainError> {
    const strategyResult = createConfigStrategy('per-tenant');
    if (!strategyResult.ok) return err(strategyResult.error);
    return this.updateBatch({ strategy: strategyResult.value });
  }

  /**
   * Set entity to global
   */
  public global(): Result<void, DomainError> {
    const strategyResult = createConfigStrategy('global');
    if (!strategyResult.ok) return err(strategyResult.error);
    return this.updateBatch({ strategy: strategyResult.value });
  }

  /**
   * Set entity to exponential
   */
  public exponential(): Result<void, DomainError> {
    const retryStrategyResult = createConfigRetryStrategy('exponential');
    if (!retryStrategyResult.ok) return err(retryStrategyResult.error);
    return this.updateBatch({ retryStrategy: retryStrategyResult.value });
  }

  /**
   * Set entity to linear
   */
  public linear(): Result<void, DomainError> {
    const retryStrategyResult = createConfigRetryStrategy('linear');
    if (!retryStrategyResult.ok) return err(retryStrategyResult.error);
    return this.updateBatch({ retryStrategy: retryStrategyResult.value });
  }

  /**
   * Set entity to fixed
   */
  public fixed(): Result<void, DomainError> {
    const retryStrategyResult = createConfigRetryStrategy('fixed');
    if (!retryStrategyResult.ok) return err(retryStrategyResult.error);
    return this.updateBatch({ retryStrategy: retryStrategyResult.value });
  }

  /**
   * Set entity to sha256
   */
  public sha256(): Result<void, DomainError> {
    const signatureAlgorithmResult = createConfigSignatureAlgorithm('sha256');
    if (!signatureAlgorithmResult.ok)
      return err(signatureAlgorithmResult.error);
    return this.updateBatch({
      signatureAlgorithm: signatureAlgorithmResult.value,
    });
  }

  /**
   * Set entity to sha1
   */
  public sha1(): Result<void, DomainError> {
    const signatureAlgorithmResult = createConfigSignatureAlgorithm('sha1');
    if (!signatureAlgorithmResult.ok)
      return err(signatureAlgorithmResult.error);
    return this.updateBatch({
      signatureAlgorithm: signatureAlgorithmResult.value,
    });
  }

  /**
   * Set entity to fifo
   */
  public fifo(): Result<void, DomainError> {
    const orderingResult = createConfigOrdering('fifo');
    if (!orderingResult.ok) return err(orderingResult.error);
    return this.updateBatch({ ordering: orderingResult.value });
  }

  /**
   * Set entity to loose
   */
  public loose(): Result<void, DomainError> {
    const orderingResult = createConfigOrdering('loose');
    if (!orderingResult.ok) return err(orderingResult.error);
    return this.updateBatch({ ordering: orderingResult.value });
  }

  /**
   * Delete the config entity (business operation with event publishing)
   *
   * @returns Result indicating success or failure
   */
  public delete(): Result<void, DomainError> {
    // Create timestamp VO for delete operation using injected clock
    const deletedAtResult = updatedAtNow(this.clock);
    if (!deletedAtResult.ok) {
      return err(deletedAtResult.error);
    }

    // Create and apply domain event for deletion
    const domainEvent: DomainEvent = {
      type: 'ConfigDeleted',
      version: 1,
      occurredAt: deletedAtResult.value.value, // Extract Date from VO
      aggregateId: this._entity.id.value,
      aggregateType: 'Config',
    };

    this.apply(domainEvent);

    return ok(undefined);
  }

  // ======================
  // Query Methods (Delegate to Entity)
  // ======================

  /**
   * Check if this aggregate represents the same entity as another
   */
  public sameAs(other: ConfigAggregate): boolean {
    return this._entity.sameAs(other._entity);
  }
}
