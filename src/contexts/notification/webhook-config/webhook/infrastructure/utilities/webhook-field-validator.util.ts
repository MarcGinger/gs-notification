// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import {
  safeParseJSON,
  safeParseJSONArray,
} from 'src/shared/infrastructure/repositories';
import {
  DetailWebhookResponse,
  WebhookMethodValue,
  WebhookStatusValue,
} from '../../application/dtos';

/**
 * Webhook Field Validator Utility
 *
 * Centralized utility for parsing and validating Webhook aggregate data from EventStore events.
 * Provides consistent field validation patterns that can be reused across repositories
 * and projectors for Webhook domain operations.
 *
 * @domain Notification Context - Webhook Field Validation Utility
 * @layer Infrastructure
 * @pattern Utility Pattern + Field Validation
 */
export class WebhookFieldValidatorUtil {
  /**
   * Create a validated DetailWebhookResponse from raw EventStore event data
   *
   * Uses modern safeParseJSON utilities and DTOs to maintain CQRS compliance.
   * This creates read model data for projections, not domain props.
   *
   * @param aggregateData - Raw event data from EventStore
   * @returns Validated DetailWebhookResponse DTO with all required fields
   * @throws Error if required fields are missing or invalid
   */
  static createWebhookSnapshotFromEventData(
    aggregateData: Record<string, any>,
  ): DetailWebhookResponse & {
    version: number;
    createdAt: Date;
    updatedAt: Date;
  } {
    // Parse array fields using safeParseJSONArray utility
    const headers = safeParseJSON<Record<string, unknown>>(
      aggregateData.headers,
      'headers',
    );
    // Extract simple fields directly from event data
    const id = aggregateData.id as string;
    const name = aggregateData.name as string;
    const description = aggregateData.description as string;
    const targetUrl = aggregateData.targetUrl as string;
    const webhookEventType = aggregateData.webhookEventType as string;
    const method = aggregateData.method as WebhookMethodValue;
    const signingSecret = aggregateData.signingSecret as string;
    const status = aggregateData.status as WebhookStatusValue;
    const verifyTls =
      aggregateData.verifyTls === 'true' || aggregateData.verifyTls === true;
    const requestTimeoutMs =
      typeof aggregateData.requestTimeoutMs === 'string'
        ? parseInt(aggregateData.requestTimeoutMs, 10)
        : (aggregateData.requestTimeoutMs as number);
    const connectTimeoutMs =
      typeof aggregateData.connectTimeoutMs === 'string'
        ? parseInt(aggregateData.connectTimeoutMs, 10)
        : (aggregateData.connectTimeoutMs as number);
    const rateLimitPerMinute =
      typeof aggregateData.rateLimitPerMinute === 'string'
        ? parseInt(aggregateData.rateLimitPerMinute, 10)
        : (aggregateData.rateLimitPerMinute as number);

    // Extract version and timestamps with proper type conversion
    const version =
      typeof aggregateData.version === 'string'
        ? parseInt(aggregateData.version, 10)
        : (aggregateData.version as number);
    const createdAt =
      typeof aggregateData.createdAt === 'string'
        ? new Date(aggregateData.createdAt)
        : (aggregateData.createdAt as Date);
    const updatedAt =
      typeof aggregateData.updatedAt === 'string'
        ? new Date(aggregateData.updatedAt)
        : (aggregateData.updatedAt as Date);

    // safeParseJSON utilities provide error handling for invalid JSON,
    // direct field access provides type safety and truthful representation
    return {
      id,
      name,
      description,
      targetUrl,
      webhookEventType,
      method,
      headers,
      signingSecret,
      status,
      verifyTls,
      requestTimeoutMs,
      connectTimeoutMs,
      rateLimitPerMinute,
      version,
      createdAt,
      updatedAt,
    };
  }
}
