// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

/**
 * Webhook State Infrastructure Mappers
 *
 * Bidirectional mapping between pure VO domain state and primitive persistence snapshot.
 * Handles conversion between rich domain objects and raw database data.
 */

import {
  WebhookCreatedAt,
  WebhookUpdatedAt,
  WebhookVersion,
  WebhookId,
  WebhookName,
  WebhookDescription,
  WebhookTargetUrl,
  WebhookEventType,
  createWebhookMethod,
  WebhookHeaders,
  WebhookSigningSecretRef,
  createWebhookStatus,
  WebhookVerifyTls,
  WebhookRequestTimeoutMs,
  WebhookConnectTimeoutMs,
  WebhookRateLimitPerMinute,
} from '../../domain/value-objects';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { WebhookDomainState } from '../../domain/state/webhook.state';
import { WebhookSnapshotProps } from '../../domain/props';

/**
 * Infrastructure State Mapper
 *
 * Handles conversion between domain VOs and persistence primitives.
 * This is where primitive obsession is eliminated - converting between
 * rich domain objects and raw database data.
 */
export class WebhookStateMapper {
  /**
   * Convert primitive persistence snapshot to rich domain state
   *
   * @param snapshot - Raw database/persistence data
   * @returns Rich domain state with VOs or error
   */
  static toDomain(
    snapshot: WebhookSnapshotProps,
  ): Result<WebhookDomainState, DomainError> {
    const errors: Array<{ field: string; error: DomainError }> = [];

    // Helper function to validate and collect errors
    const validateField = <T>(
      fieldName: string,
      result: Result<T, DomainError>,
    ): T | null => {
      if (!result.ok) {
        errors.push({ field: fieldName, error: result.error });
        return null;
      }
      return result.value;
    };

    // Convert each primitive to its corresponding VO with error collection
    const id = validateField('id', WebhookId.from(snapshot.id));
    const name = validateField('name', WebhookName.from(snapshot.name));
    const description = snapshot.description
      ? validateField(
          'description',
          WebhookDescription.from(snapshot.description),
        )
      : undefined;
    const targetUrl = validateField(
      'targetUrl',
      WebhookTargetUrl.from(snapshot.targetUrl),
    );
    const eventType = validateField(
      'eventType',
      WebhookEventType.from(snapshot.eventType),
    );
    const method = validateField(
      'method',
      createWebhookMethod(snapshot.method),
    );
    const headers = snapshot.headers
      ? validateField('headers', WebhookHeaders.from(snapshot.headers))
      : undefined;
    const signingSecretRef = snapshot.signingSecretRef
      ? validateField(
          'signingSecretRef',
          WebhookSigningSecretRef.from(snapshot.signingSecretRef),
        )
      : undefined;
    const status = validateField(
      'status',
      createWebhookStatus(snapshot.status),
    );
    const verifyTls = snapshot.verifyTls
      ? validateField('verifyTls', WebhookVerifyTls.from(snapshot.verifyTls))
      : undefined;
    const requestTimeoutMs = snapshot.requestTimeoutMs
      ? validateField(
          'requestTimeoutMs',
          WebhookRequestTimeoutMs.from(snapshot.requestTimeoutMs),
        )
      : undefined;
    const connectTimeoutMs = snapshot.connectTimeoutMs
      ? validateField(
          'connectTimeoutMs',
          WebhookConnectTimeoutMs.from(snapshot.connectTimeoutMs),
        )
      : undefined;
    const rateLimitPerMinute = snapshot.rateLimitPerMinute
      ? validateField(
          'rateLimitPerMinute',
          WebhookRateLimitPerMinute.from(snapshot.rateLimitPerMinute),
        )
      : undefined;
    const version = validateField(
      'version',
      WebhookVersion.from(snapshot.version),
    );
    const createdAt = validateField(
      'createdAt',
      WebhookCreatedAt.from(snapshot.createdAt),
    );
    const updatedAt = validateField(
      'updatedAt',
      WebhookUpdatedAt.from(snapshot.updatedAt),
    );

    // If any validations failed, return aggregated error
    if (errors.length > 0) {
      return err({
        code: 'WEBHOOK.MAPPER_VALIDATION_FAILED',
        title: 'Domain State Mapping Failed',
        detail: `Failed to create domain state from persistence snapshot. ${errors.length} validation error(s) occurred.`,
        category: 'infrastructure',
        retryable: false,
        context: {
          validationErrors: errors.map((e) => ({
            field: e.field,
            errorCode: e.error.code,
            errorMessage: e.error.detail,
          })),
          snapshotCode: snapshot.id,
        },
      });
    }

    // All validations passed, construct the rich domain state
    const domainState: WebhookDomainState = {
      id: id!,
      name: name!,
      description: description || undefined,
      targetUrl: targetUrl!,
      eventType: eventType!,
      method: method!,
      headers: headers || undefined,
      signingSecretRef: signingSecretRef || undefined,
      status: status!,
      verifyTls: verifyTls || undefined,
      requestTimeoutMs: requestTimeoutMs || undefined,
      connectTimeoutMs: connectTimeoutMs || undefined,
      rateLimitPerMinute: rateLimitPerMinute || undefined,
      version: version!,
      createdAt: createdAt!,
      updatedAt: updatedAt!,
    };

    return ok(domainState);
  }

  /**
   * Convert rich domain state to primitive persistence snapshot
   *
   * @param domainState - Rich domain state with VOs
   * @returns Raw persistence data for database storage
   */
  static toSnapshot(domainState: WebhookDomainState): WebhookSnapshotProps {
    return {
      // Extract primitive values from VOs
      id: domainState.id.value,
      name: domainState.name.value,
      description: domainState.description?.value,
      targetUrl: domainState.targetUrl.value,
      eventType: domainState.eventType.value,
      method: domainState.method.value,
      headers: domainState.headers?.value,
      signingSecretRef: domainState.signingSecretRef?.value,
      status: domainState.status.value,
      verifyTls: domainState.verifyTls?.value,
      requestTimeoutMs: domainState.requestTimeoutMs?.value,
      connectTimeoutMs: domainState.connectTimeoutMs?.value,
      rateLimitPerMinute: domainState.rateLimitPerMinute?.value,
      version: domainState.version.value,
      createdAt: domainState.createdAt.value,
      updatedAt: domainState.updatedAt.value,
    };
  }
}
