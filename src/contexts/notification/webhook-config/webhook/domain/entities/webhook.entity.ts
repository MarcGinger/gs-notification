// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { EntityIdBase } from 'src/shared/domain/entities';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { WebhookSnapshotProps } from '../props';
import { WebhookDomainState } from '../state';
import { WebhookErrors } from '../errors/webhook.errors';
import {
  WebhookConnectTimeoutMs,
  WebhookCreatedAt,
  WebhookUpdatedAt,
  WebhookVersion,
  WebhookDescription,
  WebhookHeaders,
  WebhookId,
  WebhookMethod,
  WebhookMethodLogic,
  WebhookName,
  WebhookRateLimitPerMinute,
  WebhookRequestTimeoutMs,
  WebhookSigningSecretRef,
  WebhookStatus,
  WebhookStatusLogic,
  WebhookStatusValue,
  WebhookTargetUrl,
  WebhookVerifyTls,
  WebhookWebhookEventType,
  createWebhookMethod,
  createWebhookStatus,
} from '../value-objects';

/**
 * Domain Entity: Webhook
 *
 * Represents the core Webhook entity in the notification domain.
 * Encapsulates webhook data, identity, and basic entity behavior.
 *
 * This entity follows DDD principles:
 * - Identity: Id as unique identifier
 * - Immutability: Changes create new instances
 * - Encapsulation: Private state with controlled access
 * - Business validation: Domain rules enforced
 *
 * @domain Notification Context - Webhook Entity
 * @layer Domain Entities
 */

/**
 * Webhook Entity
 *
 * Core domain entity representing a webhook in the notification.
 * Handles webhook identity, validation, and state management.
 */
export class WebhookEntity extends EntityIdBase<WebhookDomainState, WebhookId> {
  private static clock: { now: () => Date } = { now: () => new Date() };

  public static setClock(c: { now: () => Date }) {
    this.clock = c;
  }

  /**
   * Helper method to create updatedAt VO from date
   */
  private static createUpdatedAt(
    date?: Date,
  ): Result<WebhookUpdatedAt, DomainError> {
    const targetDate = date || WebhookEntity.clock.now();
    const result = WebhookUpdatedAt.from(targetDate);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create version VO from number
   */
  private static createVersion(
    versionNumber?: number,
    currentVersion?: WebhookVersion,
  ): Result<WebhookVersion, DomainError> {
    const targetVersion = versionNumber ?? currentVersion?.value ?? 1;
    const result = WebhookVersion.from(targetVersion);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create updated entity with common logic
   */
  private createUpdatedEntity(
    fieldUpdates: Partial<WebhookDomainState>,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    const updatedAtResult = WebhookEntity.createUpdatedAt(updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = WebhookEntity.createVersion(
      version,
      this.props.version,
    );
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const updatedProps: WebhookDomainState = {
      ...this.props,
      ...fieldUpdates,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return WebhookEntity.create(updatedProps);
  }

  private constructor(props: WebhookDomainState) {
    super(props, props.id);
  }

  /**
   * Factory method to create a new webhook entity
   *
   * @param props - Webhook properties
   * @returns Result containing WebhookEntity or DomainError
   */
  public static create(
    props: WebhookDomainState,
  ): Result<WebhookEntity, DomainError> {
    // Validate required properties
    const validationResult = WebhookEntity.validate(props);
    if (validationResult.ok === false) {
      return err(validationResult.error);
    }

    return ok(new WebhookEntity(props));
  }

  /**
   * Factory method to reconstitute a webhook entity from persistence
   *
   * @param props - Webhook properties from database
   * @returns WebhookEntity instance
   */
  public static reconstitute(props: WebhookDomainState): WebhookEntity {
    return new WebhookEntity(props);
  }

  /**
   * Factory method to reconstitute entity from snapshot
   *
   * @param snapshot - Webhook snapshot properties
   * @returns Result containing WebhookEntity or DomainError
   */
  public static fromSnapshot(
    snapshot: WebhookSnapshotProps,
  ): Result<WebhookEntity, DomainError> {
    const idResult = WebhookId.from(snapshot.id);
    if (!idResult.ok) {
      return err(idResult.error);
    }
    const nameResult = WebhookName.from(snapshot.name);
    if (!nameResult.ok) {
      return err(nameResult.error);
    }
    const descriptionResult = WebhookDescription.from(snapshot.description);
    if (!descriptionResult.ok) {
      return err(descriptionResult.error);
    }
    const targetUrlResult = WebhookTargetUrl.from(snapshot.targetUrl);
    if (!targetUrlResult.ok) {
      return err(targetUrlResult.error);
    }
    const webhookEventTypeResult = WebhookWebhookEventType.from(
      snapshot.webhookEventType,
    );
    if (!webhookEventTypeResult.ok) {
      return err(webhookEventTypeResult.error);
    }
    const methodResult = createWebhookMethod(snapshot.method);
    if (!methodResult.ok) {
      return err(methodResult.error);
    }
    const headersResult = WebhookHeaders.from(snapshot.headers);
    if (!headersResult.ok) {
      return err(headersResult.error);
    }
    const signingSecretRefResult = WebhookSigningSecretRef.from(
      snapshot.signingSecretRef,
    );
    if (!signingSecretRefResult.ok) {
      return err(signingSecretRefResult.error);
    }
    const statusResult = createWebhookStatus(snapshot.status);
    if (!statusResult.ok) {
      return err(statusResult.error);
    }
    const verifyTlsResult = WebhookVerifyTls.from(snapshot.verifyTls);
    if (!verifyTlsResult.ok) {
      return err(verifyTlsResult.error);
    }
    const requestTimeoutMsResult = WebhookRequestTimeoutMs.from(
      snapshot.requestTimeoutMs,
    );
    if (!requestTimeoutMsResult.ok) {
      return err(requestTimeoutMsResult.error);
    }
    const connectTimeoutMsResult = WebhookConnectTimeoutMs.from(
      snapshot.connectTimeoutMs,
    );
    if (!connectTimeoutMsResult.ok) {
      return err(connectTimeoutMsResult.error);
    }
    const rateLimitPerMinuteResult = WebhookRateLimitPerMinute.from(
      snapshot.rateLimitPerMinute,
    );
    if (!rateLimitPerMinuteResult.ok) {
      return err(rateLimitPerMinuteResult.error);
    }
    const createdAtResult = WebhookCreatedAt.from(snapshot.createdAt);
    if (!createdAtResult.ok) {
      return err(createdAtResult.error);
    }

    const updatedAtResult = WebhookUpdatedAt.from(snapshot.updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = WebhookVersion.from(snapshot.version);
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const props: WebhookDomainState = {
      id: idResult.value,
      name: nameResult.value,
      description: descriptionResult.value,
      targetUrl: targetUrlResult.value,
      webhookEventType: webhookEventTypeResult.value,
      method: methodResult.value,
      headers: headersResult.value,
      signingSecretRef: signingSecretRefResult.value,
      status: statusResult.value,
      verifyTls: verifyTlsResult.value,
      requestTimeoutMs: requestTimeoutMsResult.value,
      connectTimeoutMs: connectTimeoutMsResult.value,
      rateLimitPerMinute: rateLimitPerMinuteResult.value,
      createdAt: createdAtResult.value,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return WebhookEntity.create(props);
  }

  /**
   * Validates webhook entity properties
   *
   * @param props - Properties to validate
   * @returns Validation result
   */
  private static validate(
    props: WebhookDomainState,
  ): Result<void, DomainError> {
    // Basic validation
    if (!props.id) {
      return err(WebhookErrors.INVALID_ID_DATA);
    }
    if (!props.name) {
      return err(WebhookErrors.INVALID_NAME_DATA);
    }
    if (!props.targetUrl) {
      return err(WebhookErrors.INVALID_TARGET_URL_DATA);
    }
    if (!props.webhookEventType) {
      return err(WebhookErrors.INVALID_WEBHOOK_EVENT_TYPE_DATA);
    }
    if (!props.method) {
      return err(WebhookErrors.INVALID_METHOD_DATA);
    }
    if (!props.status) {
      return err(WebhookErrors.INVALID_STATUS_DATA);
    }

    return ok(undefined);
  }

  // ======================
  // Getters (Public API)
  // ======================

  public get id(): WebhookId {
    return this.props.id;
  }

  public get name(): WebhookName {
    return this.props.name;
  }

  public get description(): WebhookDescription | undefined {
    return this.props.description;
  }

  public get targetUrl(): WebhookTargetUrl {
    return this.props.targetUrl;
  }

  public get webhookEventType(): WebhookWebhookEventType {
    return this.props.webhookEventType;
  }

  public get method(): WebhookMethod {
    return this.props.method;
  }

  public get headers(): WebhookHeaders | undefined {
    return this.props.headers;
  }

  public get signingSecretRef(): WebhookSigningSecretRef | undefined {
    return this.props.signingSecretRef;
  }

  public get status(): WebhookStatus {
    return this.props.status;
  }

  public get verifyTls(): WebhookVerifyTls | undefined {
    return this.props.verifyTls;
  }

  public get requestTimeoutMs(): WebhookRequestTimeoutMs | undefined {
    return this.props.requestTimeoutMs;
  }

  public get connectTimeoutMs(): WebhookConnectTimeoutMs | undefined {
    return this.props.connectTimeoutMs;
  }

  public get rateLimitPerMinute(): WebhookRateLimitPerMinute | undefined {
    return this.props.rateLimitPerMinute;
  }

  public get createdAt(): WebhookCreatedAt {
    return this.props.createdAt;
  }

  public get updatedAt(): WebhookUpdatedAt {
    return this.props.updatedAt;
  }

  public get version(): WebhookVersion {
    return this.props.version;
  }

  // ======================
  // Simple Update Methods (No Business Logic)
  // ======================

  /**
   * Creates a new entity with updated name (pure state transition)
   *
   * @param name - New name value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withName(
    name: WebhookName,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    return this.createUpdatedEntity({ name }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated description (pure state transition)
   *
   * @param description - New description value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withDescription(
    description: WebhookDescription,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    return this.createUpdatedEntity({ description }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated targetUrl (pure state transition)
   *
   * @param targetUrl - New targetUrl value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withTargetUrl(
    targetUrl: WebhookTargetUrl,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    return this.createUpdatedEntity({ targetUrl }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated webhookEventType (pure state transition)
   *
   * @param webhookEventType - New webhookEventType value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withWebhookEventType(
    webhookEventType: WebhookWebhookEventType,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    return this.createUpdatedEntity({ webhookEventType }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated method (with basic transition validation)
   *
   * @param method - New method value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withMethod(
    method: WebhookMethod,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    const currentStatus = this.props.method.value;
    const targetStatus = method.value;

    if (!WebhookMethodLogic.canTransition(currentStatus, targetStatus)) {
      return err({
        ...WebhookErrors.INVALID_METHOD_TRANSITION,
        context: {
          currentStatus,
          targetStatus,
          validTransitions:
            WebhookMethodLogic.getValidTransitions(currentStatus),
        },
      });
    }

    return this.createUpdatedEntity({ method }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated headers (pure state transition)
   *
   * @param headers - New headers value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withHeaders(
    headers: WebhookHeaders,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    return this.createUpdatedEntity({ headers }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated signingSecretRef (pure state transition)
   *
   * @param signingSecretRef - New signingSecretRef value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withSigningSecretRef(
    signingSecretRef: WebhookSigningSecretRef,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    return this.createUpdatedEntity({ signingSecretRef }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated status (with basic transition validation)
   *
   * @param status - New status value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withStatus(
    status: WebhookStatus,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    const currentStatus = this.props.status.value;
    const targetStatus = status.value;

    if (!WebhookStatusLogic.canTransition(currentStatus, targetStatus)) {
      return err({
        ...WebhookErrors.INVALID_STATUS_TRANSITION,
        context: {
          currentStatus,
          targetStatus,
          validTransitions:
            WebhookStatusLogic.getValidTransitions(currentStatus),
        },
      });
    }

    return this.createUpdatedEntity({ status }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated verifyTls (pure state transition)
   *
   * @param verifyTls - New verifyTls value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withVerifyTls(
    verifyTls: WebhookVerifyTls,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    return this.createUpdatedEntity({ verifyTls }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated requestTimeoutMs (pure state transition)
   *
   * @param requestTimeoutMs - New requestTimeoutMs value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withRequestTimeoutMs(
    requestTimeoutMs: WebhookRequestTimeoutMs,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    return this.createUpdatedEntity({ requestTimeoutMs }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated connectTimeoutMs (pure state transition)
   *
   * @param connectTimeoutMs - New connectTimeoutMs value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withConnectTimeoutMs(
    connectTimeoutMs: WebhookConnectTimeoutMs,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    return this.createUpdatedEntity({ connectTimeoutMs }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated rateLimitPerMinute (pure state transition)
   *
   * @param rateLimitPerMinute - New rateLimitPerMinute value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<WebhookEntity, DomainError>
   */
  public withRateLimitPerMinute(
    rateLimitPerMinute: WebhookRateLimitPerMinute,
    updatedAt?: Date,
    version?: number,
  ): Result<WebhookEntity, DomainError> {
    return this.createUpdatedEntity({ rateLimitPerMinute }, updatedAt, version);
  }

  /**
   * Get valid next statuses from current state
   * @returns readonly WebhookStatusValue[]
   */
  public getValidStatusTransitions(): readonly WebhookStatusValue[] {
    // Get valid next statuses from current state
    return WebhookStatusLogic.getValidTransitions(this.props.status.value);
  }

  // ======================
  // Query Methods
  // ======================

  /**
   * Checks if two webhooks are the same entity
   *
   * @param other - Other webhook to compare
   */
  public sameAs(other: WebhookEntity): boolean {
    return this.props.id.equals(other.props.id);
  }

  /**
   * Gets a snapshot of current entity state for serialization
   */
  public toSnapshot(): WebhookSnapshotProps {
    return {
      id: this.props.id.value,
      name: this.props.name.value,
      description: this.props.description?.value,
      targetUrl: this.props.targetUrl.value,
      webhookEventType: this.props.webhookEventType.value,
      method: this.props.method.value,
      headers: this.props.headers?.value,
      signingSecretRef: this.props.signingSecretRef?.value,
      status: this.props.status.value,
      verifyTls: this.props.verifyTls?.value,
      requestTimeoutMs: this.props.requestTimeoutMs?.value,
      connectTimeoutMs: this.props.connectTimeoutMs?.value,
      rateLimitPerMinute: this.props.rateLimitPerMinute?.value,
      createdAt: this.props.createdAt.value,
      updatedAt: this.props.updatedAt.value,
      version: this.props.version.value,
    };
  }

  /**
   * Gets the current domain state with value objects
   *
   * Provides access to the rich domain state for application layer
   * without requiring infrastructure mappers. Maintains clean architecture.
   *
   * @returns Current domain state with value objects
   */
  public getDomainState(): WebhookDomainState {
    return this.props;
  }
}
