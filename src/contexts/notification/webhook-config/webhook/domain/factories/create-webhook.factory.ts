// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, withContext, ok } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { WebhookAggregate } from '../aggregates';
import { CreateWebhookProps } from '../props';
import { WebhookDomainState } from '../state';
import {
  WebhookCreatedAt,
  WebhookUpdatedAt,
  WebhookVersion,
  WebhookId,
  WebhookName,
  WebhookDescription,
  WebhookTargetUrl,
  WebhookWebhookEventType,
  createWebhookMethod,
  WebhookHeaders,
  WebhookSigningSecretRef,
  createWebhookStatus,
  WebhookVerifyTls,
  WebhookRequestTimeoutMs,
  WebhookConnectTimeoutMs,
  WebhookRateLimitPerMinute,
} from '../value-objects';

/**
 * Enhanced webhook entity factory with comprehensive validation and security context
 * Moved from application layer to properly separate business concerns
 */
export function createWebhookAggregateFromProps(
  props: CreateWebhookProps,
  metadata: EventMetadata,
  clock: Clock,
  // validatedEntities?: {
  //  channels?: ChannelReference[];
  // },
): Result<WebhookAggregate, DomainError> {
  // Validate each property by creating value objects
  const idResult = WebhookId.from(props.id);
  if (!idResult.ok) {
    return err(
      withContext(idResult.error, {
        ...idResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        id: props.id,
      }),
    );
  }

  const nameResult = WebhookName.from(props.name);
  if (!nameResult.ok) {
    return err(
      withContext(nameResult.error, {
        ...nameResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        name: props.name,
      }),
    );
  }

  const descriptionResult = WebhookDescription.from(props.description);
  if (!descriptionResult.ok) {
    return err(
      withContext(descriptionResult.error, {
        ...descriptionResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        description: props.description,
      }),
    );
  }

  const targetUrlResult = WebhookTargetUrl.from(props.targetUrl);
  if (!targetUrlResult.ok) {
    return err(
      withContext(targetUrlResult.error, {
        ...targetUrlResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        targetUrl: props.targetUrl,
      }),
    );
  }

  const webhookEventTypeResult = WebhookWebhookEventType.from(
    props.webhookEventType,
  );
  if (!webhookEventTypeResult.ok) {
    return err(
      withContext(webhookEventTypeResult.error, {
        ...webhookEventTypeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        webhookEventType: props.webhookEventType,
      }),
    );
  }

  const methodResult = createWebhookMethod(props.method);
  if (!methodResult.ok) {
    return err(
      withContext(methodResult.error, {
        ...methodResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        method: props.method,
      }),
    );
  }

  const headersResult = WebhookHeaders.from(props.headers);
  if (!headersResult.ok) {
    return err(
      withContext(headersResult.error, {
        ...headersResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        headers: props.headers,
      }),
    );
  }

  const signingSecretRefResult = WebhookSigningSecretRef.from(
    props.signingSecretRef,
  );
  if (!signingSecretRefResult.ok) {
    return err(
      withContext(signingSecretRefResult.error, {
        ...signingSecretRefResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        signingSecretRef: props.signingSecretRef,
      }),
    );
  }

  const statusResult = createWebhookStatus(props.status);
  if (!statusResult.ok) {
    return err(
      withContext(statusResult.error, {
        ...statusResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        status: props.status,
      }),
    );
  }

  const verifyTlsResult = WebhookVerifyTls.from(props.verifyTls);
  if (!verifyTlsResult.ok) {
    return err(
      withContext(verifyTlsResult.error, {
        ...verifyTlsResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        verifyTls: props.verifyTls,
      }),
    );
  }

  const requestTimeoutMsResult = WebhookRequestTimeoutMs.from(
    props.requestTimeoutMs,
  );
  if (!requestTimeoutMsResult.ok) {
    return err(
      withContext(requestTimeoutMsResult.error, {
        ...requestTimeoutMsResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        requestTimeoutMs: props.requestTimeoutMs,
      }),
    );
  }

  const connectTimeoutMsResult = WebhookConnectTimeoutMs.from(
    props.connectTimeoutMs,
  );
  if (!connectTimeoutMsResult.ok) {
    return err(
      withContext(connectTimeoutMsResult.error, {
        ...connectTimeoutMsResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        connectTimeoutMs: props.connectTimeoutMs,
      }),
    );
  }

  const rateLimitPerMinuteResult = WebhookRateLimitPerMinute.from(
    props.rateLimitPerMinute,
  );
  if (!rateLimitPerMinuteResult.ok) {
    return err(
      withContext(rateLimitPerMinuteResult.error, {
        ...rateLimitPerMinuteResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_webhook',
        rateLimitPerMinute: props.rateLimitPerMinute,
      }),
    );
  }

  const createdAtResult = WebhookCreatedAt.create(clock.now());
  if (!createdAtResult.ok) {
    return err(createdAtResult.error);
  }

  const updatedAtResult = WebhookUpdatedAt.create(clock.now());
  if (!updatedAtResult.ok) {
    return err(updatedAtResult.error);
  }

  const versionResult = WebhookVersion.create(1); // Initial version is 1
  if (!versionResult.ok) {
    return err(versionResult.error);
  }

  // Create the entity properties with validated value objects
  const entityProps: WebhookDomainState = {
    id: idResult.value,
    name: nameResult.value,
    description: descriptionResult.value,
    targetUrl: targetUrlResult.value,
    webhookEventType: webhookEventTypeResult.value,
    method: methodResult.value,
    headers: headersResult.value,
    signingSecretRef: signingSecretRefResult.value,
    status: statusResult.value,
    verifyTls: verifyTlsResult.value,
    requestTimeoutMs: requestTimeoutMsResult.value,
    connectTimeoutMs: connectTimeoutMsResult.value,
    rateLimitPerMinute: rateLimitPerMinuteResult.value,
    createdAt: createdAtResult.value,
    updatedAt: updatedAtResult.value,
    version: versionResult.value,
  };

  // Create the entity using the constructor
  return WebhookAggregate.create(entityProps, clock, metadata);
}
