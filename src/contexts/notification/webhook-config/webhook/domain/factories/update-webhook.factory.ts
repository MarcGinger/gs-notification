// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, ok, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { WebhookAggregate } from '../aggregates';
import { WebhookEntity } from '../entities';
import { UpdateWebhookProps, WebhookSnapshotProps } from '../props';
import { ValidatedWebhookUpdateFields } from '../types';
import {
  WebhookName,
  WebhookDescription,
  WebhookTargetUrl,
  WebhookWebhookEventType,
  createWebhookMethod,
  WebhookHeaders,
  WebhookSigningSecretRef,
  createWebhookStatus,
  WebhookVerifyTls,
  WebhookRequestTimeoutMs,
  WebhookConnectTimeoutMs,
  WebhookRateLimitPerMinute,
} from '../value-objects';

/**
 * Update Webhook Aggregate Factory
 *
 * Handles the complete update flow for Webhook aggregates:
 * 1. Loads existing aggregate from snapshot
 * 2. Validates update properties and creates value objects
 * 3. Applies updates with proper business rule enforcement
 * 4. Returns updated aggregate ready for persistence
 *
 * This factory provides:
 * - Consistent update pattern matching create operations
 * - Centralized validation and business logic
 * - Efficient batch updates vs field-by-field
 * - Proper error context and logging integration
 */
export function updateWebhookAggregateFromSnapshot(
  existingSnapshot: WebhookSnapshotProps,
  updateProps: UpdateWebhookProps,
  metadata: EventMetadata,
  clock: Clock,
): Result<WebhookAggregate, DomainError> {
  // 1. Reconstitute existing aggregate
  const entityResult = WebhookEntity.fromSnapshot(existingSnapshot);
  if (!entityResult.ok) {
    return err(
      withContext(entityResult.error, {
        operation: 'update_webhook_reconstitute',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
      }),
    );
  }

  const existingAggregate = WebhookAggregate.reconstitute(
    entityResult.value,
    clock,
    metadata,
  );

  // 2. Validate and apply updates for each provided field
  const validatedFields: ValidatedWebhookUpdateFields = {};

  // Validate name if provided
  if (updateProps.name !== undefined) {
    const nameResult = WebhookName.from(updateProps.name);
    if (!nameResult.ok) {
      return err(
        withContext(nameResult.error, {
          operation: 'update_webhook_name_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedName: updateProps.name,
        }),
      );
    }
    validatedFields.name = nameResult.value;
  }

  // Validate description if provided
  if (updateProps.description !== undefined) {
    const descriptionResult = WebhookDescription.from(updateProps.description);
    if (!descriptionResult.ok) {
      return err(
        withContext(descriptionResult.error, {
          operation: 'update_webhook_description_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedDescription: updateProps.description,
        }),
      );
    }
    validatedFields.description = descriptionResult.value;
  }

  // Validate targetUrl if provided
  if (updateProps.targetUrl !== undefined) {
    const targetUrlResult = WebhookTargetUrl.from(updateProps.targetUrl);
    if (!targetUrlResult.ok) {
      return err(
        withContext(targetUrlResult.error, {
          operation: 'update_webhook_target_url_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedTargetUrl: updateProps.targetUrl,
        }),
      );
    }
    validatedFields.targetUrl = targetUrlResult.value;
  }

  // Validate webhookEventType if provided
  if (updateProps.webhookEventType !== undefined) {
    const webhookEventTypeResult = WebhookWebhookEventType.from(
      updateProps.webhookEventType,
    );
    if (!webhookEventTypeResult.ok) {
      return err(
        withContext(webhookEventTypeResult.error, {
          operation: 'update_webhook_webhook_event_type_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedWebhookEventType: updateProps.webhookEventType,
        }),
      );
    }
    validatedFields.webhookEventType = webhookEventTypeResult.value;
  }

  // Validate method if provided
  if (updateProps.method !== undefined) {
    const methodResult = createWebhookMethod(updateProps.method);
    if (!methodResult.ok) {
      return err(
        withContext(methodResult.error, {
          operation: 'update_webhook_method_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedMethod: updateProps.method,
        }),
      );
    }
    validatedFields.method = methodResult.value;
  }

  // Validate headers if provided
  if (updateProps.headers !== undefined) {
    const headersResult = WebhookHeaders.from(updateProps.headers);
    if (!headersResult.ok) {
      return err(
        withContext(headersResult.error, {
          operation: 'update_webhook_headers_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedHeaders: updateProps.headers,
        }),
      );
    }
    validatedFields.headers = headersResult.value;
  }

  // Validate signingSecretRef if provided
  if (updateProps.signingSecretRef !== undefined) {
    const signingSecretRefResult = WebhookSigningSecretRef.from(
      updateProps.signingSecretRef,
    );
    if (!signingSecretRefResult.ok) {
      return err(
        withContext(signingSecretRefResult.error, {
          operation: 'update_webhook_signing_secret_ref_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedSigningSecretRef: updateProps.signingSecretRef,
        }),
      );
    }
    validatedFields.signingSecretRef = signingSecretRefResult.value;
  }

  // Validate status if provided
  if (updateProps.status !== undefined) {
    const statusResult = createWebhookStatus(updateProps.status);
    if (!statusResult.ok) {
      return err(
        withContext(statusResult.error, {
          operation: 'update_webhook_status_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedStatus: updateProps.status,
        }),
      );
    }
    validatedFields.status = statusResult.value;
  }

  // Validate verifyTls if provided
  if (updateProps.verifyTls !== undefined) {
    const verifyTlsResult = WebhookVerifyTls.from(updateProps.verifyTls);
    if (!verifyTlsResult.ok) {
      return err(
        withContext(verifyTlsResult.error, {
          operation: 'update_webhook_verify_tls_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedVerifyTls: updateProps.verifyTls,
        }),
      );
    }
    validatedFields.verifyTls = verifyTlsResult.value;
  }

  // Validate requestTimeoutMs if provided
  if (updateProps.requestTimeoutMs !== undefined) {
    const requestTimeoutMsResult = WebhookRequestTimeoutMs.from(
      updateProps.requestTimeoutMs,
    );
    if (!requestTimeoutMsResult.ok) {
      return err(
        withContext(requestTimeoutMsResult.error, {
          operation: 'update_webhook_request_timeout_ms_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedRequestTimeoutMs: updateProps.requestTimeoutMs,
        }),
      );
    }
    validatedFields.requestTimeoutMs = requestTimeoutMsResult.value;
  }

  // Validate connectTimeoutMs if provided
  if (updateProps.connectTimeoutMs !== undefined) {
    const connectTimeoutMsResult = WebhookConnectTimeoutMs.from(
      updateProps.connectTimeoutMs,
    );
    if (!connectTimeoutMsResult.ok) {
      return err(
        withContext(connectTimeoutMsResult.error, {
          operation: 'update_webhook_connect_timeout_ms_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedConnectTimeoutMs: updateProps.connectTimeoutMs,
        }),
      );
    }
    validatedFields.connectTimeoutMs = connectTimeoutMsResult.value;
  }

  // Validate rateLimitPerMinute if provided
  if (updateProps.rateLimitPerMinute !== undefined) {
    const rateLimitPerMinuteResult = WebhookRateLimitPerMinute.from(
      updateProps.rateLimitPerMinute,
    );
    if (!rateLimitPerMinuteResult.ok) {
      return err(
        withContext(rateLimitPerMinuteResult.error, {
          operation: 'update_webhook_rate_limit_per_minute_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedRateLimitPerMinute: updateProps.rateLimitPerMinute,
        }),
      );
    }
    validatedFields.rateLimitPerMinute = rateLimitPerMinuteResult.value;
  }

  // 3. Apply all validated changes in single atomic operation
  const batchUpdateResult = existingAggregate.updateBatch(validatedFields);
  if (!batchUpdateResult.ok) {
    return err(
      withContext(batchUpdateResult.error, {
        operation: 'update_product_batch_application',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        fieldsUpdated: Object.keys(validatedFields),
      }),
    );
  }

  return ok(existingAggregate);
}
