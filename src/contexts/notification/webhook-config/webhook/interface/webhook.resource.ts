// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

/**
 * Webhook Resource Decorators - Domain-Driven Authorization
 *
 * Clean integration with domain-driven permissions infrastructure.
 * All business rules and risk assessments come from the domain layer.
 *
 * ARCHITECTURAL PRINCIPLE: No business logic duplication
 * ✅ Risk levels: WebhookPermissionHelpers.getRiskLevel()
 * ✅ Justification rules: WebhookPermissionHelpers.requiresJustification()
 * ✅ Categories: WebhookPermissionRegistry[permission].category
 * ✅ Policy paths: WebhookPermissionHelpers.getPolicyPath()
 * ✅ Audit requirements: WebhookPermissionRegistry[permission].auditRequired
 *
 * This keeps the HTTP layer thin and ensures business rules
 * live in the domain where they belong.
 */

import { Resource } from 'src/shared/security/opa';
import { Request } from 'express';
import {
  WebhookPermission,
  WebhookPermissionHelpers,
  WebhookPermissionRegistry,
} from '../domain/permissions';

/**
 * Domain-driven Webhook resource decorator
 *
 * All business rules come from the domain layer - no duplication!
 */
export const WebhookResource = (permission: WebhookPermission) =>
  Resource({
    type: 'webhook',
    action: permission,
    extractId: (req: Request) => req.params?.id || req.params?.id,
    extractAttributes: (req: Request) => {
      const body = req.body as Record<string, unknown> | undefined;
      const query = req.query as Record<string, unknown> | undefined;

      // Business data extraction
      const name = body?.name || query?.name;
      const description = body?.description || query?.description;
      const targetUrl = body?.targetUrl || query?.targetUrl;
      const webhookEventType =
        body?.webhookEventType || query?.webhookEventType;
      const method = body?.method || query?.method;
      const signingSecret = body?.signingSecret || query?.signingSecret;
      const status = body?.status || query?.status;
      const verifyTls = body?.verifyTls || query?.verifyTls;
      const requestTimeoutMs =
        body?.requestTimeoutMs || query?.requestTimeoutMs;
      const connectTimeoutMs =
        body?.connectTimeoutMs || query?.connectTimeoutMs;
      const rateLimitPerMinute =
        body?.rateLimitPerMinute || query?.rateLimitPerMinute;

      const baseAttributes = {
        name,
        description,
        targetUrl,
        webhookEventType,
        method,
        signingSecret,
        status,
        verifyTls,
        requestTimeoutMs,
        connectTimeoutMs,
        rateLimitPerMinute,
      };

      // Domain-driven permission context (no hardcoded business rules!)
      const permissionMeta = WebhookPermissionRegistry[permission];
      const permissionContext = {
        permission,
        riskLevel: WebhookPermissionHelpers.getRiskLevel(permission),
        requiresJustification:
          WebhookPermissionHelpers.requiresJustification(permission),
        category: permissionMeta?.category as string,
        policyPath: WebhookPermissionHelpers.getPolicyPath(permission),
        auditRequired: WebhookPermissionHelpers.requiresAudit(permission),
      };

      return {
        ...baseAttributes,
        _permissionContext: permissionContext,
      };
    },
  });

/**
 * Specialized decorators for high-risk operations
 */
export const WebhookDeleteResource = () =>
  WebhookResource(WebhookPermission.DOMAIN_WEBHOOK_DELETE);

export const WebhookCreateResource = () =>
  WebhookResource(WebhookPermission.DOMAIN_WEBHOOK_CREATE);

export const WebhookUpdateResource = () =>
  WebhookResource(WebhookPermission.DOMAIN_WEBHOOK_UPDATE);

export const WebhookReadResource = () =>
  WebhookResource(WebhookPermission.DOMAIN_WEBHOOK_READ);
