// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Inject } from '@nestjs/common';
import { Result, ok, err, DomainError, withContext } from 'src/shared/errors';

// Shared utilities and infrastructure
import { APP_LOGGER, componentLogger, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import { IUserToken } from 'src/shared/security';
import { ActorContextAdapter } from 'src/shared/application/actor-context.adapter';
import { validateSortFields, toTakeSkip } from 'src/shared/domain/properties';
import {
  DEFAULT_PAGINATION_CONFIG,
  DEFAULT_LIST_CACHE_CONFIG,
} from 'src/shared/domain/pagination.config';
import {
  UseCaseLoggingUtil,
  UseCaseLoggingConfig,
} from 'src/shared/application/utils/use-case-logging.util';

import { WebhookConfigServiceConstants } from '../../../service-constants';

// Service configuration
// Using string literals for service constants

// Application layer
import { ListWebhookQuery } from '../queries';
import { IWebhookQuery, WEBHOOK_QUERY_TOKEN } from '../ports';
import { WebhookAuthorizationAdapter } from '../services';
import { ListWebhookFilterRequest, WebhookPageResponse } from '../dtos';
import { IListWebhookUseCase } from './contracts';

// Shared compliance services (lightweight for list operations)
import {
  PIIClassificationService,
  PIIProtectionService,
  DataRetentionService,
} from 'src/shared/services/compliance';

/**
 * ✅ Enhanced List Webhook Use Case with Enterprise Logging and Compliance
 *
 * Features:
 * - Classification-only PII approach (no domain data mutation)
 * - Safe logging contexts to prevent accidental PII disclosure
 * - Enhanced error handling with structured domain errors
 * - Authorization-based filtering with batch processing
 * - Comprehensive audit trails and compliance tracking
 * - Pagination validation and security controls
 */
@Injectable()
export class ListWebhookUseCase implements IListWebhookUseCase {
  private readonly logger: Logger;
  private readonly loggingConfig: UseCaseLoggingConfig;

  constructor(
    @Inject(WEBHOOK_QUERY_TOKEN)
    private readonly query: IWebhookQuery,
    private readonly authorizationService: WebhookAuthorizationAdapter,
    @Inject(APP_LOGGER) moduleLogger: Logger,
    @Inject(CLOCK) private readonly clock: Clock,
    private readonly piiClassificationService: PIIClassificationService,
    private readonly piiProtectionService: PIIProtectionService,
    private readonly dataRetentionService: DataRetentionService,
  ) {
    this.loggingConfig = {
      serviceName: WebhookConfigServiceConstants.SERVICE_NAME,
      component: 'ListWebhookUseCase',
      domain: 'webhook_config',
      entityType: 'webhook',
    };
    this.logger = componentLogger(moduleLogger, this.loggingConfig.component);
  }

  /**
   * Execute the list webhook query with enhanced pagination, validation, and compliance
   */
  async execute(params: {
    user: IUserToken;
    filter?: ListWebhookFilterRequest;
    correlationId: string;
  }): Promise<Result<WebhookPageResponse, DomainError>> {
    const operation = 'list_webhook';
    const startTime = this.clock.nowMs();

    // Create query object from params for internal use
    // Ensure we always have a proper ListWebhookFilterRequest instance with prototype methods
    const filter = params.filter
      ? Object.assign(new ListWebhookFilterRequest(), params.filter)
      : new ListWebhookFilterRequest();
    const query = new ListWebhookQuery(
      params.user,
      filter,
      params.correlationId,
    );

    // Step 1: Create safe logging context (no PII, deferred retention metadata)
    const safeLogContext = UseCaseLoggingUtil.createLogContext(
      this.loggingConfig,
      this.clock,
      operation,
      query as any, // Query adapted for use case logging
      {
        operationRisk: UseCaseLoggingUtil.assessOperationRisk(operation),
        listOperation: true,
        page: query.filter.page ?? DEFAULT_PAGINATION_CONFIG.defaultPage,
        size: query.filter.size ?? DEFAULT_PAGINATION_CONFIG.defaultPageSize,
        hasFilters: Object.keys(query.filter.sortBy ?? {}).length > 0,
      },
    );

    // Step 2: Validate query with enhanced logging
    const validation = UseCaseLoggingUtil.validateCommand(
      this.logger,
      query as any,
      safeLogContext,
    );
    if (!validation.ok) {
      return err(validation.error);
    }

    try {
      // Step 1: Validate sort fields for security using inherited configuration
      const sortFieldConfig = query.filter.getSortFieldConfig();
      const allowedFields = Object.keys(sortFieldConfig).filter(
        (field) => sortFieldConfig[field].sortable,
      );
      const sortValidation = validateSortFields(
        query.filter.sortBy ?? {},
        allowedFields,
      );
      if (!sortValidation.ok) {
        UseCaseLoggingUtil.logOperationError(
          this.logger,
          operation,
          safeLogContext,
          sortValidation.error,
          'MEDIUM',
        );
        return err(sortValidation.error);
      }

      // Step 2: Convert pagination to repository parameters
      const takeSkipResult = toTakeSkip(
        query.filter.page ?? DEFAULT_PAGINATION_CONFIG.defaultPage,
        query.filter.size ?? DEFAULT_PAGINATION_CONFIG.defaultPageSize,
        DEFAULT_PAGINATION_CONFIG.maxPageSize,
      );
      if (!takeSkipResult.ok) {
        UseCaseLoggingUtil.logOperationError(
          this.logger,
          operation,
          safeLogContext,
          takeSkipResult.error,
          'MEDIUM',
        );
        return err(takeSkipResult.error);
      }

      // Step 3: Execute the repository query
      const webhookResult = await this.fetchWebhook(query);
      if (!webhookResult.ok) {
        UseCaseLoggingUtil.logOperationError(
          this.logger,
          operation,
          safeLogContext,
          webhookResult.error,
          'HIGH',
        );
        return err(webhookResult.error);
      }

      // Step 4: Filter Webhook based on authorization
      const correlationId = query.correlationId ?? 'unknown';
      const authorizedWebhookResult = await this.filterAuthorizedWebhooks(
        webhookResult.value,
        query.user.sub,
        correlationId,
        {
          tenant: query.user.tenant,
          roles: query.user.roles,
          operationType: 'list',
        },
      );

      if (!authorizedWebhookResult.ok) {
        UseCaseLoggingUtil.logOperationError(
          this.logger,
          operation,
          safeLogContext,
          authorizedWebhookResult.error,
          'HIGH',
        );
        return err(authorizedWebhookResult.error);
      }

      // Step 5: Light compliance check for list operations (audit log only)
      const finalResult = authorizedWebhookResult.value;
      if (finalResult.data && finalResult.data.length > 0) {
        // For list operations, we log bulk data access for compliance audit
        const sampleData = finalResult.data[0]; // Use first item for classification
        const listClassification = this.piiClassificationService.classifyData(
          {
            signingSecret: sampleData.signingSecret || '',
          },
          {
            domain: 'webhook-config',
            tenant: query.user.tenant,
            // entityType: 'Webhook' // Future: for entity-level rules
          },
        );

        if (listClassification.containsPII) {
          // Log bulk data access for audit trail
          UseCaseLoggingUtil.logComplianceCheck(
            this.logger,
            operation,
            safeLogContext,
            listClassification,
          );
        }
      }

      // Step 6: Log operation success with comprehensive metrics
      const executionTime = this.clock.nowMs() - startTime;
      UseCaseLoggingUtil.logOperationSuccess(
        this.logger,
        operation,
        safeLogContext,
        {
          executionTimeMs: executionTime,
          businessData: {
            totalItems: finalResult.meta?.totalItems ?? 0,
            returnedItems: finalResult.data?.length ?? 0,
            page: query.filter.page ?? DEFAULT_PAGINATION_CONFIG.defaultPage,
            pageSize:
              query.filter.size ?? DEFAULT_PAGINATION_CONFIG.defaultPageSize,
            hasFilters: Object.keys(query.filter.sortBy ?? {}).length > 0,
            cacheEnabled: true,
            cacheTtl: DEFAULT_LIST_CACHE_CONFIG.defaultTtl,
          },
        },
      );

      return authorizedWebhookResult;
    } catch (error) {
      const domainError = withContext(
        {
          code: 'NOTIFICATION_WEBHOOK_CONFIG.LIST_WEBHOOKS_FAILED',
          title: 'Failed to list webhook',
          category: 'infrastructure' as const,
          retryable: true,
        },
        {
          ...safeLogContext,
          error: error instanceof Error ? error.message : String(error),
        },
      );

      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        domainError,
        'CRITICAL',
      );

      return err(domainError);
    }
  }

  /**
   * ✅ Fetch webhook from repository with error handling
   */
  private async fetchWebhook(
    query: ListWebhookQuery,
  ): Promise<Result<WebhookPageResponse, DomainError>> {
    try {
      // ✅ Use enhanced repository with proper Result handling
      const repositoryOptions = {
        correlationId: query.correlationId,
        source: 'list-webhook-use-case',
        cache: {
          ttl: DEFAULT_LIST_CACHE_CONFIG.defaultTtl, // Use configurable cache TTL
          skipCache: false,
        },
      };

      // ✅ Convert IUserToken to ActorContext for enhanced repository methods
      const actor = ActorContextAdapter.fromUserToken(query.user);

      // ✅ Use findPaginated directly since we have IWebhookQuery
      const webhookResult = await this.query.findPaginated(
        actor,
        query.filter,
        repositoryOptions,
      );

      if (!webhookResult.ok) {
        return err(webhookResult.error);
      }

      return ok(webhookResult.value);
    } catch (error) {
      return err(
        withContext(
          {
            code: 'NOTIFICATION_WEBHOOK_CONFIG.REPOSITORY_FETCH_FAILED',
            title: 'Failed to fetch webhook from repository',
            category: 'infrastructure',
            retryable: true,
          },
          {
            operation: 'fetch_webhook',
            error: error instanceof Error ? error.message : String(error),
          },
        ),
      );
    }
  }

  /**
   * Filter webhooks based on user authorization
   */
  private async filterAuthorizedWebhooks(
    webhookPage: WebhookPageResponse,
    userId: string,
    correlationId: string,
    context: Record<string, any>,
  ): Promise<Result<WebhookPageResponse, DomainError>> {
    try {
      if (!webhookPage.data || webhookPage.data.length === 0) {
        return ok(webhookPage); // Empty page, nothing to filter
      }

      // Extract webhook codes for batch authorization check
      const ids = webhookPage.data
        .map((item) => item.id)
        .filter((id): id is string => id !== undefined && id !== null);
      if (ids.length === 0) {
        return ok(webhookPage); // No valid webhook ids
      }

      // Perform batch authorization check
      const authResult = await this.authorizationService.authorizeWebhookList(
        userId,
        ids,
        correlationId,
        'read',
        context,
      );

      if (!authResult.ok) {
        return err(authResult.error);
      }

      const { authorized } = authResult.value;

      // Filter items to only include authorized webhooks
      const authorizedItems = webhookPage.data.filter((item) =>
        authorized.includes(item.id),
      );

      // Update the page response with filtered results
      const filteredPage = WebhookPageResponse.create(
        authorizedItems,
        webhookPage.meta, // Keep original metadata for now
      );

      // Log filtering results
      if (authorizedItems.length < webhookPage.data.length) {
        this.logger.info(
          `Filtered webhook list: originalCount=${webhookPage.data.length} authorizedCount=${authorizedItems.length} userId=${userId} correlationId=${correlationId}`,
        );
      }

      return ok(filteredPage);
    } catch (error) {
      return err({
        code: 'WEBHOOK.LIST_AUTHORIZATION_FAILED',
        title: 'Failed to authorize webhook list',
        category: 'security',
        context: {
          userId,
          correlationId,
          error: error instanceof Error ? error.message : String(error),
        },
      });
    }
  }
}

/**
 * ✅ Type-safe use case result
 */
export type ListWebhookUseCaseResult = WebhookPageResponse;

/**
 * ✅ Use case execution context for dependency injection
 */
export interface ListWebhookUseCaseContext {
  correlationId?: string;
  userId?: string;
  tenant?: string;
}

/**
 * ✅ Factory function for creating queries with context
 */
export function createListWebhookQuery(
  user: IUserToken,
  filter: ListWebhookFilterRequest,
  context: ListWebhookUseCaseContext,
): ListWebhookQuery {
  return new ListWebhookQuery(user, filter, context.correlationId);
}
