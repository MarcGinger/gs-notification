// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Inject } from '@nestjs/common';
import {
  Result,
  ok,
  err,
  DomainError,
  isOk,
  withContext,
} from 'src/shared/errors';

// Shared utilities and infrastructure
import { APP_LOGGER, componentLogger, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import { CorrelationUtil } from 'src/shared/utilities/correlation.util';
import { CACHE_TTL } from 'src/shared/application/caching/cache.config';
import { RepositoryOptions } from 'src/shared/infrastructure/repositories/repository.types';
import { Option } from 'src/shared/domain/types';
import { ActorContextUtil } from 'src/shared/utilities/actor-context.util';
import {
  UseCaseLoggingUtil,
  UseCaseLoggingConfig,
} from 'src/shared/application/utils/use-case-logging.util';
import { IUserToken } from 'src/shared/security';

// Service configuration
import { WebhookConfigServiceConstants } from '../../../service-constants';

// Application layer
import { IWebhookQuery, WEBHOOK_QUERY_TOKEN } from '../ports';
import { WebhookAuthorizationAdapter } from '../services';
import { DetailWebhookResponse } from '../dtos';
import { IGetWebhookUseCase } from './contracts';
import { WebhookErrors } from '../../domain/errors';

/**
 * Get Webhook Use Case - CQRS Read Side Implementation
 *
 * This use case properly follows CQRS principles by working directly with DTOs
 * from the query port, avoiding dependencies on domain value objects.
 * The query port returns read-optimized DetailWebhookResponse DTOs directly.
 */

import {
  PIIClassificationService,
  PIIProtectionService,
  DataRetentionService,
} from 'src/shared/services/compliance';

/**
 * âœ… Enhanced Get Webhook Use Case with Modern Security and Compliance
 *
 * Features:
 * - Classification-only PII approach (no domain data mutation)
 * - Safe logging contexts to prevent accidental PII disclosure
 * - Enhanced error handling with structured domain errors
 * - Cache-first strategy for optimal performance
 * - Comprehensive audit trails and compliance tracking
 * - CQRS-compliant read operations with DTO optimization
 */

@Injectable()
export class GetWebhookUseCase implements IGetWebhookUseCase {
  private readonly logger: Logger;
  private readonly loggingConfig: UseCaseLoggingConfig;

  constructor(
    @Inject(WEBHOOK_QUERY_TOKEN)
    private readonly query: IWebhookQuery,
    private readonly authorizationService: WebhookAuthorizationAdapter,
    @Inject(CLOCK) private readonly clock: Clock,
    @Inject(APP_LOGGER) moduleLogger: Logger,
    private readonly piiClassificationService: PIIClassificationService,
    private readonly piiProtectionService: PIIProtectionService,
    private readonly dataRetentionService: DataRetentionService,
  ) {
    this.loggingConfig = {
      serviceName: WebhookConfigServiceConstants.SERVICE_NAME,
      component: 'GetWebhookUseCase',
      domain: 'webhook-config',
      entityType: 'webhook',
    };
    this.logger = componentLogger(moduleLogger, this.loggingConfig.component);
  }

  async execute(params: {
    user: IUserToken;
    id: string;
    correlationId: string;
  }): Promise<Result<DetailWebhookResponse, DomainError>> {
    const operation = 'get_webhook';
    const startTime = this.clock.nowMs();
    const correlationId = params.correlationId || CorrelationUtil.generate();

    // Step 1: Extract raw properties for domain logic (no PII protection at domain level)
    const rawProps = {
      id: params.id,
    };

    // Step 2: Create safe logging context (no PII, deferred retention metadata)
    const safeLogContext = UseCaseLoggingUtil.createLogContext(
      this.loggingConfig,
      this.clock,
      operation,
      params as any, // Query doesn't extend BaseUseCaseCommand but has similar structure
      {
        webhookId: rawProps.id,
        operationRisk: UseCaseLoggingUtil.assessOperationRisk(operation),
        readOperation: true,
        cacheEnabled: true,
      },
    );

    // Step 3: Validate query with enhanced logging
    const validation = UseCaseLoggingUtil.validateCommand(
      this.logger,
      params as any, // Query validation adapted for read operations
      safeLogContext,
    );
    if (!validation.ok) {
      return err(validation.error);
    }

    // Step 1: Check authorization first
    const authResult = await this.authorizationService.canReadResource(
      params.user.sub,
      params.id, // Using id as webhook identifier
      correlationId,
      {
        tenant: params.user.tenant,
        roles: params.user.roles,
        operationType: 'read',
      },
    );

    if (!authResult.ok) {
      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        authResult.error,
        'HIGH',
      );
      return err(authResult.error);
    }

    if (!authResult.value) {
      const authError = {
        code: 'CHANNEL.READ_NOT_AUTHORIZED' as const,
        title: 'Not authorized to read this channel',
        category: 'security' as const,
        context: {
          userId: params.user.sub,
          webhookId: params.id,
          operation: 'read',
        },
      };
      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        authError,
        'HIGH',
      );
      return err(authError);
    }

    // Step 2: Simple validation for query-side operations (CQRS compliant)
    if (
      !params.id ||
      typeof params.id !== 'string' ||
      params.id.trim().length === 0
    ) {
      const validationError = {
        code: 'WEBHOOK.INVALID_THE_CODE' as const,
        title: 'Invalid webhook id',
        category: 'validation' as const,
        context: {
          id: params.id,
          correlationId,
          userId: params.user.sub,
          operation: 'get_webhook',
        },
      };
      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        validationError,
        'MEDIUM',
      );
      return err(validationError);
    }

    // Step 3: Enhanced repository options with cache-first strategy
    const repositoryOptions: RepositoryOptions = {
      cache: {
        ttl: CACHE_TTL.STANDARD, // 5 minutes cache for webhook reads
        refreshCache: false, // Don't refresh on read
      },
      correlationId,
      requestId: params.user.sub,
    };

    // Step 4: Load the aggregate using enhanced repository with caching
    const actorResult = ActorContextUtil.fromUserTokenSafe(params.user);
    if (!isOk(actorResult)) {
      const contextError = withContext(actorResult.error, {
        correlationId,
        userId: params.user.sub,
        operation: 'get_webhook',
        id: params.id,
      });
      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        contextError,
        'HIGH',
      );
      return err(contextError);
    }
    const actor = actorResult.value;

    const webhookResult = await this.query.findById(
      actor,
      params.id,
      repositoryOptions,
    );

    if (!isOk(webhookResult)) {
      const contextError = withContext(webhookResult.error, {
        correlationId,
        userId: params.user.sub,
        operation: 'get_webhook',
        id: params.id,
      });
      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        contextError,
        'MEDIUM',
      );
      return err(contextError);
    }

    // Step 5: Handle Option<DetailWebhookResponse> safely - query port already returns DTOs (proper CQRS)
    const webhookDto = Option.isNone(webhookResult.value)
      ? null
      : webhookResult.value.value;

    // Step 5.1: Return 404 error if webhook not found
    if (!webhookDto) {
      const notFoundError = withContext(WebhookErrors.WEBHOOK_NOT_FOUND, {
        id: params.id,
        name: '', // Default values for required fields
        targetUrl: '', // Default values for required fields
        webhookEventType: '', // Default values for required fields
        method: 0, // Default values for required fields
        status: 0, // Default values for required fields
        webhookId: params.id,
        correlationId,
        userId: params.user.sub,
        operation: 'get_webhook',
      });

      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        notFoundError,
        'LOW',
      );

      return err(notFoundError);
    }

    // Step 6: Light compliance check for read operations (audit log only)
    // For read operations, we only log data access for compliance audit
    const readClassification = this.piiClassificationService.classifyData(
      {},
      {
        domain: 'webhook-config',
        tenant: params.user.tenant,
        // entityType: 'Webhook' // Future: for entity-level rules
      },
    );

    if (readClassification.containsPII) {
      // Log data access for audit trail (no protection needed for reads)
      UseCaseLoggingUtil.logComplianceCheck(
        this.logger,
        operation,
        safeLogContext,
        readClassification,
      );
    }

    // Step 7: Log operation success with comprehensive metrics
    const executionTime = this.clock.nowMs() - startTime;
    UseCaseLoggingUtil.logOperationSuccess(
      this.logger,
      operation,
      safeLogContext,
      {
        executionTimeMs: executionTime,
        businessData: {
          webhookId: params.id,
          found: true,
          cacheEnabled: true,
          cacheTtl: repositoryOptions.cache?.ttl,
          dataAccessLogged: true,
        },
      },
    );

    return ok(webhookDto);
  }
}
