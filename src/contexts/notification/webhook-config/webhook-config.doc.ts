// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { INestApplication } from '@nestjs/common';
import { SwaggerConfigUtil } from 'src/docs/swagger-config.util';

/**
 * notification webhook-config application/service Documentation
 * This module handles the Swagger documentation for notifications
 *
 */
export class WebhookConfigDocumentation {
  static setup(app: INestApplication, port: string | number): void {
    const config = new DocumentBuilder()
      .addBearerAuth(
        { type: 'http', scheme: 'bearer', bearerFormat: 'JWT' },
        'bearer',
      )
      .setTitle(`Core Webhook Configuration`)
      .setDescription(
        `
## bounded context: notification
[‚Üê Back to documentation](/api/docs/notification)

# üß© Core Webhook Config ‚Äî General Overview

The **Core Webhook Config** service is part of the broader **Notification Bounded Context**, responsible for managing all configuration aspects required to send outbound webhooks within the platform. It provides the infrastructure and domain logic that connects a tenant‚Äôs webhook endpoints to the notification ecosystem, ensuring secure, structured, and compliant communication between services and external systems.

---

## üéØ Purpose

The primary purpose of **Core Webhook Config** is to manage the lifecycle of webhook-related configuration for each tenant. It defines *where*, *how*, and *under what conditions* webhook payloads are sent. By maintaining configurations in a domain-driven, event-sourced model, the service guarantees auditability, tenant isolation, and consistency across all webhook-related operations.

---

## üß± Architectural Role

**Core Webhook Config** acts as the **configuration source of truth** for all webhook integrations in the system. It is not responsible for executing HTTP requests (that‚Äôs handled by the **Core Webhook Execute** service), but instead manages the metadata, headers, secrets, retry strategies, and operational policies that determine how webhooks are delivered and authorized.

### Key Roles:

* Acts as the *control plane* for webhook delivery configuration.
* Provides secure storage and reference handling for signing secrets.
* Defines approved target URLs and subscribed event types.
* Publishes domain events consumed by other services (e.g., executors, auditors, or workflow engines).
* Ensures compliance with audit and retry policies via event sourcing.

---

## ‚öôÔ∏è Core Components

| Aggregate   | Description                                                                                                     |
| ----------- | --------------------------------------------------------------------------------------------------------------- |
| **Webhook** | Represents an outbound webhook endpoint, including target URL, subscribed event types, HTTP method, and status. |
| **Config**  | Defines retry/backoff strategies, timeout settings, and operational parameters controlling webhook execution.   |

Each aggregate is event-sourced and projected into Redis for fast reads. The system follows a **CQRS pattern**, separating command writes (EventStoreDB) from queries (Redis projections).

---

## üß© Data Flow Summary

&#x60;&#x60;&#x60;
[API Command] ‚Üí [Use Case] ‚Üí [ESDB Writer Repository] ‚Üí [EventStoreDB]
       ‚Üì
[Central Projection Service] ‚Üí [Redis Snapshot] + [Redis Query Index]
       ‚Üì
[Query API] ‚Üí [Executor / UI / Workflow Consumers]
&#x60;&#x60;&#x60;

This architecture provides full event auditability in **EventStoreDB**, real-time read performance in **Redis**, and flexible event-driven synchronization via **BullMQ** projectors.

---

## üõ°Ô∏è Security and Compliance

* **Authentication:** Managed via Keycloak (OAuth2 / OpenID Connect).
* **Authorization:** Governed by Open Policy Agent (OPA) Rego policies.
* **Secret Management:** Signing secrets are stored securely using Doppler or another approved secret manager.
* **Auditability:** Every configuration change emits domain events stored in EventStoreDB, ensuring immutable history and traceability.

---

## üöÄ Example Use Cases

| Use Case                 | Description                                                                                                         |
| ------------------------ | ------------------------------------------------------------------------------------------------------------------- |
| **Webhook Registration** | When a new webhook is added for a tenant, &#x60;WebhookRegistered.v1&#x60; and &#x60;ConfigUpdated.v1&#x60; events are emitted.         |
| **Retry Policy Update**  | Admins can update retry and timeout parameters, triggering &#x60;ConfigUpdated.v1&#x60; for executor synchronization.         |
| **Secret Rotation**      | When a signing secret is rotated, the service emits a new versioned event and updates downstream projections.       |
| **Subscription Change**  | Tenants can modify the event types their webhook subscribes to, updating routing and executor behavior dynamically. |

---

## ‚úÖ Benefits

* **Event-Sourced Reliability:** Every change is versioned, replayable, and fully auditable.
* **Tenant Isolation:** Each webhook configuration is scoped to a tenant.
* **High Performance:** Read models are served from Redis with millisecond-level latency.
* **Extensible Design:** Supports additional delivery settings (e.g., per-event policies, delivery headers) in future iterations.
* **Integration Friendly:** Provides consistent event naming and structure compatible with other notification channels (Slack, Email, SMS).

---

## üß© Summary

The **Core Webhook Config** service provides the configuration backbone for all webhook-based notifications. It ensures that every outbound webhook:

* Is securely configured and authorized.
* Uses approved and auditable endpoints.
* Follows consistent retry and timeout policies.
* Operates under event-sourced, tenant-aware control.

This service is a critical component of the Notification Bounded Context, enabling scalable, reliable, and compliant webhook integration within a modern, event-driven architecture.


### application: webhook-config

  | Modules |
  |---------------|
  | [***webhook  ‚Üí***](/api/docs/notification/webhook-config/webhook) |
  | [***config  ‚Üí***](/api/docs/notification/webhook-config/config) |
        `,
      )
      .setVersion('1.0.0')
      .addTag(
        'WebhookConfig',
        `Configuration for notification webhook-config application/service`,
      );

    // Add dynamic server configuration
    SwaggerConfigUtil.addServers(config, port);

    // Create a document with no modules to ensure no API paths are included
    const document = SwaggerModule.createDocument(app, config.build(), {
      include: [], // No modules included - this is a links-only documentation page
      extraModels: [],
      deepScanRoutes: false, // Prevent automatic route discovery
      ignoreGlobalPrefix: true, // Ignore global prefix to avoid path discovery
    });

    // Remove any automatically discovered paths and schemas
    document.paths = {};
    document.components = { schemas: {} };

    SwaggerModule.setup('api/docs/notification/webhook-config', app, document);
  }

  /**
   * Setup all notification-related documentation endpoints
   * This method centralizes the setup of all notification module documentation
   */
  static setupAll(
    app: INestApplication,
    port: string | number,
  ): Record<string, string> {
    // Setup main notification documentation
    WebhookConfigDocumentation.setup(app, port);

    // Setup sub-module documentation

    // Return all endpoint URLs
    return {
      notification: WebhookConfigDocumentation.getEndpoint(port),
    };
  }

  static getEndpoint(port: string | number): string {
    return `${SwaggerConfigUtil.getServerUrl(port)}/api/docs/notification/webhook-config`;
  }
}
