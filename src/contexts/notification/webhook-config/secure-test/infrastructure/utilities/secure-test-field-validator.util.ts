// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK
import {
  DetailSecureTestResponse,
  SecureTestSignatureAlgorithmValue,
  SecureTestTypeValue,
} from '../../application/dtos';

import {
  SecretRefUnion,
  DopplerSecretRef,
  SealedSecretRef,
} from 'src/shared/infrastructure/secret-ref/domain/sealed-secret-ref.types';
import { SecretRefUtils } from 'src/shared/infrastructure/secret-ref/utilities/secret-ref.utils';
import { EventDataProcessingUtils } from 'src/shared/infrastructure/events/utilities/event-data-processing.utils';

/**
 * SecureTest Field Validator Utility
 *
 * Centralized utility for parsing and validating SecureTest aggregate data from EventStore events.
 * Provides consistent field validation patterns that can be reused across repositories
 * and projectors for SecureTest domain operations.
 *
 * @domain Notification Context - SecureTest Field Validation Utility
 * @layer Infrastructure
 * @pattern Utility Pattern + Field Validation
 */
export class SecureTestFieldValidatorUtil {
  /**
   * Create a validated DetailSecureTestResponse from raw EventStore event data
   *
   * Uses modern safeParseJSON utilities and DTOs to maintain CQRS compliance.
   * This creates read model data for projections, not domain props.
   *
   * @param aggregateData - Raw event data from EventStore
   * @returns Validated DetailSecureTestResponse DTO with all required fields
   * @throws Error if required fields are missing or invalid
   */
  static createSecureTestSnapshotFromEventData(
    aggregateData: Record<string, any>,
  ): DetailSecureTestResponse & {
    version: number;
    createdAt: Date;
    updatedAt: Date;
  } {
    // Extract simple fields directly from event data
    const id = aggregateData.id as string;
    const name = aggregateData.name as string;
    const description = aggregateData.description as string;
    const type = aggregateData.type as SecureTestTypeValue;
    const signatureAlgorithm =
      aggregateData.signatureAlgorithm as SecureTestSignatureAlgorithmValue;

    // Extract version and timestamps with proper type conversion
    const version = EventDataProcessingUtils.extractVersion(aggregateData);
    const { createdAt, updatedAt } =
      EventDataProcessingUtils.extractTimestamps(aggregateData);

    // Return SecretRef objects as JSON strings for Redis storage
    // This maintains backward compatibility with snapshot props structure
    // but stores encrypted SecretRef objects instead of plain text
    return {
      id,
      name,
      description,
      type,
      // For backward compatibility, still return the expected interface
      // but now with SecretRef support we'll add a new method for projector
      signingSecret: undefined,
      signatureAlgorithm,
      username: undefined,
      password: undefined,
      version,
      createdAt,
      updatedAt,
    };
  }

  /**
   * Create projector data with SecretRef objects for Redis storage
   *
   * This method extracts SecretRef objects from event data and serializes them
   * as JSON strings for storage in Redis. The reader repository will deserialize
   * and resolve these SecretRef objects back to actual secret values.
   *
   * @param aggregateData - Raw event data from EventStore containing SecretRef objects
   * @returns Projector data object with SecretRef fields as JSON strings
   */
  static createSecureTestProjectorDataFromEventData(
    aggregateData: Record<string, any>,
  ): {
    id: string;
    name: string;
    description?: string;
    type: SecureTestTypeValue;
    signingSecret?: string;
    signatureAlgorithm?: SecureTestSignatureAlgorithmValue;
    username?: string;
    password?: string;
    version: number;
    createdAt: Date;
    updatedAt: Date;
  } {
    // Extract simple fields directly from event data
    const id = aggregateData.id as string;
    const name = aggregateData.name as string;
    const description = aggregateData.description as string;
    const type = aggregateData.type as SecureTestTypeValue;
    const signatureAlgorithm =
      aggregateData.signatureAlgorithm as SecureTestSignatureAlgorithmValue;

    // Handle SecretRef objects from encrypted event data
    // The writer repository stores encrypted SecretRef objects in these fields
    const signingSecretRef = aggregateData.signingSecret
      ? JSON.stringify(aggregateData.signingSecret)
      : undefined;

    const usernameRef = aggregateData.username
      ? JSON.stringify(aggregateData.username)
      : undefined;

    const passwordRef = aggregateData.password
      ? JSON.stringify(aggregateData.password)
      : undefined;

    // Store plain text values directly for now (not encrypted)
    // This preserves the user-provided values per record
    // Extract credentials for validation (they're handled via SecretRef below)

    // Extract version and timestamps with proper type conversion
    const version = EventDataProcessingUtils.extractVersion(aggregateData);
    const { createdAt, updatedAt } =
      EventDataProcessingUtils.extractTimestamps(aggregateData);

    return {
      id,
      name,
      description,
      type,
      signingSecret: signingSecretRef,
      signatureAlgorithm,
      username: usernameRef,
      password: passwordRef,
      version,
      createdAt,
      updatedAt,
    };
  }

  // ==============================================
  // PHASE 3.1: ENHANCED SECRETREF VALIDATION
  // ==============================================

  /**
   * Validate SecretRefUnion object (supports both doppler and sealed)
   */
  static validateSecretRefUnion(ref: unknown): ref is SecretRefUnion {
    return SecretRefUtils.validateSecretRefUnion(ref);
  }

  /**
   * Create a Doppler SecretRef with enhanced validation
   */
  static createDopplerSecretRefForField(
    baseKey: string,
    tenant: string = 'core',
  ): DopplerSecretRef {
    return SecretRefUtils.createDopplerSecretRefForField(baseKey, tenant, {
      version: 'latest',
      algHint: 'doppler-v1',
    });
  }

  /**
   * Create a Sealed SecretRef for new webhook configurations
   */
  static createSealedSecretRefForField(
    tenant: string,
    context: string,
    algorithm: 'XCHACHA20-POLY1305' | 'AES-256-GCM' = 'XCHACHA20-POLY1305',
  ): SealedSecretRef {
    return SecretRefUtils.createSealedSecretRefForField(
      tenant,
      context,
      algorithm,
    );
  }

  /**
   * Parse and validate SecretRef from stored JSON string
   */
  static parseSecretRefFromJSON(jsonString: string): SecretRefUnion | null {
    return SecretRefUtils.parseSecretRefFromJSON(jsonString);
  }

  /**
   * Serialize SecretRef to JSON string for storage
   */
  static serializeSecretRefToJSON(ref: SecretRefUnion): string {
    return SecretRefUtils.serializeSecretRefToJSON(ref);
  }

  /**
   * Check if SecretRef is Doppler type
   */
  static isDopplerSecretRef(ref: SecretRefUnion): ref is DopplerSecretRef {
    return SecretRefUtils.isDopplerSecretRef(ref);
  }

  /**
   * Check if SecretRef is Sealed type
   */
  static isSealedSecretRef(ref: SecretRefUnion): ref is SealedSecretRef {
    return SecretRefUtils.isSealedSecretRef(ref);
  }
}
