// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK
import {
  DetailSecureTestResponse,
  SecureTestSignatureAlgorithmValue,
  SecureTestTypeValue,
} from '../../application/dtos';
import { SecretRef } from 'src/shared/infrastructure/secret-ref/secret-ref.types';
import {
  SecretRefUnion,
  DopplerSecretRef,
  SealedSecretRef,
  validateSecretRef,
  isDopplerSecretRef,
  isSealedSecretRef,
  createDopplerSecretRef,
  createSealedSecretRef,
} from 'src/shared/infrastructure/secret-ref/domain/sealed-secret-ref.types';
import { TenantContext } from 'src/shared/domain/tenant';

/**
 * SecureTest Field Validator Utility
 *
 * Centralized utility for parsing and validating SecureTest aggregate data from EventStore events.
 * Provides consistent field validation patterns that can be reused across repositories
 * and projectors for SecureTest domain operations.
 *
 * @domain Notification Context - SecureTest Field Validation Utility
 * @layer Infrastructure
 * @pattern Utility Pattern + Field Validation
 */
export class SecureTestFieldValidatorUtil {
  /**
   * Create a validated DetailSecureTestResponse from raw EventStore event data
   *
   * Uses modern safeParseJSON utilities and DTOs to maintain CQRS compliance.
   * This creates read model data for projections, not domain props.
   *
   * @param aggregateData - Raw event data from EventStore
   * @returns Validated DetailSecureTestResponse DTO with all required fields
   * @throws Error if required fields are missing or invalid
   */
  static createSecureTestSnapshotFromEventData(
    aggregateData: Record<string, any>,
  ): DetailSecureTestResponse & {
    version: number;
    createdAt: Date;
    updatedAt: Date;
  } {
    // Extract simple fields directly from event data
    const id = aggregateData.id as string;
    const name = aggregateData.name as string;
    const description = aggregateData.description as string;
    const type = aggregateData.type as SecureTestTypeValue;
    const signatureAlgorithm =
      aggregateData.signatureAlgorithm as SecureTestSignatureAlgorithmValue;

    // Extract version and timestamps with proper type conversion
    const version =
      typeof aggregateData.version === 'string'
        ? parseInt(aggregateData.version, 10)
        : (aggregateData.version as number);
    const createdAt =
      typeof aggregateData.createdAt === 'string'
        ? new Date(aggregateData.createdAt)
        : (aggregateData.createdAt as Date);
    const updatedAt =
      typeof aggregateData.updatedAt === 'string'
        ? new Date(aggregateData.updatedAt)
        : (aggregateData.updatedAt as Date);

    // Return SecretRef objects as JSON strings for Redis storage
    // This maintains backward compatibility with snapshot props structure
    // but stores encrypted SecretRef objects instead of plain text
    return {
      id,
      name,
      description,
      type,
      // For backward compatibility, still return the expected interface
      // but now with SecretRef support we'll add a new method for projector
      signingSecret: undefined,
      signatureAlgorithm,
      username: undefined,
      password: undefined,
      version,
      createdAt,
      updatedAt,
    };
  }

  /**
   * Create projector data with SecretRef objects for Redis storage
   *
   * This method extracts SecretRef objects from event data and serializes them
   * as JSON strings for storage in Redis. The reader repository will deserialize
   * and resolve these SecretRef objects back to actual secret values.
   *
   * @param aggregateData - Raw event data from EventStore containing SecretRef objects
   * @returns Projector data object with SecretRef fields as JSON strings
   */
  static createSecureTestProjectorDataFromEventData(
    aggregateData: Record<string, any>,
  ): {
    id: string;
    name: string;
    description?: string;
    type: SecureTestTypeValue;
    signingSecret?: string;
    signatureAlgorithm?: SecureTestSignatureAlgorithmValue;
    username?: string;
    password?: string;
    version: number;
    createdAt: Date;
    updatedAt: Date;
  } {
    // Extract simple fields directly from event data
    const id = aggregateData.id as string;
    const name = aggregateData.name as string;
    const description = aggregateData.description as string;
    const type = aggregateData.type as SecureTestTypeValue;
    const signatureAlgorithm =
      aggregateData.signatureAlgorithm as SecureTestSignatureAlgorithmValue;

    // Handle SecretRef objects from encrypted event data
    // The writer repository stores encrypted SecretRef objects in these fields
    const signingSecretRef = aggregateData.signingSecret
      ? JSON.stringify(aggregateData.signingSecret)
      : undefined;

    const usernameRef = aggregateData.username
      ? JSON.stringify(aggregateData.username)
      : undefined;

    const passwordRef = aggregateData.password
      ? JSON.stringify(aggregateData.password)
      : undefined;

    // Store plain text values directly for now (not encrypted)
    // This preserves the user-provided values per record
    // Extract credentials for validation (they're handled via SecretRef below)

    // Extract version and timestamps with proper type conversion
    const version =
      typeof aggregateData.version === 'string'
        ? parseInt(aggregateData.version, 10)
        : (aggregateData.version as number);
    const createdAt =
      typeof aggregateData.createdAt === 'string'
        ? new Date(aggregateData.createdAt)
        : (aggregateData.createdAt as Date);
    const updatedAt =
      typeof aggregateData.updatedAt === 'string'
        ? new Date(aggregateData.updatedAt)
        : (aggregateData.updatedAt as Date);

    return {
      id,
      name,
      description,
      type,
      signingSecret: signingSecretRef,
      signatureAlgorithm,
      username: usernameRef,
      password: passwordRef,
      version,
      createdAt,
      updatedAt,
    };
  }

  /**
   * Create a SecretRef object for storing sensitive data in Doppler with tenant-specific keys
   * @param baseKey - The base Doppler key for the secret (e.g., 'NOTIFICATION_SLACK_SIGNING_SECRET')
   * @param tenant - The tenant ID to create tenant-specific keys (defaults to 'core')
   * @returns SecretRef object that can be stored in events and resolved later
   */
  private static createSecretRef(
    baseKey: string,
    tenant: string = 'core',
  ): SecretRef {
    // Create tenant-specific key to ensure proper isolation
    // e.g., 'NOTIFICATION_SLACK_SIGNING_SECRET_CORE' for core tenant
    const tenantSpecificKey = `${baseKey}_${tenant.toUpperCase()}`;

    return {
      scheme: 'secret' as const,
      provider: 'doppler' as const,
      tenant, // Tenant from context
      namespace: 'notification', // Bounded context
      key: tenantSpecificKey,
    };
  }

  // ==============================================
  // PHASE 3.1: ENHANCED SECRETREF VALIDATION
  // ==============================================

  /**
   * Validate SecretRefUnion object (supports both doppler and sealed)
   */
  static validateSecretRefUnion(ref: unknown): ref is SecretRefUnion {
    return validateSecretRef(ref);
  }

  /**
   * Create a Doppler SecretRef with enhanced validation
   */
  static createDopplerSecretRefForField(
    baseKey: string,
    tenant: string = 'core',
  ): DopplerSecretRef {
    // Parse field path to extract namespace and key
    // Format: "notification.slack.token" -> namespace: "notification", key: "slack.token"
    const parts = baseKey.split('.');
    const namespace = parts[0] || 'default';
    const key = parts.slice(1).join('.') || baseKey;

    return createDopplerSecretRef(tenant, namespace, key, {
      version: 'latest',
      algHint: 'doppler-v1',
    });
  }

  /**
   * Create a Sealed SecretRef for new webhook configurations
   */
  static createSealedSecretRefForField(
    tenant: string,
    context: string,
    algorithm: 'XCHACHA20-POLY1305' | 'AES-256-GCM' = 'XCHACHA20-POLY1305',
  ): SealedSecretRef {
    const mockBlob = Buffer.from(`encrypted-${context}`).toString('base64');
    const kekKid = `TENANT_KEK_${tenant.toUpperCase()}_V1`;

    return createSealedSecretRef(tenant, kekKid, algorithm, mockBlob, {
      aad: context,
      v: 1,
    });
  }

  /**
   * Parse and validate SecretRef from stored JSON string
   */
  static parseSecretRefFromJSON(jsonString: string): SecretRefUnion | null {
    try {
      const parsed = JSON.parse(jsonString);

      if (this.validateSecretRefUnion(parsed)) {
        return parsed;
      }

      return null;
    } catch {
      return null;
    }
  }

  /**
   * Serialize SecretRef to JSON string for storage
   */
  static serializeSecretRefToJSON(ref: SecretRefUnion): string {
    if (!this.validateSecretRefUnion(ref)) {
      throw new Error('Invalid SecretRef cannot be serialized');
    }

    return JSON.stringify(ref);
  }

  /**
   * Check if SecretRef is Doppler type
   */
  static isDopplerSecretRef(ref: SecretRefUnion): ref is DopplerSecretRef {
    return isDopplerSecretRef(ref);
  }

  /**
   * Check if SecretRef is Sealed type
   */
  static isSealedSecretRef(ref: SecretRefUnion): ref is SealedSecretRef {
    return isSealedSecretRef(ref);
  }

  /**
   * Enhanced projector data creation with SecretRefUnion support
   */
  static createEnhancedSecureTestProjectorDataFromEventData(
    aggregateData: Record<string, any>,
    tenantContext?: TenantContext,
  ): {
    id: string;
    name: string;
    description?: string;
    type: SecureTestTypeValue;
    signingSecretRef?: string;
    signatureAlgorithm?: SecureTestSignatureAlgorithmValue;
    usernameRef?: string;
    passwordRef?: string;
    version: number;
    createdAt: Date;
    updatedAt: Date;
    // Metadata for mixed-mode operation
    secretRefTypes: {
      signingSecret?: 'doppler' | 'sealed';
      username?: 'doppler' | 'sealed';
      password?: 'doppler' | 'sealed';
    };
  } {
    // Extract simple fields directly from event data
    const id = aggregateData.id as string;
    const name = aggregateData.name as string;
    const description = aggregateData.description as string;
    const type = aggregateData.type as SecureTestTypeValue;
    const signatureAlgorithm =
      aggregateData.signatureAlgorithm as SecureTestSignatureAlgorithmValue;

    // Enhanced SecretRef handling with validation
    const signingSecretRef = aggregateData.signingSecretRef
      ? this.serializeSecretRefToJSON(
          this.parseSecretRefFromJSON(
            JSON.stringify(aggregateData.signingSecretRef),
          ) ||
            this.createDopplerSecretRefForField(
              'NOTIFICATION_SLACK_SIGNING_SECRET',
              tenantContext?.tenantId || 'core',
            ),
        )
      : undefined;

    const usernameRef = aggregateData.usernameRef
      ? this.serializeSecretRefToJSON(
          this.parseSecretRefFromJSON(
            JSON.stringify(aggregateData.usernameRef),
          ) ||
            this.createDopplerSecretRefForField(
              'NOTIFICATION_SLACK_USERNAME',
              tenantContext?.tenantId || 'core',
            ),
        )
      : undefined;

    const passwordRef = aggregateData.passwordRef
      ? this.serializeSecretRefToJSON(
          this.parseSecretRefFromJSON(
            JSON.stringify(aggregateData.passwordRef),
          ) ||
            this.createDopplerSecretRefForField(
              'NOTIFICATION_SLACK_PASSWORD',
              tenantContext?.tenantId || 'core',
            ),
        )
      : undefined;

    // Determine SecretRef types for metadata
    const secretRefTypes = {
      signingSecret: signingSecretRef
        ? this.isDopplerSecretRef(
            this.parseSecretRefFromJSON(signingSecretRef)!,
          )
          ? ('doppler' as const)
          : ('sealed' as const)
        : undefined,
      username: usernameRef
        ? this.isDopplerSecretRef(this.parseSecretRefFromJSON(usernameRef)!)
          ? ('doppler' as const)
          : ('sealed' as const)
        : undefined,
      password: passwordRef
        ? this.isDopplerSecretRef(this.parseSecretRefFromJSON(passwordRef)!)
          ? ('doppler' as const)
          : ('sealed' as const)
        : undefined,
    };

    // Extract version and timestamps with proper type conversion
    const version =
      typeof aggregateData.version === 'string'
        ? parseInt(aggregateData.version, 10)
        : (aggregateData.version as number);
    const createdAt =
      typeof aggregateData.createdAt === 'string'
        ? new Date(aggregateData.createdAt)
        : (aggregateData.createdAt as Date);
    const updatedAt =
      typeof aggregateData.updatedAt === 'string'
        ? new Date(aggregateData.updatedAt)
        : (aggregateData.updatedAt as Date);

    return {
      id,
      name,
      description,
      type,
      signingSecretRef,
      signatureAlgorithm,
      usernameRef,
      passwordRef,
      version,
      createdAt,
      updatedAt,
      secretRefTypes,
    };
  }

  /**
   * Migrate legacy SecretRef to new SecretRefUnion format
   */
  static migrateLegacySecretRef(
    legacyRef: SecretRef,
    tenantContext: TenantContext,
  ): SecretRefUnion {
    // If it's already a valid SecretRefUnion, return as-is
    if (this.validateSecretRefUnion(legacyRef)) {
      return legacyRef as SecretRefUnion;
    }

    // Otherwise, create a Doppler SecretRef from legacy format
    const key = String((legacyRef as any).key || 'UNKNOWN_KEY');
    const parts = key.split('.');
    const namespace = parts[0] || 'legacy';
    const secretKey = parts.slice(1).join('.') || key;

    return createDopplerSecretRef(
      tenantContext.tenantId,
      namespace,
      secretKey,
      {
        version: 'latest',
        algHint: 'legacy-migration',
      },
    );
  }
}
