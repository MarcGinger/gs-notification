// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK
import {
  DetailSecureTestResponse,
  SecureTestSignatureAlgorithmValue,
  SecureTestTypeValue,
} from '../../application/dtos';
import { SecretRef } from 'src/shared/infrastructure/secret-ref/secret-ref.types';
import {
  SecretRefUnion,
  DopplerSecretRef,
  SealedSecretRef,
  validateSecretRef,
  isDopplerSecretRef,
  isSealedSecretRef,
  createDopplerSecretRef,
  createSealedSecretRef,
} from 'src/shared/infrastructure/secret-ref/domain/sealed-secret-ref.types';

/**
 * SecureTest Field Validator Utility
 *
 * Centralized utility for parsing and validating SecureTest aggregate data from EventStore events.
 * Provides consistent field validation patterns that can be reused across repositories
 * and projectors for SecureTest domain operations.
 *
 * @domain Notification Context - SecureTest Field Validation Utility
 * @layer Infrastructure
 * @pattern Utility Pattern + Field Validation
 */
export class SecureTestFieldValidatorUtil {
  /**
   * Create a validated DetailSecureTestResponse from raw EventStore event data
   *
   * Uses modern safeParseJSON utilities and DTOs to maintain CQRS compliance.
   * This creates read model data for projections, not domain props.
   *
   * @param aggregateData - Raw event data from EventStore
   * @returns Validated DetailSecureTestResponse DTO with all required fields
   * @throws Error if required fields are missing or invalid
   */
  static createSecureTestSnapshotFromEventData(
    aggregateData: Record<string, any>,
  ): DetailSecureTestResponse & {
    version: number;
    createdAt: Date;
    updatedAt: Date;
  } {
    // Extract simple fields directly from event data
    const id = aggregateData.id as string;
    const name = aggregateData.name as string;
    const description = aggregateData.description as string;
    const type = aggregateData.type as SecureTestTypeValue;
    const signatureAlgorithm =
      aggregateData.signatureAlgorithm as SecureTestSignatureAlgorithmValue;

    // Extract version and timestamps with proper type conversion
    const version =
      typeof aggregateData.version === 'string'
        ? parseInt(aggregateData.version, 10)
        : (aggregateData.version as number);
    const createdAt =
      typeof aggregateData.createdAt === 'string'
        ? new Date(aggregateData.createdAt)
        : (aggregateData.createdAt as Date);
    const updatedAt =
      typeof aggregateData.updatedAt === 'string'
        ? new Date(aggregateData.updatedAt)
        : (aggregateData.updatedAt as Date);

    // Return SecretRef objects as JSON strings for Redis storage
    // This maintains backward compatibility with snapshot props structure
    // but stores encrypted SecretRef objects instead of plain text
    return {
      id,
      name,
      description,
      type,
      // For backward compatibility, still return the expected interface
      // but now with SecretRef support we'll add a new method for projector
      signingSecret: undefined,
      signatureAlgorithm,
      username: undefined,
      password: undefined,
      version,
      createdAt,
      updatedAt,
    };
  }

  /**
   * Create projector data with SecretRef objects for Redis storage
   *
   * This method extracts SecretRef objects from event data and serializes them
   * as JSON strings for storage in Redis. The reader repository will deserialize
   * and resolve these SecretRef objects back to actual secret values.
   *
   * @param aggregateData - Raw event data from EventStore containing SecretRef objects
   * @returns Projector data object with SecretRef fields as JSON strings
   */
  static createSecureTestProjectorDataFromEventData(
    aggregateData: Record<string, any>,
  ): {
    id: string;
    name: string;
    description?: string;
    type: SecureTestTypeValue;
    signingSecret?: string;
    signatureAlgorithm?: SecureTestSignatureAlgorithmValue;
    username?: string;
    password?: string;
    version: number;
    createdAt: Date;
    updatedAt: Date;
  } {
    // Extract simple fields directly from event data
    const id = aggregateData.id as string;
    const name = aggregateData.name as string;
    const description = aggregateData.description as string;
    const type = aggregateData.type as SecureTestTypeValue;
    const signatureAlgorithm =
      aggregateData.signatureAlgorithm as SecureTestSignatureAlgorithmValue;

    // Handle SecretRef objects from encrypted event data
    // The writer repository stores encrypted SecretRef objects in these fields
    const signingSecretRef = aggregateData.signingSecret
      ? JSON.stringify(aggregateData.signingSecret)
      : undefined;

    const usernameRef = aggregateData.username
      ? JSON.stringify(aggregateData.username)
      : undefined;

    const passwordRef = aggregateData.password
      ? JSON.stringify(aggregateData.password)
      : undefined;

    // Store plain text values directly for now (not encrypted)
    // This preserves the user-provided values per record
    // Extract credentials for validation (they're handled via SecretRef below)

    // Extract version and timestamps with proper type conversion
    const version =
      typeof aggregateData.version === 'string'
        ? parseInt(aggregateData.version, 10)
        : (aggregateData.version as number);
    const createdAt =
      typeof aggregateData.createdAt === 'string'
        ? new Date(aggregateData.createdAt)
        : (aggregateData.createdAt as Date);
    const updatedAt =
      typeof aggregateData.updatedAt === 'string'
        ? new Date(aggregateData.updatedAt)
        : (aggregateData.updatedAt as Date);

    return {
      id,
      name,
      description,
      type,
      signingSecret: signingSecretRef,
      signatureAlgorithm,
      username: usernameRef,
      password: passwordRef,
      version,
      createdAt,
      updatedAt,
    };
  }

  // ==============================================
  // PHASE 3.1: ENHANCED SECRETREF VALIDATION
  // ==============================================

  /**
   * Validate SecretRefUnion object (supports both doppler and sealed)
   */
  static validateSecretRefUnion(ref: unknown): ref is SecretRefUnion {
    return validateSecretRef(ref);
  }

  /**
   * Create a Doppler SecretRef with enhanced validation
   */
  static createDopplerSecretRefForField(
    baseKey: string,
    tenant: string = 'core',
  ): DopplerSecretRef {
    // Parse field path to extract namespace and key
    // Format: "notification.slack.token" -> namespace: "notification", key: "slack.token"
    const parts = baseKey.split('.');
    const namespace = parts[0] || 'default';
    const key = parts.slice(1).join('.') || baseKey;

    return createDopplerSecretRef(tenant, namespace, key, {
      version: 'latest',
      algHint: 'doppler-v1',
    });
  }

  /**
   * Create a Sealed SecretRef for new webhook configurations
   */
  static createSealedSecretRefForField(
    tenant: string,
    context: string,
    algorithm: 'XCHACHA20-POLY1305' | 'AES-256-GCM' = 'XCHACHA20-POLY1305',
  ): SealedSecretRef {
    const mockBlob = Buffer.from(`encrypted-${context}`).toString('base64');
    const kekKid = `TENANT_KEK_${tenant.toUpperCase()}_V1`;

    return createSealedSecretRef(tenant, kekKid, algorithm, mockBlob, {
      aad: context,
      v: 1,
    });
  }

  /**
   * Parse and validate SecretRef from stored JSON string
   */
  static parseSecretRefFromJSON(jsonString: string): SecretRefUnion | null {
    try {
      const parsed = JSON.parse(jsonString);

      if (this.validateSecretRefUnion(parsed)) {
        return parsed;
      }

      return null;
    } catch {
      return null;
    }
  }

  /**
   * Serialize SecretRef to JSON string for storage
   */
  static serializeSecretRefToJSON(ref: SecretRefUnion): string {
    if (!this.validateSecretRefUnion(ref)) {
      throw new Error('Invalid SecretRef cannot be serialized');
    }

    return JSON.stringify(ref);
  }

  /**
   * Check if SecretRef is Doppler type
   */
  static isDopplerSecretRef(ref: SecretRefUnion): ref is DopplerSecretRef {
    return isDopplerSecretRef(ref);
  }

  /**
   * Check if SecretRef is Sealed type
   */
  static isSealedSecretRef(ref: SecretRefUnion): ref is SealedSecretRef {
    return isSealedSecretRef(ref);
  }
}
