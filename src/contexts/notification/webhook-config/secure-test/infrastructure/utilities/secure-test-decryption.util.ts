// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { Log, Logger } from 'src/shared/logging';
import { ActorContext } from 'src/shared/application/context';
import { EventEncryptionFactory } from 'src/shared/infrastructure/encryption';
import { SecureTestEncryptionConfig } from '../encryption/secure-test-encryption.config';

/**
 * SecureTest Decryption Utility
 *
 * Centralized utility for parsing and decrypting SecretRef fields from Redis storage.
 * This utility handles the common pattern of:
 * 1. Parsing JSON strings back to SecretRef objects
 * 2. Creating domain event structure for SecretRefStrategy
 * 3. Decrypting using EventEncryptionFactory
 * 4. Converting results back to string values for repository interfaces
 *
 * Used by both SecureTestQueryRepository and SecureTestReaderRepository
 * to eliminate code duplication and ensure consistent decryption behavior.
 *
 * @domain Notification Context - SecureTest Decryption Utility
 * @layer Infrastructure
 * @pattern Utility Pattern + Shared Decryption Logic
 */
export class SecureTestDecryptionUtil {
  /**
   * Parse and decrypt SecretRef fields using EventEncryptionFactory
   *
   * The repository layer has no knowledge of encryption formats - the factory handles
   * all encryption/decryption logic. This utility creates the proper domain event
   * structure required by SecretRefStrategy and handles the conversion of results
   * back to string values for repository interfaces.
   *
   * @param secretFields - Record of field names to encrypted values (JSON strings or plain strings)
   * @param actor - Actor context for decryption
   * @param eventEncryptionFactory - Factory for handling encryption/decryption operations
   * @param logger - Logger instance for error reporting
   * @returns Promise resolving to record of field names to decrypted string values
   */
  static async decryptSecretRefFields(
    secretFields: Record<string, string | undefined>,
    actor: ActorContext,
    eventEncryptionFactory: EventEncryptionFactory,
    logger: Logger,
  ): Promise<Record<string, string | undefined>> {
    try {
      // Parse JSON strings back to objects (if they are JSON)
      const parsedFields: Record<string, unknown> = {};

      for (const [key, value] of Object.entries(secretFields)) {
        if (value) {
          try {
            // Try to parse as JSON
            const parsed = JSON.parse(value) as unknown;
            parsedFields[key] = parsed;
          } catch {
            // Not JSON, treat as plain string
            parsedFields[key] = value;
          }
        }
      }

      // Create proper domain event structure for SecretRefStrategy
      const mockDomainEvent = {
        type: 'SecureTestQuery',
        data: parsedFields,
        aggregateId: `query-${actor.tenant}-${Date.now()}`,
      };
      const secretConfig = SecureTestEncryptionConfig.createSecretRefConfig();

      const decryptionResult = await eventEncryptionFactory.decryptEvents(
        [mockDomainEvent],
        actor,
        secretConfig,
      );

      // Extract data from the domain event structure
      const decryptedEvent = decryptionResult.events[0];
      const decryptedResult = decryptedEvent?.data || parsedFields;

      // Convert the result to string values for the repository interface
      const result: Record<string, string | undefined> = {};

      for (const [key, value] of Object.entries(decryptedResult)) {
        if (typeof value === 'string') {
          result[key] = value;
        } else if (value === null || value === undefined) {
          result[key] = undefined;
        } else {
          // EventEncryptionFactory should have decrypted this to a string
          // If it returned an object, that indicates the factory needs to be fixed
          result[key] = JSON.stringify(value);
        }
      }

      return result;
    } catch (error) {
      Log.error(logger, 'Failed to decrypt fields', {
        method: 'SecureTestDecryptionUtil.decryptSecretRefFields',
        error: (error as Error).message,
        fieldKeys: Object.keys(secretFields),
      });
      // Return original values on error
      return secretFields;
    }
  }

  /**
   * Decrypt specific SecureTest fields commonly used across repositories
   *
   * Convenience wrapper for the most common SecureTest field decryption pattern.
   * Handles the standard fields: signingSecret, username, password.
   *
   * @param secureTestData - Object containing encrypted SecureTest fields
   * @param actor - Actor context for decryption
   * @param eventEncryptionFactory - Factory for handling encryption/decryption operations
   * @param logger - Logger instance for error reporting
   * @returns Promise resolving to decrypted field values
   */
  static async decryptSecureTestFields(
    secureTestData: {
      signingSecret?: string;
      username?: string;
      password?: string;
    },
    actor: ActorContext,
    eventEncryptionFactory: EventEncryptionFactory,
    logger: Logger,
  ): Promise<{
    signingSecret?: string;
    username?: string;
    password?: string;
  }> {
    const decryptedFields = await this.decryptSecretRefFields(
      {
        signingSecret: secureTestData.signingSecret,
        username: secureTestData.username,
        password: secureTestData.password,
      },
      actor,
      eventEncryptionFactory,
      logger,
    );

    return {
      signingSecret: decryptedFields.signingSecret,
      username: decryptedFields.username,
      password: decryptedFields.password,
    };
  }
}
