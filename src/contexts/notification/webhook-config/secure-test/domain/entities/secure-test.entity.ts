// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { EntityIdBase } from 'src/shared/domain/entities';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { SecureTestSnapshotProps } from '../props';
import { SecureTestDomainState } from '../state';
import { SecureTestErrors } from '../errors/secure-test.errors';
import {
  SecureTestCreatedAt,
  SecureTestUpdatedAt,
  SecureTestVersion,
  SecureTestDescription,
  SecureTestId,
  SecureTestName,
  SecureTestPassword,
  SecureTestSignatureAlgorithm,
  SecureTestSignatureAlgorithmLogic,
  SecureTestSigningSecret,
  SecureTestType,
  SecureTestTypeLogic,
  SecureTestUsername,
  createSecureTestSignatureAlgorithm,
  createSecureTestType,
} from '../value-objects';
import { SecureTestSecretRef } from '../value-objects/secure-test-secret-ref.vo';

/**
 * Domain Entity: SecureTest
 *
 * Represents the core SecureTest entity in the notification domain.
 * Encapsulates secureTest data, identity, and basic entity behavior.
 *
 * This entity follows DDD principles:
 * - Identity: Id as unique identifier
 * - Immutability: Changes create new instances
 * - Encapsulation: Private state with controlled access
 * - Business validation: Domain rules enforced
 *
 * @domain Notification Context - SecureTest Entity
 * @layer Domain Entities
 */

/**
 * SecureTest Entity
 *
 * Core domain entity representing a secureTest in the notification.
 * Handles secureTest identity, validation, and state management.
 */
export class SecureTestEntity extends EntityIdBase<
  SecureTestDomainState,
  SecureTestId
> {
  private static clock: { now: () => Date } = { now: () => new Date() };

  public static setClock(c: { now: () => Date }) {
    this.clock = c;
  }

  /**
   * Helper method to create updatedAt VO from date
   */
  private static createUpdatedAt(
    date?: Date,
  ): Result<SecureTestUpdatedAt, DomainError> {
    const targetDate = date || SecureTestEntity.clock.now();
    const result = SecureTestUpdatedAt.from(targetDate);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create version VO from number
   */
  private static createVersion(
    versionNumber?: number,
    currentVersion?: SecureTestVersion,
  ): Result<SecureTestVersion, DomainError> {
    const targetVersion = versionNumber ?? currentVersion?.value ?? 1;
    const result = SecureTestVersion.from(targetVersion);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create updated entity with common logic
   */
  private createUpdatedEntity(
    fieldUpdates: Partial<SecureTestDomainState>,
    updatedAt?: Date,
    version?: number,
  ): Result<SecureTestEntity, DomainError> {
    const updatedAtResult = SecureTestEntity.createUpdatedAt(updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = SecureTestEntity.createVersion(
      version,
      this.props.version,
    );
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const updatedProps: SecureTestDomainState = {
      ...this.props,
      ...fieldUpdates,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return SecureTestEntity.create(updatedProps);
  }

  private constructor(props: SecureTestDomainState) {
    super(props, props.id);
  }

  /**
   * Factory method to create a new secureTest entity
   *
   * @param props - SecureTest properties
   * @returns Result containing SecureTestEntity or DomainError
   */
  public static create(
    props: SecureTestDomainState,
  ): Result<SecureTestEntity, DomainError> {
    // Validate required properties
    const validationResult = SecureTestEntity.validate(props);
    if (validationResult.ok === false) {
      return err(validationResult.error);
    }

    return ok(new SecureTestEntity(props));
  }

  /**
   * Factory method to reconstitute a secureTest entity from persistence
   *
   * @param props - SecureTest properties from database
   * @returns SecureTestEntity instance
   */
  public static reconstitute(props: SecureTestDomainState): SecureTestEntity {
    return new SecureTestEntity(props);
  }

  /**
   * Factory method to reconstitute entity from snapshot
   *
   * @param snapshot - SecureTest snapshot properties
   * @returns Result containing SecureTestEntity or DomainError
   */
  public static fromSnapshot(
    snapshot: SecureTestSnapshotProps,
  ): Result<SecureTestEntity, DomainError> {
    const idResult = SecureTestId.from(snapshot.id);
    if (!idResult.ok) {
      return err(idResult.error);
    }
    const nameResult = SecureTestName.from(snapshot.name);
    if (!nameResult.ok) {
      return err(nameResult.error);
    }
    const descriptionResult = SecureTestDescription.from(snapshot.description);
    if (!descriptionResult.ok) {
      return err(descriptionResult.error);
    }
    const typeResult = createSecureTestType(snapshot.type);
    if (!typeResult.ok) {
      return err(typeResult.error);
    }
    const signingSecretResult = SecureTestSigningSecret.from(
      snapshot.signingSecret,
    );
    if (!signingSecretResult.ok) {
      return err(signingSecretResult.error);
    }
    const signatureAlgorithmResult = createSecureTestSignatureAlgorithm(
      snapshot.signatureAlgorithm,
    );
    if (!signatureAlgorithmResult.ok) {
      return err(signatureAlgorithmResult.error);
    }
    const usernameResult = SecureTestUsername.from(snapshot.username);
    if (!usernameResult.ok) {
      return err(usernameResult.error);
    }
    const passwordResult = SecureTestPassword.from(snapshot.password);
    if (!passwordResult.ok) {
      return err(passwordResult.error);
    }
    const createdAtResult = SecureTestCreatedAt.from(snapshot.createdAt);
    if (!createdAtResult.ok) {
      return err(createdAtResult.error);
    }

    const updatedAtResult = SecureTestUpdatedAt.from(snapshot.updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = SecureTestVersion.from(snapshot.version);
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const props: SecureTestDomainState = {
      id: idResult.value,
      name: nameResult.value,
      description: descriptionResult.value,
      type: typeResult.value,
      signingSecretRef: undefined, // TODO: Convert StringVO to SecretRef
      signatureAlgorithm: signatureAlgorithmResult.value,
      usernameRef: undefined, // TODO: Convert StringVO to SecretRef
      passwordRef: undefined, // TODO: Convert StringVO to SecretRef
      createdAt: createdAtResult.value,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return SecureTestEntity.create(props);
  }

  /**
   * Validates secureTest entity properties
   *
   * @param props - Properties to validate
   * @returns Validation result
   */
  private static validate(
    props: SecureTestDomainState,
  ): Result<void, DomainError> {
    // Basic validation
    if (!props.id) {
      return err(SecureTestErrors.INVALID_ID_DATA);
    }
    if (!props.name) {
      return err(SecureTestErrors.INVALID_NAME_DATA);
    }
    if (!props.type) {
      return err(SecureTestErrors.INVALID_TYPE_DATA);
    }

    return ok(undefined);
  }

  // ======================
  // Getters (Public API)
  // ======================

  public get id(): SecureTestId {
    return this.props.id;
  }

  public get name(): SecureTestName {
    return this.props.name;
  }

  public get description(): SecureTestDescription | undefined {
    return this.props.description;
  }

  public get type(): SecureTestType {
    return this.props.type;
  }

  public get signingSecret(): SecureTestSecretRef | undefined {
    return this.props.signingSecretRef;
  }

  public get signatureAlgorithm(): SecureTestSignatureAlgorithm | undefined {
    return this.props.signatureAlgorithm;
  }

  public get username(): SecureTestSecretRef | undefined {
    return this.props.usernameRef;
  }

  public get password(): SecureTestSecretRef | undefined {
    return this.props.passwordRef;
  }

  public get createdAt(): SecureTestCreatedAt {
    return this.props.createdAt;
  }

  public get updatedAt(): SecureTestUpdatedAt {
    return this.props.updatedAt;
  }

  public get version(): SecureTestVersion {
    return this.props.version;
  }

  // ======================
  // Simple Update Methods (No Business Logic)
  // ======================

  /**
   * Creates a new entity with updated name (pure state transition)
   *
   * @param name - New name value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<SecureTestEntity, DomainError>
   */
  public withName(
    name: SecureTestName,
    updatedAt?: Date,
    version?: number,
  ): Result<SecureTestEntity, DomainError> {
    return this.createUpdatedEntity({ name }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated description (pure state transition)
   *
   * @param description - New description value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<SecureTestEntity, DomainError>
   */
  public withDescription(
    description: SecureTestDescription,
    updatedAt?: Date,
    version?: number,
  ): Result<SecureTestEntity, DomainError> {
    return this.createUpdatedEntity({ description }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated type (with basic transition validation)
   *
   * @param type - New type value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<SecureTestEntity, DomainError>
   */
  public withType(
    type: SecureTestType,
    updatedAt?: Date,
    version?: number,
  ): Result<SecureTestEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    const currentStatus = this.props.type.value;
    const targetStatus = type.value;

    if (!SecureTestTypeLogic.canTransition(currentStatus, targetStatus)) {
      return err({
        ...SecureTestErrors.INVALID_TYPE_TRANSITION,
        context: {
          currentStatus,
          targetStatus,
          validTransitions:
            SecureTestTypeLogic.getValidTransitions(currentStatus),
        },
      });
    }

    return this.createUpdatedEntity({ type }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated signingSecret (pure state transition)
   *
   * @param signingSecret - New signingSecret value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<SecureTestEntity, DomainError>
   */
  public withSigningSecret(
    signingSecret: SecureTestSigningSecret,
    updatedAt?: Date,
    version?: number,
  ): Result<SecureTestEntity, DomainError> {
    // TODO: Convert StringVO to SecretRef before update
    return this.createUpdatedEntity({}, updatedAt, version);
  }

  /**
   * Creates a new entity with updated signatureAlgorithm (with basic transition validation)
   *
   * @param signatureAlgorithm - New signatureAlgorithm value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<SecureTestEntity, DomainError>
   */
  public withSignatureAlgorithm(
    signatureAlgorithm: SecureTestSignatureAlgorithm,
    updatedAt?: Date,
    version?: number,
  ): Result<SecureTestEntity, DomainError> {
    // Basic validation - business rules handled by aggregate
    if (this.props.signatureAlgorithm) {
      // If current status exists, validate transition
      const currentStatus = this.props.signatureAlgorithm.value;
      const targetStatus = signatureAlgorithm.value;

      if (
        !SecureTestSignatureAlgorithmLogic.canTransition(
          currentStatus,
          targetStatus,
        )
      ) {
        return err({
          ...SecureTestErrors.INVALID_SIGNATURE_ALGORITHM_TRANSITION,
          context: {
            currentStatus,
            targetStatus,
            validTransitions:
              SecureTestSignatureAlgorithmLogic.getValidTransitions(
                currentStatus,
              ),
          },
        });
      }
    }

    return this.createUpdatedEntity({ signatureAlgorithm }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated username (pure state transition)
   *
   * @param username - New username value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<SecureTestEntity, DomainError>
   */
  public withUsername(
    username: SecureTestUsername,
    updatedAt?: Date,
    version?: number,
  ): Result<SecureTestEntity, DomainError> {
    // TODO: Convert StringVO to SecretRef before update
    return this.createUpdatedEntity({}, updatedAt, version);
  }

  /**
   * Creates a new entity with updated password (pure state transition)
   *
   * @param password - New password value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<SecureTestEntity, DomainError>
   */
  public withPassword(
    password: SecureTestPassword,
    updatedAt?: Date,
    version?: number,
  ): Result<SecureTestEntity, DomainError> {
    // TODO: Convert StringVO to SecretRef before update
    return this.createUpdatedEntity({}, updatedAt, version);
  }

  // ======================
  // Query Methods
  // ======================

  /**
   * Checks if two secureTests are the same entity
   *
   * @param other - Other secureTest to compare
   */
  public sameAs(other: SecureTestEntity): boolean {
    return this.props.id.equals(other.props.id);
  }

  /**
   * Gets a snapshot of current entity state for serialization
   */
  public toSnapshot(): SecureTestSnapshotProps {
    return {
      id: this.props.id.value,
      name: this.props.name.value,
      description: this.props.description?.value,
      type: this.props.type.value,
      signingSecret: this.props.signingSecretRef?.ref.key,
      signatureAlgorithm: this.props.signatureAlgorithm?.value,
      username: this.props.usernameRef?.ref.key,
      password: this.props.passwordRef?.ref.key,
      createdAt: this.props.createdAt.value,
      updatedAt: this.props.updatedAt.value,
      version: this.props.version.value,
    };
  }

  /**
   * Gets the current domain state with value objects
   *
   * Provides access to the rich domain state for application layer
   * without requiring infrastructure mappers. Maintains clean architecture.
   *
   * @returns Current domain state with value objects
   */
  public getDomainState(): SecureTestDomainState {
    return this.props;
  }
}
