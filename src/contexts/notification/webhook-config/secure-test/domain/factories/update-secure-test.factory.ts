// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, ok, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { SecureTestAggregate } from '../aggregates';
import { SecureTestEntity } from '../entities';
import { SecureTestSnapshotProps, UpdateSecureTestProps } from '../props';
import { ValidatedSecureTestUpdateFields } from '../types';
import {
  SecureTestName,
  SecureTestDescription,
  createSecureTestType,
  SecureTestSigningSecret,
  createSecureTestSignatureAlgorithm,
  SecureTestUsername,
  SecureTestPassword,
  SecureTestOptions,
} from '../value-objects';

/**
 * Update SecureTest Aggregate Factory
 *
 * Handles the complete update flow for SecureTest aggregates:
 * 1. Loads existing aggregate from snapshot
 * 2. Validates update properties and creates value objects
 * 3. Applies updates with proper business rule enforcement
 * 4. Returns updated aggregate ready for persistence
 *
 * This factory provides:
 * - Consistent update pattern matching create operations
 * - Centralized validation and business logic
 * - Efficient batch updates vs field-by-field
 * - Proper error context and logging integration
 */
export function updateSecureTestAggregateFromSnapshot(
  existingSnapshot: SecureTestSnapshotProps,
  updateProps: UpdateSecureTestProps,
  metadata: EventMetadata,
  clock: Clock,
): Result<SecureTestAggregate, DomainError> {
  // 1. Reconstitute existing aggregate
  const entityResult = SecureTestEntity.fromSnapshot(existingSnapshot);
  if (!entityResult.ok) {
    return err(
      withContext(entityResult.error, {
        operation: 'update_secure_test_reconstitute',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
      }),
    );
  }

  const existingAggregate = SecureTestAggregate.reconstitute(
    entityResult.value,
    clock,
    metadata,
  );

  // 2. Validate and apply updates for each provided field
  const validatedFields: ValidatedSecureTestUpdateFields = {};

  // Validate name if provided
  if (updateProps.name !== undefined) {
    const nameResult = SecureTestName.from(updateProps.name);
    if (!nameResult.ok) {
      return err(
        withContext(nameResult.error, {
          operation: 'update_secure_test_name_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedName: updateProps.name,
        }),
      );
    }
    validatedFields.name = nameResult.value;
  }

  // Validate description if provided
  if (updateProps.description !== undefined) {
    const descriptionResult = SecureTestDescription.from(
      updateProps.description,
    );
    if (!descriptionResult.ok) {
      return err(
        withContext(descriptionResult.error, {
          operation: 'update_secure_test_description_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedDescription: updateProps.description,
        }),
      );
    }
    validatedFields.description = descriptionResult.value;
  }

  // Validate type if provided
  if (updateProps.type !== undefined) {
    const typeResult = createSecureTestType(updateProps.type);
    if (!typeResult.ok) {
      return err(
        withContext(typeResult.error, {
          operation: 'update_secure_test_type_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedType: updateProps.type,
        }),
      );
    }
    validatedFields.type = typeResult.value;
  }

  // Validate signingSecret if provided
  if (updateProps.signingSecret !== undefined) {
    const signingSecretResult = SecureTestSigningSecret.from(
      updateProps.signingSecret,
    );
    if (!signingSecretResult.ok) {
      return err(
        withContext(signingSecretResult.error, {
          operation: 'update_secure_test_signing_secret_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedSigningSecret: updateProps.signingSecret,
        }),
      );
    }
    validatedFields.signingSecret = signingSecretResult.value;
  }

  // Validate signatureAlgorithm if provided
  if (updateProps.signatureAlgorithm !== undefined) {
    const signatureAlgorithmResult = createSecureTestSignatureAlgorithm(
      updateProps.signatureAlgorithm,
    );
    if (!signatureAlgorithmResult.ok) {
      return err(
        withContext(signatureAlgorithmResult.error, {
          operation: 'update_secure_test_signature_algorithm_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedSignatureAlgorithm: updateProps.signatureAlgorithm,
        }),
      );
    }
    validatedFields.signatureAlgorithm = signatureAlgorithmResult.value;
  }

  // Validate username if provided
  if (updateProps.username !== undefined) {
    const usernameResult = SecureTestUsername.from(updateProps.username);
    if (!usernameResult.ok) {
      return err(
        withContext(usernameResult.error, {
          operation: 'update_secure_test_username_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedUsername: updateProps.username,
        }),
      );
    }
    validatedFields.username = usernameResult.value;
  }

  // Validate password if provided
  if (updateProps.password !== undefined) {
    const passwordResult = SecureTestPassword.from(updateProps.password);
    if (!passwordResult.ok) {
      return err(
        withContext(passwordResult.error, {
          operation: 'update_secure_test_password_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedPassword: updateProps.password,
        }),
      );
    }
    validatedFields.password = passwordResult.value;
  }

  // Validateoptions if provided
  if (updateProps.options !== undefined) {
    const optionsResult = SecureTestOptions.update(updateProps.options);
    if (!optionsResult.ok) {
      return err(
        withContext(optionsResult.error, {
          operation: 'update_secure_test_options_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedOptions: updateProps.options,
        }),
      );
    }

    validatedFields.options = optionsResult.value;
  }

  // 3. Apply all validated changes in single atomic operation
  const batchUpdateResult = existingAggregate.updateBatch(validatedFields);
  if (!batchUpdateResult.ok) {
    return err(
      withContext(batchUpdateResult.error, {
        operation: 'update_product_batch_application',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        fieldsUpdated: Object.keys(validatedFields),
      }),
    );
  }

  return ok(existingAggregate);
}
