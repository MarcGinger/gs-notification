// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { SecureTestAggregate } from '../aggregates';
import { CreateSecureTestProps, SecureTestProps } from '../props';
import { SecureTestDomainState } from '../state';
import {
  SecureTestCreatedAt,
  SecureTestUpdatedAt,
  SecureTestVersion,
  SecureTestId,
  SecureTestName,
  SecureTestDescription,
  createSecureTestType,
  createSecureTestSignatureAlgorithm,
} from '../value-objects';

/**
 * Enhanced secureTest entity factory with comprehensive validation and security context
 * Moved from application layer to properly separate business concerns
 */
export function createSecureTestAggregateFromProps(
  props: SecureTestProps,
  metadata: EventMetadata,
  clock: Clock,
  // validatedEntities?: {
  //  channels?: ChannelReference[];
  // },
): Result<SecureTestAggregate, DomainError> {
  // Validate each property by creating value objects
  const idResult = SecureTestId.from(props.id);
  if (!idResult.ok) {
    return err(
      withContext(idResult.error, {
        ...idResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_secure_test',
        id: props.id,
      }),
    );
  }

  const nameResult = SecureTestName.from(props.name);
  if (!nameResult.ok) {
    return err(
      withContext(nameResult.error, {
        ...nameResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_secure_test',
        name: props.name,
      }),
    );
  }

  const descriptionResult = SecureTestDescription.from(props.description);
  if (!descriptionResult.ok) {
    return err(
      withContext(descriptionResult.error, {
        ...descriptionResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_secure_test',
        description: props.description,
      }),
    );
  }

  const typeResult = createSecureTestType(props.type);
  if (!typeResult.ok) {
    return err(
      withContext(typeResult.error, {
        ...typeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_secure_test',
        type: props.type,
      }),
    );
  }

  // For SecretRef, we don't validate the secret content here
  // The SecretRef itself is the validated reference
  const signingSecretRef = props.signingSecretRef;

  const signatureAlgorithmResult = createSecureTestSignatureAlgorithm(
    props.signatureAlgorithm,
  );
  if (!signatureAlgorithmResult.ok) {
    return err(
      withContext(signatureAlgorithmResult.error, {
        ...signatureAlgorithmResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_secure_test',
        signatureAlgorithm: props.signatureAlgorithm,
      }),
    );
  }

  // For SecretRef, we use the references directly
  const usernameRef = props.usernameRef;
  const passwordRef = props.passwordRef;

  const createdAtResult = SecureTestCreatedAt.create(clock.now());
  if (!createdAtResult.ok) {
    return err(createdAtResult.error);
  }

  const updatedAtResult = SecureTestUpdatedAt.create(clock.now());
  if (!updatedAtResult.ok) {
    return err(updatedAtResult.error);
  }

  const versionResult = SecureTestVersion.create(1); // Initial version is 1
  if (!versionResult.ok) {
    return err(versionResult.error);
  }

  // Create the entity properties with validated value objects
  const entityProps: SecureTestDomainState = {
    id: idResult.value,
    name: nameResult.value,
    description: descriptionResult.value,
    type: typeResult.value,
    signingSecretRef: signingSecretRef,
    signatureAlgorithm: signatureAlgorithmResult.value,
    usernameRef: usernameRef,
    passwordRef: passwordRef,
    createdAt: createdAtResult.value,
    updatedAt: updatedAtResult.value,
    version: versionResult.value,
  };

  // Create the entity using the constructor
  return SecureTestAggregate.create(entityProps, clock, metadata);
}
