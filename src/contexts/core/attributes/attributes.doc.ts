// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { INestApplication } from '@nestjs/common';
import { SwaggerConfigUtil } from 'src/docs/swagger-config.util';

/**
 * core attributes application/service Documentation
 * This module handles the Swagger documentation for cores
 *
 */
export class AttributesApplicationDocumentation {
  static setup(app: INestApplication, port: string | number): void {
    const config = new DocumentBuilder()
      .addBearerAuth(
        { type: 'http', scheme: 'bearer', bearerFormat: 'JWT' },
        'bearer',
      )
      .setTitle(`Attribute rule set management`)
      .setDescription(
        `
## bounded context: core
[‚Üê Back to documentation](/api/docs/core)

# üìò Attribute Rule Set Service ‚Äî Detailed Description

## 1. Purpose and Overview

The **Attribute Rule Set Service** is a foundational microservice responsible for defining, governing, and exposing **reusable sets of attribute rules** that can be applied across multiple domains. Instead of each bounded context inventing its own way of describing dynamic fields, this service provides a **central catalog of rule sets** that describe *how attributes should behave* (type, constraints, validation messages, etc.).

Where other services manage concrete entities (Lookup, Person, Company, Customer, Supplier, Employer, etc.), the Attribute Rule Set Service manages **metadata about attributes**:

* What fields exist (by code and name)
* What type each field is (string, boolean, integer, currency, date, datetime, other)
* Which fields are required or unique
* Which fields must match a regex pattern
* Which fields are reserved or used as references

By centralizing attribute rule sets, the service ensures that all domains implement their dynamic attributes **consistently and with shared validation logic**.

---

## 2. Core Responsibilities

### 2.1 Attribute Rule Set Management

* Define reusable **attribute rule sets**, each identified by a unique &#x60;code&#x60;.
* Each rule set contains a **map of attribute rules**, keyed by attribute code.
* Manage lifecycle operations:

  * Create, update, enable/disable, and (soft) delete rule sets.
* Support per-tenant customization of rule sets where needed.

### 2.2 Attribute Rule Definition

For each attribute in a rule set, the service defines:

* **Identity &amp; description**

  * &#x60;code&#x60; ‚Äî technical identifier for the attribute (e.g. &#x60;email&#x60;, &#x60;risk_level&#x60;).
  * &#x60;name&#x60; ‚Äî user-facing label (e.g. &quot;Email&quot;, &quot;Risk Level&quot;).
  * &#x60;description&#x60; ‚Äî human-readable explanation and business context.

* **Type &amp; behavior**

  * &#x60;type&#x60; ‚Äî one of &#x60;string | boolean | integer | currency | date | datetime | other&#x60;.
  * &#x60;reference&#x60; ‚Äî whether this field is a reference/search key.
  * &#x60;reserved&#x60; ‚Äî protects attributes that must not be removed or radically changed.

* **Validation rules**

  * &#x60;required&#x60; ‚Äî whether the field must always be present.
  * &#x60;requiredError&#x60; ‚Äî error message shown when required validation fails.
  * &#x60;unique&#x60; ‚Äî whether the field must be unique in its scope.
  * &#x60;uniqueError&#x60; ‚Äî error message when uniqueness is violated.
  * &#x60;regex&#x60; ‚Äî optional pattern for format validation.
  * &#x60;regexError&#x60; ‚Äî error message when the value doesn&#x27;t match the pattern.

These rules are **pure metadata**; the actual data (lookup entities, people, companies, etc.) lives in other services.

### 2.3 Validation-as-a-Service (via metadata)

The Attribute Rule Set Service itself does not validate entity payloads directly; instead, it provides:

* A **canonical description** of attribute rules.
* A contract that other services use to validate their own dynamic attributes.

Other microservices can:

* Query an attribute rule set by &#x60;code&#x60;.
* Retrieve all rules for a given set.
* Use those rules to perform client-side or server-side validation.

This turns validation into a **shared capability**, while keeping entity-specific logic in the owning bounded context.

### 2.4 Multi-Domain Reuse

Any domain that manages entities with flexible attributes can **bind to one or more attribute rule sets**, for example:

* **Lookup** entries using rule sets like &#x60;COUNTRY_ATTRIBUTES&#x60;, &#x60;ACCOUNT_STATUS_ATTRIBUTES&#x60;.
* **Person** domain using rule sets like &#x60;PERSON_PROFILE_ATTRIBUTES&#x60;.
* **Customer** domain using rule sets like &#x60;CUSTOMER_CLASSIFICATION_ATTRIBUTES&#x60;.

This eliminates duplicated schema logic and promotes governance: rule sets are changed once and reflected everywhere they are used.

---

## 3. Domain Model

### 3.1 AttributeRuleSet Aggregate

**Purpose:** Represents a named collection of attribute rules.

**Attributes:**

* &#x60;code&#x60; ‚Äî Unique technical identifier for the rule set (immutable), e.g. &#x60;PERSON_PROFILE_ATTRIBUTES&#x60;.
* &#x60;name&#x60; ‚Äî Human-readable label, e.g. &quot;Person Profile Attributes&quot;.
* &#x60;description&#x60; ‚Äî Optional detailed explanation and business context.
* &#x60;enabled&#x60; ‚Äî Whether this rule set is active and should be used by consuming services.
* &#x60;rules&#x60; ‚Äî A map of &#x60;AttributeRule&#x60; value objects keyed by attribute code.

**Responsibilities:**

* Create, update, and deactivate rule sets.
* Add, update, and remove individual attribute rules.
* Enforce invariants between rules (no duplicate codes, reserved rules protected, valid types and regex patterns, etc.).

**Example Structure:**

&#x60;&#x60;&#x60;json
{
  &quot;code&quot;: &quot;CUSTOMER_CLASSIFICATION_ATTRIBUTES&quot;,
  &quot;name&quot;: &quot;Customer Classification Attributes&quot;,
  &quot;rules&quot;: {
    &quot;riskLevel&quot;: {
      &quot;type&quot;: &quot;string&quot;,
      &quot;required&quot;: true
    },
    &quot;creditScore&quot;: {
      &quot;type&quot;: &quot;integer&quot;,
      &quot;required&quot;: false
    }
  }
}
&#x60;&#x60;&#x60;

**Domain Events (examples):**

* &#x60;AttributeRuleSetCreated&#x60;
* &#x60;AttributeRuleSetUpdated&#x60;
* &#x60;AttributeRuleSetEnabled&#x60;
* &#x60;AttributeRuleSetDisabled&#x60;
* &#x60;AttributeRuleAdded&#x60;
* &#x60;AttributeRuleUpdated&#x60;
* &#x60;AttributeRuleRemoved&#x60;

### 3.2 AttributeRule Value Object

**Purpose:** Describes the behavior and constraints of a single attribute field inside a rule set.

**Attributes:**

* &#x60;code&#x60; ‚Äî Unique code of the attribute within the rule set.
* &#x60;name&#x60; ‚Äî Human-readable label.
* &#x60;description&#x60; ‚Äî What the attribute represents and how it&#x27;s used.
* &#x60;type&#x60; ‚Äî Data type (&#x60;string&#x60;, &#x60;integer&#x60;, &#x60;boolean&#x60;, &#x60;currency&#x60;, &#x60;date&#x60;, &#x60;datetime&#x60;, &#x60;other&#x60;).
* &#x60;required&#x60; ‚Äî Whether this attribute must always be present when the rule set is applied.
* &#x60;unique&#x60; ‚Äî Whether the attribute value must be unique in the scope defined by the consuming service.
* &#x60;regex&#x60; ‚Äî Optional pattern to validate the data format.
* &#x60;reference&#x60; ‚Äî Whether this attribute can be used as a reference/search key.
* &#x60;reserved&#x60; ‚Äî Whether this attribute is protected from deletion or incompatible changes.
* &#x60;requiredError&#x60;, &#x60;uniqueError&#x60;, &#x60;regexError&#x60; ‚Äî User-facing error messages for validation failures.

**Validation Behavior (as metadata):**

* Defines which attributes are mandatory.
* Defines uniqueness and format rules.
* Supplies message templates that consuming services can reuse when returning errors.

---

## 4. Integration and Implementation Model

### 4.1 API Integration

Other domains use the Attribute Rule Set Service via REST or internal service calls, typically:

#### Query APIs

* &#x60;GET /api/v1/attribute-rule-sets&#x60; ‚Äî List available rule sets.
* &#x60;GET /api/v1/attribute-rule-sets/{code}&#x60; ‚Äî Retrieve a specific rule set with all attribute rules.

#### Command APIs

* &#x60;POST /api/v1/attribute-rule-sets&#x60; ‚Äî Create a new rule set.
* &#x60;PUT /api/v1/attribute-rule-sets/{code}&#x60; ‚Äî Replace an existing rule set definition (full update), or
* &#x60;PATCH /api/v1/attribute-rule-sets/{code}&#x60; ‚Äî Apply partial changes (if supported).

Each domain can cache or project rule sets locally for fast runtime validation.

### 4.2 Domain Integration Pattern

Each bounded context that supports dynamic attributes (Person, Company, Lookup, etc.) typically implements an **AttributeRuleSetAdapter** or **AttributeRuleValidator**:

1. On entity create/update, the service determines which rule set(s) apply to the entity.
2. It loads the attribute rule set definition (from a local projection or via the Attribute Rule Set Service API).
3. The validator applies type, required, unique, and regex rules to the entity&#x27;s attribute payload.
4. If validation passes, the entity is persisted and events are emitted.
5. If validation fails, domain-specific validation errors are produced using the error messages defined in the rule set.

### 4.3 Event-Driven Synchronization

* Attribute rule sets and their rules are stored as events (e.g. in EventStoreDB) and exposed via read models.
* Changes to rule sets are published as **domain events**.
* Consuming services subscribe to these events and update their local projections or caches, so validation rules stay in sync without tight coupling.

---

## 5. Architectural Role

### 5.1 Shared Governance Layer

* Acts as a **single point of truth** for attribute rule sets across the platform.
* Prevents each service from recreating similar validation logic.
* Provides auditability: every rule set change is recorded as a domain event.

### 5.2 Enabler for Dynamic Schemas

By decoupling attribute rules from persistence schemas:

* Entities can gain new attributes without database migrations.
* Front-end forms (e.g. FEML-driven UIs) can render fields and validation dynamically based on a rule set.
* Admin tools can allow configuration of which rule sets apply to which entity types.

### 5.3 Multi-Tenant Support

Each &#x60;AttributeRuleSet&#x60; can be **scoped per tenant**, enabling custom metadata per tenant or organization.

Key identifier pattern (example):

&#x60;&#x60;&#x60;text
core-attributes:v1:{tenant}:rule-set:{ruleSetCode}
core-attributes:v1:{tenant}:rule:{ruleSetCode}:{attributeCode}
&#x60;&#x60;&#x60;

---

## 6. Example Use Cases

### 6.1 Lookup Domain

Define a rule set for account status metadata:

&#x60;&#x60;&#x60;json
{
  &quot;code&quot;: &quot;ACCOUNT_STATUS_ATTRIBUTES&quot;,
  &quot;name&quot;: &quot;Account Status Attributes&quot;,
  &quot;rules&quot;: {
    &quot;category&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;required&quot;: true },
    &quot;terminal&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;required&quot;: true }
  }
}
&#x60;&#x60;&#x60;

The Lookup service applies this rule set to all lookup entries of type &#x60;ACCOUNT_STATUS&#x60; when validating their &#x60;attributes&#x60; payload.

### 6.2 Person Domain

Define a rule set for optional profile attributes:

&#x60;&#x60;&#x60;json
{
  &quot;code&quot;: &quot;PERSON_PROFILE_ATTRIBUTES&quot;,
  &quot;name&quot;: &quot;Person Profile Attributes&quot;,
  &quot;rules&quot;: {
    &quot;maritalStatus&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;employmentType&quot;: { &quot;type&quot;: &quot;string&quot; }
  }
}
&#x60;&#x60;&#x60;

The Person service uses this rule set to validate additional profile data stored in a flexible &#x60;attributes&#x60; structure.

### 6.3 Customer Domain

Define a rule set for customer classification:

&#x60;&#x60;&#x60;json
{
  &quot;code&quot;: &quot;CUSTOMER_CLASSIFICATION_ATTRIBUTES&quot;,
  &quot;name&quot;: &quot;Customer Classification Attributes&quot;,
  &quot;rules&quot;: {
    &quot;riskLevel&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;required&quot;: true },
    &quot;creditScore&quot;: { &quot;type&quot;: &quot;integer&quot; }
  }
}
&#x60;&#x60;&#x60;

The Customer service uses this to validate classification metadata and enforce that &#x60;riskLevel&#x60; is always present.

---

## 7. Benefits

* **Centralized validation and governance** for all dynamic attributes.
* **Reduced coupling** ‚Äî domains depend on rule sets, not hard-coded schemas.
* **Dynamic extensibility** ‚Äî adding new attributes is a configuration change, not a migration.
* **Auditability** ‚Äî every rule set and rule change is captured as an event.
* **Front-end flexibility** ‚Äî UIs can render fields and validation dynamically from rule sets.

---

## 8. Summary

The **Attribute Rule Set Service** provides an event-driven, tenant-aware framework for defining and managing attribute rule sets across the platform. It acts as the **metadata backbone** for any domain requiring dynamic, extensible, and validated attributes.

By consolidating attribute rules into shared, reusable rule sets, it transforms attribute handling from ad-hoc, per-service logic into a governed, composable capability ‚Äî improving consistency, adaptability, and developer productivity across the ecosystem.


### application: attributes

  | Modules |
  |---------------|
  | [***attribute-rule-set  ‚Üí***](/api/docs/core/attributes/attribute-rule-set) |
        `,
      )
      .setVersion('1.0.0')
      .addTag(
        'Attributes',
        `Configuration for core attributes application/service`,
      );

    // Add dynamic server configuration
    SwaggerConfigUtil.addServers(config, port);

    // Create a document with no modules to ensure no API paths are included
    const document = SwaggerModule.createDocument(app, config.build(), {
      include: [], // No modules included - this is a links-only documentation page
      extraModels: [],
      deepScanRoutes: false, // Prevent automatic route discovery
      ignoreGlobalPrefix: true, // Ignore global prefix to avoid path discovery
    });

    // Remove any automatically discovered paths and schemas
    document.paths = {};
    document.components = { schemas: {} };

    SwaggerModule.setup('api/docs/core/attributes', app, document);
  }

  /**
   * Setup all core-related documentation endpoints
   * This method centralizes the setup of all core module documentation
   */
  static setupAll(
    app: INestApplication,
    port: string | number,
  ): Record<string, string> {
    // Setup main core documentation
    AttributesApplicationDocumentation.setup(app, port);

    // Setup sub-module documentation

    // Return all endpoint URLs
    return {
      core: AttributesApplicationDocumentation.getEndpoint(port),
    };
  }

  static getEndpoint(port: string | number): string {
    return `${SwaggerConfigUtil.getServerUrl(port)}/api/docs/core/attributes`;
  }
}
