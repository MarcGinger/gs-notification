// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Logger, Inject } from '@nestjs/common';

// Shared utilities and infrastructure
import { Result, DomainError, ok, err, withContext } from 'src/shared/errors';
import {
  AuthorizationPort,
  buildAuthorizationContext,
} from 'src/shared/security/authorization.port';
import type { AuthorizationRequest } from 'src/shared/security/authorization.port';

// Domain types and errors
import { AttributeRuleSetPermission } from '../../domain/permissions/attribute-rule-set.permissions';
import { AttributeRuleSetErrors } from '../../domain/errors/attribute-rule-set.errors';
import { ATTRIBUTES_DI_TOKENS } from '../../../attributes.constants';

// Application layer
import { AttributeRuleSetFieldPermissionMatrix } from '../security/attribute-rule-set-field-permission-matrix';
import {
  AttributeRuleSetAuthContext,
  CrudOperation,
  BatchOperation,
} from '../types/attribute-rule-set-auth-context';

/**
 * Domain-specific authorization service for AttributeRuleSet operations.
 * Provides AttributeRuleSet-aware convenience methods and field-level permission checking.
 *
 * Improvements:
 * - Uses typed AttributeRuleSetAuthContext for better ABAC support
 * - Includes tenant/role information in actor context
 * - Optimized field-level checks with anyOf pattern
 * - Proper error handling with domain error factories
 * - Chunked batch processing for performance
 */
@Injectable()
export class AttributeRuleSetAuthorizationService {
  private readonly logger = new Logger(
    AttributeRuleSetAuthorizationService.name,
  );

  constructor(
    @Inject(ATTRIBUTES_DI_TOKENS.AUTHORIZATION_SERVICE)
    private readonly authorizationPort: AuthorizationPort<AttributeRuleSetPermission>,
  ) {}

  /**
   * Helper to create consistent logging context
   */
  private createLogContext(
    operation: string,
    correlationId: string,
    userId?: string,
    additionalContext?: Record<string, unknown>,
  ): Record<string, unknown> {
    return {
      serviceName: 'AttributeRuleSetAuthorizationService',
      component: 'AttributeRuleSetAuthorizationService',
      operation,
      correlationId,
      userId,
      ...additionalContext,
    };
  }

  /**
   * Check if user can read a specific attributeRuleSet
   */
  async canReadAttributeRuleSet(
    userId: string,
    attributeRuleSets: string,
    correlationId: string,
    context?: AttributeRuleSetAuthContext,
  ): Promise<Result<boolean, DomainError>> {
    if (!attributeRuleSets) {
      return err(
        withContext(AttributeRuleSetErrors.PERMISSION_DENIED, {
          attributeRuleSets: attributeRuleSets || '',
          userId,
          correlationId,
          operation: 'read',
        }),
      );
    }

    const actor = {
      userId,
      tenant: context?.tenant,
      roles: context?.roles,
    };

    const request: AuthorizationRequest<AttributeRuleSetPermission> = {
      domain: 'attribute_rule_set',
      permissions: [AttributeRuleSetPermission.DOMAIN_ATTRIBUTE_RULE_SET_READ],
      actor,
      resource: { type: 'attribute_rule_set', id: attributeRuleSets },
      context: buildAuthorizationContext(correlationId, {
        metadata: context?.metadata,
      }),
    };

    const result = await this.authorizationPort.check(request);
    return result.ok ? ok(result.value.allowed) : err(result.error);
  }

  /**
   * Check if user can create attributeRuleSets
   */
  async canCreateAttributeRuleSet(
    userId: string,
    correlationId: string,
    context?: AttributeRuleSetAuthContext,
  ): Promise<Result<boolean, DomainError>> {
    const actor = {
      userId,
      tenant: context?.tenant,
      roles: context?.roles,
    };

    const request: AuthorizationRequest<AttributeRuleSetPermission> = {
      domain: 'attribute_rule_set',
      permissions: [
        AttributeRuleSetPermission.DOMAIN_ATTRIBUTE_RULE_SET_CREATE,
      ],
      actor,
      resource: { type: 'attribute_rule_set' },
      context: buildAuthorizationContext(correlationId, {
        metadata: context?.metadata,
      }),
    };

    const result = await this.authorizationPort.check(request);
    return result.ok ? ok(result.value.allowed) : err(result.error);
  }

  /**
   * Check if user can update a specific attributeRuleSet
   */
  async canUpdateAttributeRuleSet(
    userId: string,
    attributeRuleSets: string,
    correlationId: string,
    context?: AttributeRuleSetAuthContext,
  ): Promise<Result<boolean, DomainError>> {
    if (!attributeRuleSets) {
      return err(
        withContext(AttributeRuleSetErrors.PERMISSION_DENIED, {
          attributeRuleSets: attributeRuleSets || '',
          userId,
          correlationId,
          operation: 'update',
        }),
      );
    }

    const actor = {
      userId,
      tenant: context?.tenant,
      roles: context?.roles,
    };

    const request: AuthorizationRequest<AttributeRuleSetPermission> = {
      domain: 'attribute_rule_set',
      permissions: [
        AttributeRuleSetPermission.DOMAIN_ATTRIBUTE_RULE_SET_UPDATE,
      ],
      actor,
      resource: { type: 'attribute_rule_set', id: attributeRuleSets },
      context: buildAuthorizationContext(correlationId, {
        metadata: context?.metadata,
      }),
    };

    const result = await this.authorizationPort.check(request);
    return result.ok ? ok(result.value.allowed) : err(result.error);
  }

  /**
   * Check if user can delete a specific attributeRuleSet
   */
  async canDeleteAttributeRuleSet(
    userId: string,
    attributeRuleSets: string,
    correlationId: string,
    context?: AttributeRuleSetAuthContext,
  ): Promise<Result<boolean, DomainError>> {
    if (!attributeRuleSets) {
      return err(
        withContext(AttributeRuleSetErrors.PERMISSION_DENIED, {
          attributeRuleSets: attributeRuleSets || '',
          userId,
          correlationId,
          operation: 'delete',
        }),
      );
    }

    const actor = {
      userId,
      tenant: context?.tenant,
      roles: context?.roles,
    };

    const request: AuthorizationRequest<AttributeRuleSetPermission> = {
      domain: 'attribute_rule_set',
      permissions: [
        AttributeRuleSetPermission.DOMAIN_ATTRIBUTE_RULE_SET_DELETE,
      ],
      actor,
      resource: { type: 'attribute_rule_set', id: attributeRuleSets },
      context: buildAuthorizationContext(correlationId, {
        metadata: context?.metadata,
      }),
    };

    const result = await this.authorizationPort.check(request);
    return result.ok ? ok(result.value.allowed) : err(result.error);
  }

  /**
   * Check if user can perform admin operations on attributeRuleSets
   */
  async canAdministerAttributeRuleSet(
    userId: string,
    correlationId: string,
    attributeRuleSets?: string,
    context?: AttributeRuleSetAuthContext,
  ): Promise<Result<boolean, DomainError>> {
    const actor = {
      userId,
      tenant: context?.tenant,
      roles: context?.roles,
    };

    const request: AuthorizationRequest<AttributeRuleSetPermission> = {
      domain: 'attribute_rule_set',
      permissions: [AttributeRuleSetPermission.DOMAIN_ATTRIBUTE_RULE_SET_ADMIN],
      actor,
      resource: { type: 'attribute_rule_set', id: attributeRuleSets },
      context: buildAuthorizationContext(correlationId, {
        metadata: context?.metadata,
      }),
    };

    const result = await this.authorizationPort.check(request);
    return result.ok ? ok(result.value.allowed) : err(result.error);
  }

  /**
   * Check field-level permissions for attributeRuleSet updates.
   * Returns which fields the user can modify based on the permission matrix.
   *
   * Optimizations:
   * - Uses anyOf pattern to reduce OPA calls
   * - Parallel processing of field checks
   * - Proper actor context with tenant/role information
   */
  async checkFieldPermissions(
    userId: string,
    attributeRuleSets: string,
    requestedFields: string[],
    correlationId: string,
    context?: AttributeRuleSetAuthContext,
  ): Promise<
    Result<{ allowedFields: string[]; deniedFields: string[] }, DomainError>
  > {
    if (!attributeRuleSets) {
      return err(
        withContext(AttributeRuleSetErrors.PERMISSION_DENIED, {
          attributeRuleSets: attributeRuleSets || '',
          userId,
          correlationId,
          operation: 'checkFieldPermissions',
        }),
      );
    }

    try {
      const actor = {
        userId,
        tenant: context?.tenant,
        roles: context?.roles,
      };

      // Process fields in parallel for better performance
      const results = await Promise.all(
        requestedFields.map(async (field) => {
          const requiredPermissions =
            AttributeRuleSetFieldPermissionMatrix.getRequiredPermissions(field);

          // Use basic UPDATE permission if no special permissions required
          const permissions = requiredPermissions.length
            ? requiredPermissions
            : [AttributeRuleSetPermission.DOMAIN_ATTRIBUTE_RULE_SET_UPDATE];

          const request: AuthorizationRequest<AttributeRuleSetPermission> = {
            domain: 'attribute_rule_set',
            permissions,
            anyOf: true, // User needs ANY of the required permissions
            actor,
            resource: { type: 'attribute_rule_set', id: attributeRuleSets },
            context: buildAuthorizationContext(correlationId, {
              metadata: { ...context?.metadata, field },
            }),
          };

          const result = await this.authorizationPort.check(request);
          return { field, allowed: result.ok && result.value.allowed };
        }),
      );

      const allowedFields = results
        .filter((r) => r.allowed)
        .map((r) => r.field);
      const deniedFields = results
        .filter((r) => !r.allowed)
        .map((r) => r.field);

      return ok({ allowedFields, deniedFields });
    } catch (error: unknown) {
      this.logger.error(
        'Error checking field permissions',
        this.createLogContext('checkFieldPermissions', correlationId, userId, {
          attributeRuleSets,
          requestedFields,
          error: error instanceof Error ? error.message : String(error),
        }),
      );

      return err(
        withContext(AttributeRuleSetErrors.AUTHORIZATION_FAILED, {
          attributeRuleSets: attributeRuleSets || '',
          userId,
          correlationId,
          operation: 'checkFieldPermissions',
          reason: error instanceof Error ? error.message : String(error),
        }),
      );
    }
  }

  /**
   * Comprehensive authorization check for attributeRuleSet operations.
   * Validates both operation-level and field-level permissions.
   *
   * Improvements:
   * - Proper type safety with CrudOperation
   * - Explicit guards for required attributeRuleSet IDs
   * - Uses typed AttributeRuleSetAuthContext
   */
  async authorizeAttributeRuleSetOperation(
    userId: string,
    operation: CrudOperation,
    correlationId: string,
    attributeRuleSets?: string,
    fields?: string[],
    context?: AttributeRuleSetAuthContext,
  ): Promise<
    Result<
      {
        authorized: boolean;
        allowedFields?: string[];
        deniedFields?: string[];
      },
      DomainError
    >
  > {
    try {
      // Validate required attributeRuleSets for operations that need it
      if (
        ['read', 'update', 'delete'].includes(operation) &&
        !attributeRuleSets
      ) {
        return err(
          withContext(AttributeRuleSetErrors.PERMISSION_DENIED, {
            attributeRuleSets: attributeRuleSets || '',
            userId,
            correlationId,
            operation: String(operation),
          }),
        );
      }

      // First check operation-level permission
      let operationResult: Result<boolean, DomainError>;

      switch (operation) {
        case 'read':
          operationResult = await this.canReadAttributeRuleSet(
            userId,
            attributeRuleSets!,
            correlationId,
            context,
          );
          break;
        case 'create':
          operationResult = await this.canCreateAttributeRuleSet(
            userId,
            correlationId,
            context,
          );
          break;
        case 'update':
          operationResult = await this.canUpdateAttributeRuleSet(
            userId,
            attributeRuleSets!,
            correlationId,
            context,
          );
          break;
        case 'delete':
          operationResult = await this.canDeleteAttributeRuleSet(
            userId,
            attributeRuleSets!,
            correlationId,
            context,
          );
          break;
        default:
          return err(
            withContext(AttributeRuleSetErrors.NOT_IMPLEMENTED, {
              attributeRuleSets: attributeRuleSets || '',
              userId,
              correlationId,
              operation: String(operation),
            }),
          );
      }

      if (!operationResult.ok) {
        return err(operationResult.error);
      }

      if (!operationResult.value) {
        return ok({ authorized: false });
      }

      // For update operations with field specifications, check field-level permissions
      if (
        operation === 'update' &&
        fields &&
        fields.length > 0 &&
        attributeRuleSets
      ) {
        const fieldResult = await this.checkFieldPermissions(
          userId,
          attributeRuleSets,
          fields,
          correlationId,
          context,
        );

        if (!fieldResult.ok) {
          return err(fieldResult.error);
        }

        const { allowedFields, deniedFields } = fieldResult.value;

        // Operation is authorized, but some fields might be denied
        return ok({
          authorized: allowedFields.length > 0,
          allowedFields,
          deniedFields,
        });
      }

      // Simple operation authorization without field-level checks
      return ok({ authorized: true });
    } catch (error: unknown) {
      this.logger.error(
        'Error in comprehensive attributeRuleSet authorization',
        this.createLogContext('comprehensiveCheck', correlationId, userId, {
          operation,
          attributeRuleSets,
          fields,
          error: error instanceof Error ? error.message : String(error),
        }),
      );

      return err(
        withContext(AttributeRuleSetErrors.AUTHORIZATION_FAILED, {
          attributeRuleSets: attributeRuleSets || '',
          userId,
          correlationId,
          operation: String(operation),
          reason: error instanceof Error ? error.message : String(error),
        }),
      );
    }
  }

  /**
   * Batch authorization check for multiple attributeRuleSets.
   * Useful for list operations where you need to filter results.
   *
   * Optimizations:
   * - Chunked processing to avoid overwhelming OPA
   * - Typed AttributeRuleSetAuthContext and BatchOperation
   * - Proper actor context with tenant/role information
   */
  async authorizeAttributeRuleSetList(
    userId: string,
    attributeRuleSetss: string[],
    correlationId: string,
    operation: BatchOperation = 'read',
    context?: AttributeRuleSetAuthContext,
  ): Promise<Result<{ authorized: string[]; denied: string[] }, DomainError>> {
    try {
      const authorized: string[] = [];
      const denied: string[] = [];

      // Chunk processing to avoid stampeding OPA with large lists
      const chunk = <T>(arr: T[], size: number): T[][] =>
        Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>
          arr.slice(i * size, (i + 1) * size),
        );

      // Process in chunks of 50 to balance performance and resource usage
      for (const batch of chunk(attributeRuleSetss, 50)) {
        const results = await Promise.allSettled(
          batch.map(async (attributeRuleSets) => {
            let result: Result<boolean, DomainError>;

            switch (operation) {
              case 'read':
                result = await this.canReadAttributeRuleSet(
                  userId,
                  attributeRuleSets,
                  correlationId,
                  context,
                );
                break;
              case 'update':
                result = await this.canUpdateAttributeRuleSet(
                  userId,
                  attributeRuleSets,
                  correlationId,
                  context,
                );
                break;
              case 'delete':
                result = await this.canDeleteAttributeRuleSet(
                  userId,
                  attributeRuleSets,
                  correlationId,
                  context,
                );
                break;
              default:
                result = err(
                  withContext(AttributeRuleSetErrors.NOT_IMPLEMENTED, {
                    attributeRuleSets,
                    userId,
                    correlationId,
                    operation: String(operation),
                  }),
                );
                break;
            }

            return { attributeRuleSets, result };
          }),
        );

        // Process results from this chunk
        results.forEach((promiseResult, index) => {
          const attributeRuleSets = batch[index];

          if (promiseResult.status === 'fulfilled') {
            const { result } = promiseResult.value;
            if (result.ok && result.value) {
              authorized.push(attributeRuleSets);
            } else {
              denied.push(attributeRuleSets);
            }
          } else {
            // Promise rejected, treat as denied
            denied.push(attributeRuleSets);
            this.logger.warn(
              'Authorization check failed for attributeRuleSet',
              this.createLogContext(
                'batchAuthorization',
                correlationId,
                userId,
                {
                  attributeRuleSets,
                  error: String(promiseResult.reason),
                },
              ),
            );
          }
        });
      }

      return ok({ authorized, denied });
    } catch (error: unknown) {
      this.logger.error(
        'Error in batch attributeRuleSet authorization',
        this.createLogContext('batchAuthorization', correlationId, userId, {
          attributeRuleSetss: attributeRuleSetss.slice(0, 10), // Log only first 10 for brevity
          operation,
          error: error instanceof Error ? error.message : String(error),
        }),
      );

      return err(
        withContext(AttributeRuleSetErrors.AUTHORIZATION_FAILED, {
          attributeRuleSets: '',
          userId,
          correlationId,
          operation: String(operation),
          reason: error instanceof Error ? error.message : String(error),
        }),
      );
    }
  }
}
