// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { Result, DomainError, ok, err } from 'src/shared/errors';
import { AttributeRuleErrors } from '../../errors/attribute-rule.errors';
import { AttributeRuleProps } from '../../props';

/**
 * AttributeRuleSetAttributeRuleConfiguration Value Object
 *
 * Simple wrapper for Record<string, AttributeRuleProps> that preserves the
 * structure without expanding into individual properties.
 */
export class AttributeRuleSetAttributeRuleConfiguration {
  private readonly _value: Record<string, AttributeRuleProps>;

  private constructor(value: Record<string, AttributeRuleProps>) {
    this._value = value;
  }

  /**
   * Create from Record<string, AttributeRuleProps>
   */
  static from(
    value: unknown,
  ): Result<AttributeRuleSetAttributeRuleConfiguration, DomainError> {
    // Allow null/undefined for optional attributes
    if (value === null || value === undefined) {
      return ok(new AttributeRuleSetAttributeRuleConfiguration({}));
    }

    if (typeof value !== 'object' || Array.isArray(value)) {
      return err(AttributeRuleErrors.INVALID_ATTRIBUTE_RULE_CONFIGURATION_DATA);
    }

    const record = value as Record<string, unknown>;

    // Basic validation - ensure all values are objects with required properties
    for (const [key, val] of Object.entries(record)) {
      if (typeof val !== 'object' || val === null) {
        return err({
          ...AttributeRuleErrors.INVALID_ATTRIBUTE_RULE_CONFIGURATION_DATA,
          context: { invalidKey: key, invalidValue: val },
        });
      }
    }

    return ok(
      new AttributeRuleSetAttributeRuleConfiguration(
        record as Record<string, AttributeRuleProps>,
      ),
    );
  }

  /**
   * Get the underlying Record<string, AttributeRuleProps>
   */
  get value(): Record<string, AttributeRuleProps> {
    return { ...this._value };
  }

  /**
   * Check if two configurations are equal
   */
  equals(other: AttributeRuleSetAttributeRuleConfiguration): boolean {
    const thisKeys = Object.keys(this._value).sort();
    const otherKeys = Object.keys(other._value).sort();

    if (thisKeys.length !== otherKeys.length) {
      return false;
    }

    for (let i = 0; i < thisKeys.length; i++) {
      if (thisKeys[i] !== otherKeys[i]) {
        return false;
      }
    }

    // Deep comparison would be needed for complete equality,
    // but this basic implementation should work for our use case
    return JSON.stringify(this._value) === JSON.stringify(other._value);
  }
}

/**
 * Converts AttributeRuleSetAttributeRuleConfiguration to Record<string, AttributeRuleProps>
 * for persistence. The input is already in the correct Record format.
 */
export const attributeRuleConfigurationToSnapshotProps = (
  config: AttributeRuleSetAttributeRuleConfiguration,
): Record<string, AttributeRuleProps> => {
  // The config.value is already a Record<string, AttributeRuleProps>
  // No additional wrapping needed
  return config.value;
};
