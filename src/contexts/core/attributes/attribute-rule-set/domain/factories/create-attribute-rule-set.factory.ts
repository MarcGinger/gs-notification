// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, withContext, ok } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { AttributeRuleSetAggregate } from '../aggregates';
import { CreateAttributeRuleSetProps } from '../props';
import { AttributeRuleSetDomainState } from '../state';
import {
  AttributeRuleSetAttributeRuleConfiguration,
  AttributeRuleSetCreatedAt,
  AttributeRuleSetUpdatedAt,
  AttributeRuleSetVersion,
  AttributeRuleSetCode,
  AttributeRuleSetName,
  AttributeRuleSetDescription,
  AttributeRuleSetEnabled,
} from '../value-objects';
import { createAttributeRuleConfigurationFromProps } from './attribute-rule.factory';

/**
 * Enhanced attributeRuleSet entity factory with comprehensive validation and security context
 * Moved from application layer to properly separate business concerns
 */
export function createAttributeRuleSetAggregateFromProps(
  props: CreateAttributeRuleSetProps,
  metadata: EventMetadata,
  clock: Clock,
  // validatedEntities?: {
  //  channels?: ChannelReference[];
  // },
): Result<AttributeRuleSetAggregate, DomainError> {
  // Validate each property by creating value objects
  const codeResult = AttributeRuleSetCode.from(props.code);
  if (!codeResult.ok) {
    return err(
      withContext(codeResult.error, {
        ...codeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_attribute_rule_set',
        code: props.code,
      }),
    );
  }

  const nameResult = AttributeRuleSetName.from(props.name);
  if (!nameResult.ok) {
    return err(
      withContext(nameResult.error, {
        ...nameResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_attribute_rule_set',
        name: props.name,
      }),
    );
  }

  const descriptionResult = AttributeRuleSetDescription.from(props.description);
  if (!descriptionResult.ok) {
    return err(
      withContext(descriptionResult.error, {
        ...descriptionResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_attribute_rule_set',
        description: props.description,
      }),
    );
  }

  const enabledResult = AttributeRuleSetEnabled.from(props.enabled);
  if (!enabledResult.ok) {
    return err(
      withContext(enabledResult.error, {
        ...enabledResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_attribute_rule_set',
        enabled: props.enabled,
      }),
    );
  }

  // Create attributes configuration using comprehensive validation for each Attribute rule
  let attributesResult: Result<
    AttributeRuleSetAttributeRuleConfiguration | undefined,
    DomainError
  >;

  if (props.attributes) {
    // Validate that attributes is actually an array
    if (!Array.isArray(props.attributes)) {
      // Try to validate with AttributeRuleSetAttributeRuleConfiguration to get proper error
      const arrayValidationResult =
        AttributeRuleSetAttributeRuleConfiguration.from(props.attributes);
      if (!arrayValidationResult.ok) {
        return err(
          withContext(arrayValidationResult.error, {
            ...arrayValidationResult.error.context,
            correlationId: metadata.correlationId,
            userId: metadata.userId,
            operation: 'create_attribute_rule_set_validate_array',
            message: 'Attributes must be an array of AttributeRule objects',
            receivedType: typeof props.attributes,
            isArray: Array.isArray(props.attributes),
            attributes: props.attributes,
          }),
        );
      }
    }

    const validatedAttributeConfigurations: unknown[] = [];

    // Validate each Attribute rule in the array using the specialized factory
    for (
      let attributeIndex = 0;
      attributeIndex < props.attributes.length;
      attributeIndex++
    ) {
      const attributeRuleProps = props.attributes[attributeIndex];
      const singleAttributeResult = createAttributeRuleConfigurationFromProps(
        attributeRuleProps,
        metadata,
      );

      if (!singleAttributeResult.ok) {
        return err(
          withContext(singleAttributeResult.error, {
            ...singleAttributeResult.error.context,
            correlationId: metadata.correlationId,
            userId: metadata.userId,
            operation: 'create_attribute_rule_set',
            attributeIndex,
            attributes: props.attributes,
          }),
        );
      }

      // Store the validated configuration as raw value for the array
      validatedAttributeConfigurations.push(singleAttributeResult.value.value);
    }

    // Create the final AttributeRuleSetAttributeRuleConfiguration from validated data
    const finalAttributesResult =
      AttributeRuleSetAttributeRuleConfiguration.from(
        validatedAttributeConfigurations,
      );
    if (!finalAttributesResult.ok) {
      return err(
        withContext(finalAttributesResult.error, {
          ...finalAttributesResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_set_final_attributes',
          attributes: props.attributes,
        }),
      );
    }

    attributesResult = {
      ok: true,
      value: finalAttributesResult.value,
    } as const;
  } else {
    attributesResult = { ok: true, value: undefined } as const;
  }
  const createdAtResult = AttributeRuleSetCreatedAt.create(clock.now());
  if (!createdAtResult.ok) {
    return err(createdAtResult.error);
  }

  const updatedAtResult = AttributeRuleSetUpdatedAt.create(clock.now());
  if (!updatedAtResult.ok) {
    return err(updatedAtResult.error);
  }

  const versionResult = AttributeRuleSetVersion.create(1); // Initial version is 1
  if (!versionResult.ok) {
    return err(versionResult.error);
  }

  // Create the entity properties with validated value objects
  const entityProps: AttributeRuleSetDomainState = {
    code: codeResult.value,
    name: nameResult.value,
    description: descriptionResult.value,
    enabled: enabledResult.value,
    attributes: attributesResult.value,
    createdAt: createdAtResult.value,
    updatedAt: updatedAtResult.value,
    version: versionResult.value,
  };

  // Create the entity using the constructor
  return AttributeRuleSetAggregate.create(entityProps, clock, metadata);
}
