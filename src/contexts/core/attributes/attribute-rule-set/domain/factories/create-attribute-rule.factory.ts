// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, withContext } from 'src/shared/errors';
import { EventMetadata } from 'src/shared/domain/events';
import { CreateAttributeRuleProps } from '../props';
import {
  AttributeRuleCode,
  AttributeRuleName,
  AttributeRuleDescription,
  createAttributeRuleType,
  AttributeRuleReference,
  AttributeRuleReserved,
  AttributeRuleUnique,
  AttributeRuleUniqueError,
  AttributeRuleRequired,
  AttributeRuleRequiredError,
  AttributeRuleRegex,
  AttributeRuleRegexError,
  AttributeRuleSetAttributeRuleItemConfiguration,
  createAttributeRuleSetAttributeRuleConfiguration,
} from '../value-objects';

/**
 * Factory for creating attributeRule configuration with comprehensive validation
 */
export function createAttributeRuleConfigurationFromProps(
  attributeRuleProps: CreateAttributeRuleProps[],
  metadata: EventMetadata,
): Result<AttributeRuleSetAttributeRuleItemConfiguration[], DomainError> {
  const configurations: AttributeRuleSetAttributeRuleItemConfiguration[] = [];

  // Process each attribute rule props in the array
  for (const props of attributeRuleProps) {
    // Create attributeRule value objects
    const attributeRuleCodeResult = AttributeRuleCode.from(props.code);
    if (!attributeRuleCodeResult.ok) {
      return err(
        withContext(attributeRuleCodeResult.error, {
          ...attributeRuleCodeResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          code: props.code,
        }),
      );
    }

    const attributeRuleNameResult = AttributeRuleName.from(props.name);
    if (!attributeRuleNameResult.ok) {
      return err(
        withContext(attributeRuleNameResult.error, {
          ...attributeRuleNameResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          name: props.name,
        }),
      );
    }

    const attributeRuleDescriptionResult = AttributeRuleDescription.from(
      props.description,
    );
    if (!attributeRuleDescriptionResult.ok) {
      return err(
        withContext(attributeRuleDescriptionResult.error, {
          ...attributeRuleDescriptionResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          description: props.description,
        }),
      );
    }

    const attributeRuleTypeResult = createAttributeRuleType(props.type);
    if (!attributeRuleTypeResult.ok) {
      return err(
        withContext(attributeRuleTypeResult.error, {
          ...attributeRuleTypeResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          type: props.type,
        }),
      );
    }

    const attributeRuleReferenceResult = AttributeRuleReference.from(
      props.reference,
    );
    if (!attributeRuleReferenceResult.ok) {
      return err(
        withContext(attributeRuleReferenceResult.error, {
          ...attributeRuleReferenceResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          reference: props.reference,
        }),
      );
    }

    const attributeRuleReservedResult = AttributeRuleReserved.from(
      props.reserved,
    );
    if (!attributeRuleReservedResult.ok) {
      return err(
        withContext(attributeRuleReservedResult.error, {
          ...attributeRuleReservedResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          reserved: props.reserved,
        }),
      );
    }

    const attributeRuleUniqueResult = AttributeRuleUnique.from(props.unique);
    if (!attributeRuleUniqueResult.ok) {
      return err(
        withContext(attributeRuleUniqueResult.error, {
          ...attributeRuleUniqueResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          unique: props.unique,
        }),
      );
    }

    const attributeRuleUniqueErrorResult = AttributeRuleUniqueError.from(
      props.uniqueError,
    );
    if (!attributeRuleUniqueErrorResult.ok) {
      return err(
        withContext(attributeRuleUniqueErrorResult.error, {
          ...attributeRuleUniqueErrorResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          uniqueError: props.uniqueError,
        }),
      );
    }

    const attributeRuleRequiredResult = AttributeRuleRequired.from(
      props.required,
    );
    if (!attributeRuleRequiredResult.ok) {
      return err(
        withContext(attributeRuleRequiredResult.error, {
          ...attributeRuleRequiredResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          required: props.required,
        }),
      );
    }

    const attributeRuleRequiredErrorResult = AttributeRuleRequiredError.from(
      props.requiredError,
    );
    if (!attributeRuleRequiredErrorResult.ok) {
      return err(
        withContext(attributeRuleRequiredErrorResult.error, {
          ...attributeRuleRequiredErrorResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          requiredError: props.requiredError,
        }),
      );
    }

    const attributeRuleRegexResult = AttributeRuleRegex.from(props.regex);
    if (!attributeRuleRegexResult.ok) {
      return err(
        withContext(attributeRuleRegexResult.error, {
          ...attributeRuleRegexResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          regex: props.regex,
        }),
      );
    }

    const attributeRuleRegexErrorResult = AttributeRuleRegexError.from(
      props.regexError,
    );
    if (!attributeRuleRegexErrorResult.ok) {
      return err(
        withContext(attributeRuleRegexErrorResult.error, {
          ...attributeRuleRegexErrorResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          regexError: props.regexError,
        }),
      );
    }

    const attributeRuleResult =
      createAttributeRuleSetAttributeRuleConfiguration({
        code: attributeRuleCodeResult.value,
        name: attributeRuleNameResult.value,
        description: attributeRuleDescriptionResult.value,
        type: attributeRuleTypeResult.value,
        reference: attributeRuleReferenceResult.value,
        reserved: attributeRuleReservedResult.value,
        unique: attributeRuleUniqueResult.value,
        uniqueError: attributeRuleUniqueErrorResult.value,
        required: attributeRuleRequiredResult.value,
        requiredError: attributeRuleRequiredErrorResult.value,
        regex: attributeRuleRegexResult.value,
        regexError: attributeRuleRegexErrorResult.value,
      });
    if (!attributeRuleResult.ok) {
      return err(
        withContext(attributeRuleResult.error, {
          ...attributeRuleResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.userId,
          operation: 'create_attribute_rule_configuration',
          attributeRule: props,
        }),
      );
    }

    configurations.push(attributeRuleResult.value);
  }

  return { ok: true, value: configurations };
}
