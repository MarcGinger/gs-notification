// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, ok, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { AttributeRuleSetAggregate } from '../aggregates';
import { AttributeRuleSetEntity } from '../entities';
import {
  AttributeRuleSetSnapshotProps,
  UpdateAttributeRuleSetProps,
} from '../props';
import { ValidatedAttributeRuleSetUpdateFields } from '../types';
import {
  AttributeRuleSetAttributeRuleConfiguration,
  AttributeRuleSetName,
  AttributeRuleSetDescription,
  AttributeRuleSetEnabled,
} from '../value-objects';
import { updateAttributeRuleConfigurationFromProps } from './attribute-rule.factory';

/**
 * Update AttributeRuleSet Aggregate Factory
 *
 * Handles the complete update flow for AttributeRuleSet aggregates:
 * 1. Loads existing aggregate from snapshot
 * 2. Validates update properties and creates value objects
 * 3. Applies updates with proper business rule enforcement
 * 4. Returns updated aggregate ready for persistence
 *
 * This factory provides:
 * - Consistent update pattern matching create operations
 * - Centralized validation and business logic
 * - Efficient batch updates vs field-by-field
 * - Proper error context and logging integration
 */
export function updateAttributeRuleSetAggregateFromSnapshot(
  existingSnapshot: AttributeRuleSetSnapshotProps,
  updateProps: UpdateAttributeRuleSetProps,
  metadata: EventMetadata,
  clock: Clock,
): Result<AttributeRuleSetAggregate, DomainError> {
  // 1. Reconstitute existing aggregate
  const entityResult = AttributeRuleSetEntity.fromSnapshot(existingSnapshot);
  if (!entityResult.ok) {
    return err(
      withContext(entityResult.error, {
        operation: 'update_attribute_rule_set_reconstitute',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
      }),
    );
  }

  const existingAggregate = AttributeRuleSetAggregate.reconstitute(
    entityResult.value,
    clock,
    metadata,
  );

  // 2. Validate and apply updates for each provided field
  const validatedFields: ValidatedAttributeRuleSetUpdateFields = {};

  // Validate name if provided
  if (updateProps.name !== undefined) {
    const nameResult = AttributeRuleSetName.from(updateProps.name);
    if (!nameResult.ok) {
      return err(
        withContext(nameResult.error, {
          operation: 'update_attribute_rule_set_name_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedName: updateProps.name,
        }),
      );
    }
    validatedFields.name = nameResult.value;
  }

  // Validate description if provided
  if (updateProps.description !== undefined) {
    const descriptionResult = AttributeRuleSetDescription.from(
      updateProps.description,
    );
    if (!descriptionResult.ok) {
      return err(
        withContext(descriptionResult.error, {
          operation: 'update_attribute_rule_set_description_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedDescription: updateProps.description,
        }),
      );
    }
    validatedFields.description = descriptionResult.value;
  }

  // Validate enabled if provided
  if (updateProps.enabled !== undefined) {
    const enabledResult = AttributeRuleSetEnabled.from(updateProps.enabled);
    if (!enabledResult.ok) {
      return err(
        withContext(enabledResult.error, {
          operation: 'update_attribute_rule_set_enabled_validation',
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          providedEnabled: updateProps.enabled,
        }),
      );
    }
    validatedFields.enabled = enabledResult.value;
  }

  // Validate attributes if provided - handle UpdateAttributeRuleProps[] (array replacement)
  if (updateProps.attributes !== undefined) {
    // Validate that attributes is actually an array
    if (!Array.isArray(updateProps.attributes)) {
      // Try to validate with AttributeRuleSetAttributeRuleConfiguration to get proper error
      const arrayValidationResult =
        AttributeRuleSetAttributeRuleConfiguration.from(updateProps.attributes);
      if (!arrayValidationResult.ok) {
        return err(
          withContext(arrayValidationResult.error, {
            ...arrayValidationResult.error.context,
            correlationId: metadata.correlationId,
            userId: metadata.actor?.userId,
            operation: 'update_attribute_rule_set_validate_array',
            message: 'Attributes must be an array of AttributeRule objects',
            receivedType: typeof updateProps.attributes,
            isArray: Array.isArray(updateProps.attributes),
            providedAttributes: updateProps.attributes,
          }),
        );
      }
    }

    const validatedAttributeConfigurations: unknown[] = [];

    // Validate each Attribute rule in the array using the specialized factory
    for (let index = 0; index < updateProps.attributes.length; index++) {
      const attributeRuleProps = updateProps.attributes[index];

      // For updates, we can use createAttributeRuleConfigurationFromProps since we're replacing the entire array
      const singleAttributeResult = updateAttributeRuleConfigurationFromProps(
        attributeRuleProps,
        metadata,
      );

      if (!singleAttributeResult.ok) {
        return err(
          withContext(singleAttributeResult.error, {
            ...singleAttributeResult.error.context,
            correlationId: metadata.correlationId,
            userId: metadata.actor?.userId,
            operation: 'update_attribute_rule_set_attributes_validation',
            attributeIndex: index,
            providedAttributes: updateProps.attributes,
          }),
        );
      }

      // Store the validated configuration for the array
      validatedAttributeConfigurations.push(singleAttributeResult.value.value);
    }

    // Create the final AttributeRuleSetAttributeRuleConfiguration from validated data
    const finalAttributesResult =
      AttributeRuleSetAttributeRuleConfiguration.from(
        validatedAttributeConfigurations,
      );
    if (!finalAttributesResult.ok) {
      return err(
        withContext(finalAttributesResult.error, {
          ...finalAttributesResult.error.context,
          correlationId: metadata.correlationId,
          userId: metadata.actor?.userId,
          operation: 'update_attribute_rule_set_final_attributes',
          providedAttributes: updateProps.attributes,
        }),
      );
    }

    validatedFields.attributes = finalAttributesResult.value;
  }

  // 3. Apply all validated changes in single atomic operation
  const batchUpdateResult = existingAggregate.updateBatch(validatedFields);
  if (!batchUpdateResult.ok) {
    return err(
      withContext(batchUpdateResult.error, {
        operation: 'update_product_batch_application',
        correlationId: metadata.correlationId,
        userId: metadata.actor?.userId,
        fieldsUpdated: Object.keys(validatedFields),
      }),
    );
  }

  return ok(existingAggregate);
}
