// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// LookupType Projector - ESDB to In-Memory Projection
// Optimized for testing, prototyping, shadow validation, and ephemeral scenarios

import {
  Injectable,
  Inject,
  OnModuleInit,
  OnModuleDestroy,
} from '@nestjs/common';
import { performance } from 'node:perf_hooks';
import {
  CatchUpRunner,
  ProjectionEvent,
  RunOptions,
} from 'src/shared/infrastructure/projections/catchup.runner';
import { BaseProjector } from 'src/shared/infrastructure/projections/base.projector';
import {
  CommonProjectorErrorDefinitions,
  createProjectorErrorCatalog,
  TenantExtractor,
} from 'src/shared/infrastructure/projections/projection.utils';
import { APP_LOGGER, Log, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import { withContext } from 'src/shared/errors';
import {
  InMemoryCheckpointStore,
  ProjectionMetrics,
  ProjectionMetricsCollector,
} from 'src/shared/infrastructure/stores';
import { safeParseJSON } from 'src/shared/infrastructure/repositories';
import { LookupTypeProjectionKeys } from '../../lookup-type-projection-keys';
import {
  DetailLookupTypeResponse,
  DetailAttributeruleResponse,
} from '../../application/dtos';
import {
  lookupTypeStore,
  LookupTypeProjection,
} from '../stores/lookup-type.store';
import { LookupTypeFieldValidatorUtil } from '../utilities/lookup-type-field-validator.util';
/**
 * LookupType projector error catalog using shared error definitions
 */
const LookupTypeProjectorErrors = createProjectorErrorCatalog(
  'LOOKUP_TYPE_PROJECTOR_INMEMORY',
  CommonProjectorErrorDefinitions,
);

/**
 * Extracted lookupType parameters from event data
 */
interface ExtractedLookupTypeParams extends DetailLookupTypeResponse {
  tenant: string;
  version?: number;
}

/**
 * Extended lookupType projection with projector-specific metadata
 */
interface InMemoryLookupTypeProjection extends LookupTypeProjection {
  // In-memory specific metadata
  projectionTimestamp: Date;
  eventCount: number;
  lastEventType: string;
}

/**
 * LookupType Projector using In-Memory Architecture
 *
 * Perfect for:
 * - Unit & property tests: Run projection logic fast and hermetically
 * - Local dev / rapid prototyping: No infrastructure dependencies
 * - Shadow/canary validation: Run parallel with production for comparison
 * - Dry-run replays: Simulate outcomes without persistence
 * - Contract evolution checks: Verify producer changes won't break consumers
 * - Benchmarking: Profile logic without I/O noise
 * - Ephemeral caches: Ultra-low latency for small reference data
 * - Gatekeeping validation: Assert invariants before heavy operations
 * - Edge scenarios: When external stores aren't available
 * - Ad hoc analytics: Safe experimentation playground
 *
 * Features:
 * - LRU eviction for bounded memory usage
 * - Comprehensive metrics and observability
 * - Shadow mode with diff capability
 * - Snapshot + incremental patterns
 * - Per-stream isolation
 * - Fast reset and replay capabilities
 * - Zero external dependencies
 */
@Injectable()
export class LookupTypeProjector
  extends BaseProjector
  implements OnModuleInit, OnModuleDestroy
{
  // Metrics and observability
  private metrics: ProjectionMetricsCollector;

  // Shadow mode support
  private shadowMode = false;
  private shadowCallback?: (
    key: string,
    primaryResult: InMemoryLookupTypeProjection,
    shadowResult?: InMemoryLookupTypeProjection,
    comparisonResult?: any,
  ) => void;

  // Deduplication window to prevent processing same event multiple times
  private readonly recentEvents: Map<string, number> = new Map();
  private readonly dedupWindowMs = 5000; // 5 second window

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    @Inject(CLOCK) private readonly clock: Clock,
    @Inject(CatchUpRunner) private readonly catchUpRunner: CatchUpRunner,
  ) {
    const inMemoryCheckpointStore = new InMemoryCheckpointStore();

    super(
      'lookup-type-projector-inmemory',
      'lookup-type-projection-inmemory',
      baseLogger,
      inMemoryCheckpointStore,
    );

    // Initialize metrics
    this.metrics = new ProjectionMetricsCollector();

    Log.info(
      this.logger,
      'LookupTypeProjectorInMemory initialized using shared lookupType store',
      {
        method: 'constructor',
        subscriptionGroup: this.subscriptionGroup,
        architecture: 'in-memory-shared-store',
        features: [
          'shared-store',
          'shadow-mode',
          'metrics-collection',
          'zero-dependencies',
        ],
        useCases: [
          'unit-testing',
          'rapid-prototyping',
          'shadow-validation',
          'dry-run-replays',
          'benchmarking',
        ],
      },
    );
  }

  /**
   * Enable shadow mode for parallel validation with production projector
   */
  enableShadowMode(
    callback: (
      key: string,
      inMemoryProjection: InMemoryLookupTypeProjection,
      expectedProjection?: any,
    ) => void,
  ): void {
    this.shadowMode = true;
    this.shadowCallback = callback;

    Log.info(this.logger, 'Shadow mode enabled for parallel validation', {
      method: 'enableShadowMode',
      shadowMode: true,
    });
  }

  /**
   * Disable shadow mode
   */
  disableShadowMode(): void {
    this.shadowMode = false;
    this.shadowCallback = undefined;

    Log.info(this.logger, 'Shadow mode disabled', {
      method: 'disableShadowMode',
      shadowMode: false,
    });
  }

  /**
   * Load snapshot data for snapshot + incremental pattern
   */
  loadSnapshot(snapshot: Map<string, InMemoryLookupTypeProjection>): void {
    lookupTypeStore.clear();

    for (const [key, projection] of snapshot) {
      const [tenant, , code] = key.split(':');
      lookupTypeStore.set(tenant, code, projection);
    }

    this.updateMetrics();

    Log.info(this.logger, 'Snapshot loaded successfully', {
      method: 'loadSnapshot',
      entitiesLoaded: snapshot.size,
      memoryUsage: this.estimateMemoryUsage(),
    });
  }

  /**
   * Create snapshot for persistence or comparison
   */
  createSnapshot(): Map<string, InMemoryLookupTypeProjection> {
    const snapshot = new Map<string, InMemoryLookupTypeProjection>();

    for (const [key, projection] of lookupTypeStore.getAll()) {
      // Add projector-specific metadata to base projection
      const extendedProjection: InMemoryLookupTypeProjection = {
        ...projection,
        projectionTimestamp: new Date(),
        eventCount: 1, // Default values for snapshot
        lastEventType: 'snapshot',
      };
      snapshot.set(key, { ...extendedProjection }); // Deep copy for safety
    }

    Log.info(this.logger, 'Snapshot created', {
      method: 'createSnapshot',
      entitiesSnapshotted: snapshot.size,
    });

    return snapshot;
  }

  /**
   * Get current metrics
   */
  getMetrics(): ProjectionMetrics {
    this.updateMetrics();
    return this.metrics.getMetrics();
  }

  /**
   * Get projection by key with hit/miss tracking
   */
  getProjection(key: string): InMemoryLookupTypeProjection | undefined {
    const [tenant, , code] = key.split(':');
    const projection = lookupTypeStore.get(tenant, code);

    if (projection) {
      this.metrics.recordCacheHit();
      // Add projector-specific metadata to base projection
      return {
        ...projection,
        projectionTimestamp: new Date(),
        eventCount: 1, // Default value
        lastEventType: 'get',
      };
    } else {
      this.metrics.recordCacheMiss();
      return undefined;
    }
  }

  /**
   * Get all projections (for testing and inspection)
   */
  getAllProjections(): Array<[string, InMemoryLookupTypeProjection]> {
    return lookupTypeStore.getAll().map(([key, projection]) => [
      key,
      {
        ...projection,
        projectionTimestamp: new Date(),
        eventCount: 1, // Default value
        lastEventType: 'getAll',
      },
    ]);
  }

  /**
   * Clear all projections and reset metrics
   */
  clear(): void {
    lookupTypeStore.clear();
    void this.checkpointStore.clear();

    // Clear deduplication window
    this.recentEvents.clear();

    // Reset metrics
    this.metrics = new ProjectionMetricsCollector();

    Log.info(this.logger, 'In-memory projector cleared', {
      method: 'clear',
      status: 'reset',
    });
  }

  /**
   * Start the projector using CatchUpRunner
   */
  onModuleInit(): void {
    Log.info(
      this.logger,
      'Starting LookupType Projector (In-Memory) with CatchUpRunner',
      {
        method: 'onModuleInit',
        subscriptionGroup: this.subscriptionGroup,
        architecture: 'in-memory',
        maxCacheSize: 5000, // From lookupType store
      },
    );

    try {
      const runOptions: RunOptions = {
        prefixes: [LookupTypeProjectionKeys.getEventStoreStreamPrefix()],
        batchSize: 1000, // Higher batch size for in-memory processing
        stopOnCaughtUp: false,
        maxRetries: 3,
        retryDelayMs: 100, // Faster retries for in-memory
        checkpointBatchSize: 100,
      };

      // Start the projection in the background
      this.catchUpRunner
        .runSafe(
          this.subscriptionGroup,
          this.projectEvent.bind(this) as (
            event: ProjectionEvent,
          ) => Promise<void>,
          runOptions,
        )
        .then((result) => {
          if (!result.ok) {
            this.updateHealthStatusOnError(
              result.error.detail || 'Unknown error',
            );
            Log.error(this.logger, 'Projection failed to start', {
              method: 'onModuleInit',
              error: result.error.detail || 'Unknown error',
            });
          } else {
            Log.info(this.logger, 'Projection completed successfully', {
              method: 'onModuleInit',
              status: 'completed',
              finalMetrics: this.getMetrics(),
            });
          }
        })
        .catch((error) => {
          const e = error as Error;
          this.updateHealthStatusOnError(e.message);
          Log.error(this.logger, 'Projection failed with exception', {
            method: 'onModuleInit',
            error: e.message,
            stack: e.stack,
          });
        });

      this.setRunning(true);
      this.updateHealthStatusOnSuccess();

      Log.info(
        this.logger,
        'LookupType Projector (In-Memory) started successfully',
        {
          method: 'onModuleInit',
          status: 'running',
          initialMetrics: this.getMetrics(),
        },
      );
    } catch (error) {
      const e = error as Error;
      this.updateHealthStatusOnError(e.message);
      this.metrics.recordError();

      Log.error(
        this.logger,
        'Failed to start LookupType Projector (In-Memory)',
        {
          method: 'onModuleInit',
          error: e.message,
          stack: e.stack,
        },
      );
      throw error;
    }
  }

  /**
   * Stop the projector using CatchUpRunner shutdown
   */
  onModuleDestroy(): void {
    Log.info(this.logger, 'Stopping LookupType Projector (In-Memory)', {
      method: 'onModuleDestroy',
      subscriptionGroup: this.subscriptionGroup,
      finalMetrics: this.getMetrics(),
    });

    try {
      this.catchUpRunner.stop(this.subscriptionGroup);
      this.setRunning(false);

      Log.info(
        this.logger,
        'LookupType Projector (In-Memory) stopped successfully',
        {
          method: 'onModuleDestroy',
          status: 'stopped',
          totalEventsProcessed: this.metrics.getMetrics().totalEvents,
          finalCacheSize: lookupTypeStore.size(),
        },
      );
    } catch (error) {
      const e = error as Error;
      Log.error(
        this.logger,
        'Error stopping LookupType Projector (In-Memory)',
        {
          method: 'onModuleDestroy',
          error: e.message,
          stack: e.stack,
        },
      );
    }
  }

  /**
   * Project individual event using in-memory storage with LRU eviction
   */
  private projectEvent(event: ProjectionEvent): void {
    const start = performance.now();

    // Deduplication check - prevent processing same event multiple times
    const eventId = `${event.streamId}:${event.revision}`;
    const now = Date.now();
    const lastProcessed = this.recentEvents.get(eventId);

    if (lastProcessed && now - lastProcessed < this.dedupWindowMs) {
      Log.debug(this.logger, 'Duplicate event detected, skipping', {
        method: 'projectEvent',
        eventId,
        streamId: event.streamId,
        revision: event.revision,
        timeSinceLastMs: now - lastProcessed,
      });
      return;
    }

    // Clean up old entries periodically (simple cleanup every 100 events)
    if (this.recentEvents.size > 100) {
      const cutoff = now - this.dedupWindowMs;
      for (const [id, timestamp] of this.recentEvents) {
        if (timestamp < cutoff) {
          this.recentEvents.delete(id);
        }
      }
    }

    // Record this event processing
    this.recentEvents.set(eventId, now);

    const tenant = this.extractTenant(event);
    const pos = event.position
      ? `${event.position.commit}:${event.position.prepare}`
      : undefined;

    try {
      const params = this.extractLookupTypeParams(event, 'project');
      const key = this.buildProjectionKey(tenant, params.code);

      const projection = this.applyEventToMemory(event, params);

      // Store in shared lookupType store
      lookupTypeStore.set(tenant, params.code, projection);

      // Shadow mode: compare with expected projection
      if (this.shadowMode && this.shadowCallback) {
        this.shadowCallback(key, projection, undefined, undefined);
      }

      const latencyMs = performance.now() - start;
      this.metrics.recordEvent(latencyMs);

      // Update metrics after all write operations complete
      this.updateMetrics();

      Log.debug(this.logger, 'Event projected to in-memory', {
        method: 'projectEvent',
        eventType: event.type,
        streamId: event.streamId,
        revision: event.revision,
        tenant,
        code: params.code,
        version: projection.version,
        latencyMs,
        cacheSize: lookupTypeStore.size(),
        outcome: 'applied',
      });

      this.updateHealthStatusOnSuccess(pos);
    } catch (err) {
      const e = err as Error;
      this.updateHealthStatusOnError(e.message);
      this.metrics.recordError();
      Log.error(this.logger, 'Failed to project in-memory', {
        method: 'projectEvent',
        eventType: event.type,
        streamId: event.streamId,
        revision: event.revision,
        tenant,
        error: e.message,
        stack: e.stack,
        latencyMs: performance.now() - start,
      });
      throw new Error(
        withContext(LookupTypeProjectorErrors.DATABASE_OPERATION_FAILED, {
          eventType: event.type,
          streamId: event.streamId,
          originalError: e.message,
        }).detail,
        { cause: e },
      );
    }
  }

  /**
   * Apply event to in-memory projection
   */
  private applyEventToMemory(
    event: ProjectionEvent,
    params: ExtractedLookupTypeParams,
  ): InMemoryLookupTypeProjection {
    // Prefer event timestamp when available, fallback to clock
    const hasTimestamp = (e: unknown): e is { timestamp: string | number } => {
      return typeof e === 'object' && e !== null && 'timestamp' in e;
    };
    const eventTs =
      hasTimestamp(event) && event.timestamp
        ? new Date(event.timestamp)
        : this.clock.now();
    const existing = lookupTypeStore.get(params.tenant, params.code);

    // Stale/duplicate guard
    const incomingVersion = params.version ?? event.revision;
    if (existing && incomingVersion <= existing.version) {
      // Still advance health + metrics; do not mutate state
      this.metrics.recordEvent(0); // Tiny synthetic latency
      Log.debug(this.logger, 'Stale/duplicate event ignored', {
        method: 'applyEventToMemory',
        streamId: event.streamId,
        revision: event.revision,
        current: existing.version,
        incoming: incomingVersion,
      });
      // Convert to extended projection for return
      return {
        ...existing,
        projectionTimestamp: new Date(),
        eventCount: 1,
        lastEventType: 'stale-ignored',
      };
    }

    switch (event.type) {
      case 'CoreAttributesLookupTypeCreated.v1':
        return this.handleLookupTypeCreated(params, event, eventTs);
      case 'CoreAttributesLookupTypeUpdated.v1':
        return this.handleLookupTypeUpdated(params, event, eventTs);
      case 'CoreAttributesLookupTypeDeleted.v1':
        return this.handleLookupTypeDeleted(params, event, eventTs);
      default:
        Log.warn(this.logger, 'Unknown event type in in-memory projection', {
          method: 'applyEventToMemory',
          eventType: event.type,
          streamId: event.streamId,
        });
        // Return current projection or create minimal one
        return this.createMinimalProjection(params, event, eventTs);
    }
  }

  /**
   * Handle LookupTypeCreated event
   */
  private handleLookupTypeCreated(
    params: ExtractedLookupTypeParams,
    event: ProjectionEvent,
    timestamp: Date,
  ): InMemoryLookupTypeProjection {
    return {
      ...params,
      version: params.version || event.revision,
      createdAt: timestamp,
      updatedAt: timestamp,
      deletedAt: null,
      lastStreamRevision: event.revision.toString(),
      projectionTimestamp: timestamp,
      eventCount: 1,
      lastEventType: event.type,
    };
  }

  /**
   * Handle LookupTypeUpdated event
   */
  private handleLookupTypeUpdated(
    params: ExtractedLookupTypeParams,
    event: ProjectionEvent,
    timestamp: Date,
  ): InMemoryLookupTypeProjection {
    const existing = lookupTypeStore.get(params.tenant, params.code);

    return {
      ...params,
      version: params.version || event.revision,
      createdAt: existing?.createdAt || timestamp,
      updatedAt: timestamp,
      deletedAt: null,
      lastStreamRevision: event.revision.toString(),
      projectionTimestamp: timestamp,
      eventCount: 1, // Simplified for now
      lastEventType: event.type,
    };
  }

  /**
   * Handle LookupTypeDeleted event
   */
  private handleLookupTypeDeleted(
    params: ExtractedLookupTypeParams,
    event: ProjectionEvent,
    timestamp: Date,
  ): InMemoryLookupTypeProjection {
    const existing = lookupTypeStore.get(params.tenant, params.code);

    return {
      ...params,
      version: params.version || event.revision,
      createdAt: existing?.createdAt || timestamp,
      updatedAt: timestamp,
      deletedAt: timestamp,
      lastStreamRevision: event.revision.toString(),
      projectionTimestamp: timestamp,
      eventCount: 1, // Simplified for now
      lastEventType: event.type,
    };
  }

  /**
   * Create minimal projection for unknown events
   */
  private createMinimalProjection(
    params: ExtractedLookupTypeParams,
    event: ProjectionEvent,
    timestamp: Date,
  ): InMemoryLookupTypeProjection {
    return {
      ...params,
      version: params.version || event.revision,
      createdAt: timestamp,
      updatedAt: timestamp,
      deletedAt: null,
      lastStreamRevision: event.revision.toString(),
      projectionTimestamp: timestamp,
      eventCount: 1,
      lastEventType: event.type,
    };
  }

  /**
   * Build projection key for tenant isolation
   */
  private buildProjectionKey(tenant: string, code: string): string {
    return `${tenant}:lookup-type:${code}`;
  }

  /**
   * Extract tenant ID from event using shared utility
   */
  private extractTenant(event: ProjectionEvent): string {
    return TenantExtractor.extractTenant(event);
  }

  /**
   * Extract lookupType parameters from event data using LookupTypeFieldValidatorUtil
   *
   * Uses LookupTypeFieldValidatorUtil to create validated DetailLookupTypeResponse for consistent
   * validation across repository and projector, and TenantExtractor for reliable tenant identification.
   */
  private extractLookupTypeParams(
    event: ProjectionEvent,
    operation: string,
  ): ExtractedLookupTypeParams {
    try {
      const eventData = event.data as Record<string, any>;

      // Extract tenant using shared utility
      const tenant = TenantExtractor.extractTenant(event);

      // Use LookupTypeFieldValidatorUtil to create validated initiation fee snapshot
      const lookupTypeSnapshot =
        LookupTypeFieldValidatorUtil.createLookupTypeProjectorDataFromEventData(
          eventData,
        );

      const attributes = safeParseJSON<
        Record<string, DetailAttributeruleResponse>
      >(lookupTypeSnapshot.attributes, 'attributes');

      // Add projector-specific fields for in-memory storage
      return {
        ...lookupTypeSnapshot,
        attributes,
        tenant,
      };
    } catch (error) {
      const e = error as Error;
      throw new Error(
        withContext(LookupTypeProjectorErrors.INVALID_EVENT_DATA, {
          eventType: event.type,
          streamId: event.streamId,
          operation,
          originalError: e.message,
        }).detail,
      );
    }
  }

  /**
   * Update metrics with current state
   */
  private updateMetrics(): void {
    this.metrics.updateEntityCount(lookupTypeStore.size());
    this.metrics.updateMemoryUsage(this.estimateMemoryUsage());
  }

  /**
   * Estimate memory usage (rough approximation)
   */
  private estimateMemoryUsage(): number {
    // Rough estimate: 1KB per projection + overhead
    return lookupTypeStore.size() * 1024;
  }
}
