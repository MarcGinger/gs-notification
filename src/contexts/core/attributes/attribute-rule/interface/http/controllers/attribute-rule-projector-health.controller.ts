// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// AttributeRule Projector Health Controller
// Provides health check endpoints for the AttributeRule Projector

import { Controller, Get, Inject } from '@nestjs/common';
import { APP_LOGGER, Log, componentLogger, Logger } from 'src/shared/logging';
import { AttributeRuleProjector } from '../../../infrastructure/projectors';
import { AttributeRuleProjectionKeys } from '../../../attribute-rule-projection-keys';

@Controller('health/projectors')
export class AttributeRuleProjectorHealthController {
  private readonly logger: Logger;

  constructor(
    private readonly attributeRuleProjector: AttributeRuleProjector,
    @Inject(APP_LOGGER) baseLogger: Logger,
  ) {
    this.logger = componentLogger(
      baseLogger,
      'AttributeRuleProjectorHealthController',
    );
  }

  @Get('attributeRule')
  async getAttributeRuleProjectorHealth() {
    try {
      const health = this.attributeRuleProjector.getHealthStatus();
      const checkpoint =
        await this.attributeRuleProjector.getCurrentCheckpoint();

      Log.debug(this.logger, 'AttributeRule projector health check', {
        isHealthy: health.isHealthy,
        isRunning: health.isRunning,
        projectorName: health.projectorName,
        hasCheckpoint: !!checkpoint,
      });

      return {
        isHealthy: health.isHealthy,
        isRunning: health.isRunning,
        projectorName: health.projectorName,
        subscriptionGroup: health.subscriptionGroup,
        eventsProcessed: health.eventsProcessed,
        lastProcessedAt: health.lastProcessedAt?.toISOString() || null,
        lastError: health.lastError,
        checkpointPosition: checkpoint,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      const e = error as Error;

      Log.error(this.logger, 'AttributeRule projector health check failed', {
        error: e.message,
        stack: e.stack,
      });

      return {
        isHealthy: false,
        isRunning: false,
        projectorName: AttributeRuleProjectionKeys.PROJECTOR_NAME,
        subscriptionGroup: AttributeRuleProjectionKeys.SUBSCRIPTION_GROUP,
        eventsProcessed: 0,
        lastProcessedAt: null,
        lastError: e.message,
        checkpointPosition: null,
        timestamp: new Date().toISOString(),
      };
    }
  }

  @Get('attribute-rule/metrics')
  async getAttributeRuleProjectorMetrics() {
    try {
      const health = this.attributeRuleProjector.getHealthStatus();
      const checkpoint =
        await this.attributeRuleProjector.getCurrentCheckpoint();

      // This would typically integrate with your metrics system
      // For now, return basic health metrics
      return {
        projector_status: health.isHealthy ? 1 : 0,
        projector_running: health.isRunning ? 1 : 0,
        events_processed: health.eventsProcessed,
        checkpoint_position: checkpoint || '0:0',
        last_processed_at: health.lastProcessedAt?.toISOString() || null,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      const e = error as Error;

      Log.error(this.logger, 'AttributeRule projector metrics failed', {
        error: e.message,
      });

      return {
        projector_status: 0,
        projector_running: 0,
        events_processed: 0,
        checkpoint_position: '0:0',
        last_processed_at: null,
        timestamp: new Date().toISOString(),
        error: e.message,
      };
    }
  }
}
