// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Inject } from '@nestjs/common';
import {
  Result,
  ok,
  err,
  DomainError,
  isOk,
  withContext,
} from 'src/shared/errors';

// Shared utilities and infrastructure
import { APP_LOGGER, componentLogger, Logger } from 'src/shared/logging';
import { CACHE_TTL } from 'src/shared/application/caching/cache.config';
import { RepositoryOptions } from 'src/shared/infrastructure/repositories/repository.types';
import { Option } from 'src/shared/domain/types';
import { ActorContextUtil } from 'src/shared/utilities/actor-context.util';
import { IUserToken } from 'src/shared/security';

// Application layer
import { IAttributeRuleQuery, ATTRIBUTE_RULE_QUERY_TOKEN } from '../ports';
import { DetailAttributeRuleResponse } from '../dtos';
import { IGetAttributeRuleUseCase } from './contracts';
import { AttributeRuleErrors } from '../../domain/errors';

/**
 * Get AttributeRule Use Case - Simplified CQRS Read Side Implementation
 *
 * Simple use case that queries for attributeRule data by code.
 * Authorization is handled at the service layer.
 */

@Injectable()
export class GetAttributeRuleUseCase implements IGetAttributeRuleUseCase {
  private readonly logger: Logger;

  constructor(
    @Inject(ATTRIBUTE_RULE_QUERY_TOKEN)
    private readonly query: IAttributeRuleQuery,
    @Inject(APP_LOGGER) moduleLogger: Logger,
  ) {
    this.logger = componentLogger(moduleLogger, 'GetAttributeRuleUseCase');
  }

  async execute(params: {
    user: IUserToken;
    code: string;
    correlationId: string;
  }): Promise<Result<DetailAttributeRuleResponse, DomainError>> {
    const { user, code, correlationId } = params;

    // Simple input validation
    if (!code?.trim()) {
      return err({
        code: 'ATTRIBUTE_RULE.INVALID_CODE' as const,
        title: 'Invalid code',
        category: 'validation' as const,
        context: { code, correlationId, userId: user.sub },
      });
    }

    // Setup repository options with caching
    const repositoryOptions: RepositoryOptions = {
      cache: {
        ttl: CACHE_TTL.STANDARD,
        refreshCache: false,
      },
      correlationId,
      requestId: user.sub,
    };

    // Convert user token to actor context
    const actorResult = ActorContextUtil.fromUserTokenSafe(user);
    if (!isOk(actorResult)) {
      return err(
        withContext(actorResult.error, {
          correlationId,
          userId: user.sub,
          operation: 'get_attribute_rule',
          code,
        }),
      );
    }

    // Query for the attributeRule data
    const queryResult = await this.query.findById(
      actorResult.value,
      code,
      repositoryOptions,
    );

    if (!isOk(queryResult)) {
      return err(
        withContext(queryResult.error, {
          correlationId,
          userId: user.sub,
          operation: 'get_attribute_rule',
          code,
        }),
      );
    }

    // Handle Option<DetailAttributeRuleResponse>
    const attributeRuleDto = Option.isNone(queryResult.value)
      ? null
      : queryResult.value.value;

    if (!attributeRuleDto) {
      return err(
        withContext(AttributeRuleErrors.ATTRIBUTE_RULE_NOT_FOUND, {
          code,
          correlationId,
          userId: user.sub,
          operation: 'get_attribute_rule',
        }),
      );
    }

    // Success - no logging needed as this is handled at service layer

    return ok(attributeRuleDto);
  }
}
