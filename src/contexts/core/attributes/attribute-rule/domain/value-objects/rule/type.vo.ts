// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import {
  EnumVOInstance,
  createDisplayNameHelper,
  createEnumTypeGuards,
  createEnumVO,
  createEnumVOErrors,
  createStateTransitions,
} from 'src/shared/domain/value-objects';
import { Result, DomainError } from 'src/shared/errors';
import { RuleErrors } from '../../errors/rule.errors';

// ============================================================================
// SINGLE SOURCE OF TRUTH
// ============================================================================

/**
 * RuleType allowed values
 * Canonical definition used across all layers (API, Domain, DB)
 */
export const RuleTypeValues = [
  'string',
  'boolean',
  'integer',
  'currency',
  'date',
  'datetime',
  'other',
] as const;
export type RuleTypeValue = (typeof RuleTypeValues)[number];

// ============================================================================
// VALUE OBJECT - Domain Layer
// ============================================================================

/**
 * RuleType Value Object
 *
 * Provides validation, business rules, and rich domain behavior
 * for rule type enumerated values.
 *
 * @example
 * ```typescript
 * const type = RuleType.create('string');
 * if (type.ok) {
 *   console.log(type.value.canTransitionTo('boolean'));
 * }
 * ```
 */
export const RuleType = createEnumVO({
  name: 'RuleType',
  values: RuleTypeValues,
  required: true,
  errors: createEnumVOErrors(RuleErrors.INVALID_TYPE, 'RuleType'),
});

export type RuleType = EnumVOInstance<RuleTypeValue>;

// ============================================================================
// CONVENIENCE FACTORIES
// ============================================================================

export const createRuleType = (value: RuleTypeValue | undefined) =>
  RuleType.create(value) as Result<RuleType, DomainError>;
export const ruleTypeFrom = (value: unknown) =>
  RuleType.from(value) as Result<RuleType, DomainError>;

// ============================================================================
// BUSINESS LOGIC HELPERS - Domain Behavior
// ============================================================================

/**
 * Valid state transitions for rule type
 */
const RULE_TYPE_TRANSITIONS = {
  string: [
    'boolean',
    'integer',
    'currency',
    'date',
    'datetime',
    'other',
  ] as const,
  boolean: [
    'string',
    'integer',
    'currency',
    'date',
    'datetime',
    'other',
  ] as const,
  integer: [
    'string',
    'boolean',
    'currency',
    'date',
    'datetime',
    'other',
  ] as const,
  currency: [
    'string',
    'boolean',
    'integer',
    'date',
    'datetime',
    'other',
  ] as const,
  date: [
    'string',
    'boolean',
    'integer',
    'currency',
    'datetime',
    'other',
  ] as const,
  datetime: [
    'string',
    'boolean',
    'integer',
    'currency',
    'date',
    'other',
  ] as const,
  other: [
    'string',
    'boolean',
    'integer',
    'currency',
    'date',
    'datetime',
  ] as const,
} as const;

/**
 * Display names for rule type values
 */
const RULE_TYPE_DISPLAY_NAMES = {
  string: 'String',
  boolean: 'Boolean',
  integer: 'Integer',
  currency: 'Currency',
  date: 'Date',
  datetime: 'Datetime',
  other: 'Other',
} as const;

/**
 * State machine helpers for RuleType transitions
 */
const RuleTypeTransitions = createStateTransitions(RULE_TYPE_TRANSITIONS);

/**
 * Type guards for RuleType values
 */
const RuleTypeGuards = createEnumTypeGuards(
  RuleTypeValues,
  'RuleType',
  (value, validValues) => ({
    ...RuleErrors.INVALID_TYPE,
    detail: `RuleType must be one of: ${validValues.join(', ')}, received: ${String(value)}`,
    context: { value, validValues },
  }),
);

/**
 * Display name helpers for RuleType
 */
const RuleTypeDisplay = createDisplayNameHelper(RULE_TYPE_DISPLAY_NAMES);

/**
 * Business logic functions for RuleType
 */
export const RuleTypeLogic = {
  /**
   * Check if transition from one state to another is valid
   */
  canTransition: (from: RuleTypeValue, to: RuleTypeValue): boolean =>
    RuleTypeTransitions.canTransition(from, to),

  /**
   * Get all valid next states from current state
   */
  getValidTransitions: (from: RuleTypeValue): readonly RuleTypeValue[] =>
    RuleTypeTransitions.getValidTransitions(from),

  /**
   * Get human-readable display name
   */
  getDisplayName: (value: RuleTypeValue): string =>
    RuleTypeDisplay.getDisplayName(value),

  /**
   * Get all available values with metadata
   */
  getAllValues(): Array<{
    value: RuleTypeValue;
    displayName: string;
    validTransitions: readonly RuleTypeValue[];
  }> {
    return RuleTypeValues.map((value) => ({
      value,
      displayName: RuleTypeLogic.getDisplayName(value),
      validTransitions: RuleTypeLogic.getValidTransitions(value),
    }));
  },
} as const;

// ============================================================================
// TYPE GUARDS - Runtime Type Checking
// ============================================================================

/**
 * Type guard to check if value is valid RuleType
 */
export const isRuleTypeValue = (value: unknown): value is RuleTypeValue =>
  RuleTypeGuards.isValid(value);

/**
 * Assert that value is valid RuleType (throws if invalid)
 */
export const assertRuleTypeValue = (
  value: unknown,
): asserts value is RuleTypeValue => RuleTypeGuards.assert(value);
