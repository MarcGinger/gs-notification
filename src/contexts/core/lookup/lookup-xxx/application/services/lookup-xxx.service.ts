// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

/**
 * LookupXxx Application Service
 *
 * Application-layer service that coordinates authorization with business operations.
 */

// Framework imports
import { Inject, Injectable } from '@nestjs/common';

// Shared utilities and infrastructure
import { APP_LOGGER, Log, componentLogger, Logger } from 'src/shared/logging';
import { Result, DomainError, err, ok, withContext } from 'src/shared/errors';
import type { IUserToken } from 'src/shared/security';
import { CorrelationUtil } from 'src/shared/utilities/correlation.util';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';

// Service configuration
import { LookupServiceConstants } from '../../../service-constants';

// Domain types and errors
import { LookupXxxErrors } from '../../domain/errors/lookup-xxx.errors';
import {
  DetailLookupXxxResponse,
  ListLookupXxxFilterRequest,
  LookupXxxPageResponse,
  CreateLookupXxxRequest,
  UpdateLookupXxxRequest,
} from '../dtos';

// Application layer
import { LookupXxxAuthorizationService } from './lookup-xxx-authorization.service';
import { LookupXxxAuthContext } from '../types/lookup-xxx-auth-context';

// Use case contracts
import {
  ICreateLookupXxxUseCase,
  IUpdateLookupXxxUseCase,
  IDeleteLookupXxxUseCase,
  IGetLookupXxxUseCase,
  IListLookupXxxUseCase,
} from '../use-cases/contracts';

/**
 * Application Service for LookupXxx operations with integrated authorization
 */
@Injectable()
export class LookupXxxApplicationService {
  private readonly logger: Logger;

  constructor(
    private readonly lookupXxxAuthorizationService: LookupXxxAuthorizationService,
    private readonly createLookupXxxUseCase: ICreateLookupXxxUseCase,
    private readonly updateLookupXxxUseCase: IUpdateLookupXxxUseCase,
    private readonly deleteLookupXxxUseCase: IDeleteLookupXxxUseCase,
    private readonly getLookupXxxUseCase: IGetLookupXxxUseCase,
    private readonly listLookupXxxUseCase: IListLookupXxxUseCase,
    @Inject(CLOCK) private readonly clock: Clock,
    @Inject(APP_LOGGER) moduleLogger: Logger,
  ) {
    this.logger = componentLogger(moduleLogger, 'LookupXxxApplicationService');
  }

  /**
   * Helper to create LookupXxxAuthContext from user token
   */
  private createAuthContext(
    user: IUserToken,
    operation: string,
  ): LookupXxxAuthContext {
    return {
      tenant: user.tenant,
      tenant_userId: user.tenant_id || '',
      roles: user.roles || [],
      operationType: operation,
      metadata: {
        userId: user.sub,
        timestamp: this.clock.nowIso(),
      },
    };
  }

  /**
   * Helper to create consistent logging context
   */
  private createLogContext(
    operation: string,
    correlationId: string,
    userId: string,
    additionalContext?: Record<string, unknown>,
  ): Record<string, unknown> {
    return {
      serviceName: LookupServiceConstants.SERVICE_NAME,
      component: 'LookupXxxApplicationService',
      operation,
      correlationId,
      userId,
      ...additionalContext,
    };
  }

  /**
   * Helper to validate required code input
   */
  private validateCode(
    code: string,
    operation: string,
    correlationId?: string,
  ): Result<string, DomainError> {
    if (!code?.trim()) {
      return err(
        withContext(LookupXxxErrors.INVALID_LOOKUP_XXX_DATA, {
          operation,
          correlationId:
            correlationId ||
            CorrelationUtil.generateForOperation(`lookup-xxx-${operation}`),
        }),
      );
    }
    return ok(code.trim());
  }

  /**
   * Centralized auth → log → execute → catch pattern
   */
  private async authorizeThenExecute<T>(args: {
    operation: 'create' | 'update' | 'delete' | 'read';
    user: IUserToken;
    code?: string;
    correlationIdPrefix: string;
    doAuthorize: () => Promise<Result<boolean, DomainError>>;
    doExecute: () => Promise<Result<T, DomainError>>;
    logContext?: Record<string, unknown>;
  }): Promise<Result<T, DomainError>> {
    const corrId = CorrelationUtil.generateForOperation(
      args.correlationIdPrefix,
    );
    const ctx = {
      ...this.createLogContext(
        `${args.operation}_lookup_xxx`,
        corrId,
        args.user.sub,
        args.logContext,
      ),
    };

    const auth = await args.doAuthorize();
    if (!auth.ok) {
      Log.warn(this.logger, `${args.operation} authorization failed`, {
        ...ctx,
        authDecision: 'deny',
      });
      return err(auth.error);
    }
    if (!auth.value) {
      Log.warn(this.logger, `${args.operation} permission denied`, {
        ...ctx,
        authDecision: 'deny',
      });
      return err(
        withContext(LookupXxxErrors.PERMISSION_DENIED, {
          correlationId: corrId,
          userId: args.user.sub,
          operation: args.operation,
          code: args.code,
          category: 'security',
        }),
      );
    }

    Log.info(this.logger, `LookupXxx ${args.operation} authorized`, {
      ...ctx,
      authDecision: 'allow',
    });

    try {
      return await args.doExecute();
    } catch (error) {
      Log.error(this.logger, `LookupXxx ${args.operation} use case failed`, {
        ...ctx,
        error: error instanceof Error ? error.message : String(error),
      });
      return err({
        code: `DOMAIN.LOOKUP_XXX.${args.operation.toUpperCase()}_FAILED`,
        title: `LookupXxx ${args.operation} failed`,
        detail: error instanceof Error ? error.message : 'Unknown error',
        category: 'application',
        context: {
          correlationId: corrId,
          code: args.code,
          operation: `${args.operation}_lookup_xxx`,
        },
      });
    }
  }

  /**
   * Create a new lookupXxx with authorization
   */
  async createLookupXxx(
    user: IUserToken,
    lookupType: string,
    props: CreateLookupXxxRequest,
    options?: { idempotencyKey?: string; correlationId?: string },
  ): Promise<Result<DetailLookupXxxResponse, DomainError>> {
    const authContext = this.createAuthContext(user, 'create');
    const correlationId =
      options?.correlationId ||
      CorrelationUtil.generateForOperation('lookup-xxx-create');

    return this.authorizeThenExecute<DetailLookupXxxResponse>({
      operation: 'create',
      user,
      correlationIdPrefix: 'lookup-xxx-create',
      doAuthorize: () =>
        this.lookupXxxAuthorizationService.canCreateLookupXxx(
          user.sub,
          correlationId,
          authContext,
        ),
      doExecute: () =>
        this.createLookupXxxUseCase.execute({
          user,
          props: {
            ...props,
            lookupType,
          },
          correlationId,
          authorizationReason: 'create_lookup_xxx',
          ...(options?.idempotencyKey && {
            idempotencyKey: options.idempotencyKey,
          }),
        }),
    });
  }

  /**
   * Update an existing lookupXxx with authorization
   */
  async updateLookupXxx(
    user: IUserToken,
    lookupType: string,
    code: string,
    props: UpdateLookupXxxRequest,
    options?: { idempotencyKey?: string; correlationId?: string },
  ): Promise<Result<DetailLookupXxxResponse, DomainError>> {
    // Early input validation
    const codeValidation = this.validateCode(code, 'update');
    if (!codeValidation.ok) {
      return err(codeValidation.error);
    }

    const validatedcode = codeValidation.value;
    const authContext = this.createAuthContext(user, 'update');
    const correlationId =
      options?.correlationId ||
      CorrelationUtil.generateForOperation('lookup-xxx-update');

    // Optional: Field-level authorization
    // Uncomment when LookupXxxAuthorizationService supports authorizeLookupXxxOperation
    /*
    const fields = extractDefinedFields(props); // Use shared utility
    const opAuth = await this.lookupXxxAuthorizationService.authorizeLookupXxxOperation(
      user.sub, 
      'update', 
      CorrelationUtil.generateForOperation('lookup-xxx-update'), 
      validatedcode, 
      fields, 
      authContext
    );
    if (!opAuth.ok) return err(opAuth.error);
    if (!opAuth.value.authorized) {
      return err(withContext(LookupXxxErrors.PERMISSION_DENIED, { 
        operation: 'update', 
        code: validatedcode, 
        userId: user.sub,
        category: 'security'
      }));
    }
    */

    return this.authorizeThenExecute<DetailLookupXxxResponse>({
      operation: 'update',
      user,
      code: validatedcode,
      correlationIdPrefix: 'lookup-xxx-update',
      doAuthorize: () =>
        this.lookupXxxAuthorizationService.canUpdateLookupXxx(
          user.sub,
          validatedcode,
          correlationId,
          authContext,
        ),
      doExecute: () =>
        this.updateLookupXxxUseCase.execute({
          user,
          code: validatedcode,
          props: {
            ...props,
            lookupType,
            code: validatedcode,
          },
          correlationId,
          authorizationReason: 'update_lookup_xxx',
          ...(options?.idempotencyKey && {
            idempotencyKey: options.idempotencyKey,
          }),
        }),
      logContext: { code: validatedcode },
    });
  }

  /**
   * Delete a lookupXxx with authorization
   */
  async deleteLookupXxx(
    user: IUserToken,
    lookupType: string,
    code: string,
  ): Promise<Result<void, DomainError>> {
    // Early input validation
    const codeValidation = this.validateCode(code, 'delete');
    if (!codeValidation.ok) {
      return err(codeValidation.error);
    }

    const validatedcode = codeValidation.value;
    const authContext = this.createAuthContext(user, 'delete');

    return this.authorizeThenExecute<void>({
      operation: 'delete',
      user,
      code: validatedcode,
      correlationIdPrefix: 'lookup-xxx-delete',
      doAuthorize: () =>
        this.lookupXxxAuthorizationService.canDeleteLookupXxx(
          user.sub,
          validatedcode,
          CorrelationUtil.generateForOperation('lookup-xxx-delete'),
          authContext,
        ),
      doExecute: () => {
        // Log high-risk operation before execution
        Log.warn(
          this.logger,
          'LookupXxx deletion authorized - HIGH RISK OPERATION',
          {
            code: validatedcode,
            userId: user.sub,
            riskLevel: 'HIGH',
            operation: 'delete_lookup_xxx',
          },
        );
        return this.deleteLookupXxxUseCase.execute({
          user,
          lookupType,
          code: validatedcode,
          correlationId:
            CorrelationUtil.generateForOperation('lookup-xxx-delete'),
          authorizationReason: 'delete_lookup_xxx',
        });
      },
      logContext: { code: validatedcode, riskLevel: 'HIGH' },
    });
  }

  /**
   * Get a lookupXxx by code with authorization
   */
  async getLookupXxxById(
    user: IUserToken,
    lookupType: string,
    code: string,
  ): Promise<Result<DetailLookupXxxResponse, DomainError>> {
    // Early input validation
    const codeValidation = this.validateCode(code, 'read');
    if (!codeValidation.ok) {
      return err(codeValidation.error);
    }

    const validatedcode = codeValidation.value;
    const authContext = this.createAuthContext(user, 'read');

    return this.authorizeThenExecute<DetailLookupXxxResponse>({
      operation: 'read',
      user,
      code: validatedcode,
      correlationIdPrefix: 'lookup-xxx-read',
      doAuthorize: () =>
        this.lookupXxxAuthorizationService.canReadLookupXxx(
          user.sub,
          validatedcode,
          CorrelationUtil.generateForOperation('lookup-xxx-read'),
          authContext,
        ),
      doExecute: () =>
        this.getLookupXxxUseCase.execute({
          user,
          lookupType,
          code: validatedcode,
          correlationId:
            CorrelationUtil.generateForOperation('lookup-xxx-read'),
        }),
      logContext: { code: validatedcode },
    });
  }

  /**
   * List lookupXxxs with authorization and pagination
   */
  async listLookupXxxs(
    user: IUserToken,
    lookupType: string,
    filter?: ListLookupXxxFilterRequest,
  ): Promise<Result<LookupXxxPageResponse, DomainError>> {
    const authContext = this.createAuthContext(user, 'list');
    const correlationId =
      CorrelationUtil.generateForOperation('lookup-xxx-list');

    // Ensure we always have a proper filter object
    const safeFilter = filter || new ListLookupXxxFilterRequest();

    return this.authorizeThenExecute<LookupXxxPageResponse>({
      operation: 'read', // List is a form of read operation
      user,
      correlationIdPrefix: 'lookup-xxx-list',
      doAuthorize: () =>
        this.lookupXxxAuthorizationService.canReadLookupXxx(
          user.sub,
          'list', // Use 'list' as a special code for list operations
          correlationId,
          authContext,
        ),
      doExecute: () =>
        this.listLookupXxxUseCase.execute({
          user,
          lookupType,
          filter: safeFilter,
          correlationId,
        }),
      logContext: {
        operation: 'list_lookup_xxxs',
        pageSize: safeFilter.size,
        page: safeFilter.page,
      },
    });
  }
}
