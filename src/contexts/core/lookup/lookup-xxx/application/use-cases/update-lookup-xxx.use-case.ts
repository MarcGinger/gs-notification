// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Framework imports
import { Injectable, Inject } from '@nestjs/common';
import { Result, DomainError, ok, err, withContext } from 'src/shared/errors';
import { ActorContext } from 'src/shared/application/context';

// Shared utilities and infrastructure
import { APP_LOGGER, componentLogger, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import { Option } from 'src/shared/domain/types';
import { runUseCaseWithSecurity } from 'src/shared/application/utils';
import { extractDefinedFields } from 'src/shared/utilities';
import {
  UseCaseLoggingUtil,
  UseCaseLoggingConfig,
} from 'src/shared/application/utils/use-case-logging.util';
import { IUserToken } from 'src/shared/security';

// Service configuration
import { LookupServiceConstants } from '../../../service-constants';

// Domain types and errors
import { LookupXxxAggregate } from '../../domain/aggregates';
import { LookupXxxCode } from '../../domain/value-objects';
import { updateLookupXxxAggregateFromSnapshot } from '../../domain/factories';
import { LookupXxxErrors } from '../../domain/errors';
import { UpdateLookupXxxProps } from '../../domain/props';

// Application layer
import { UpdateLookupXxxCommand } from '../commands';
import {
  ILookupXxxReader,
  ILookupXxxWriter,
  LOOKUP_XXX_READER_TOKEN,
  LOOKUP_XXX_WRITER_TOKEN,
} from '../ports';
import { LookupXxxAuthorizationAdapter } from '../services';
import { DetailLookupXxxResponse } from '../dtos';
import { LookupXxxDtoAssembler } from '../assemblers';
import { IUpdateLookupXxxUseCase } from './contracts';

type LookupXxxSnapshot = Parameters<
  typeof updateLookupXxxAggregateFromSnapshot
>[0];

@Injectable()
export class UpdateLookupXxxUseCase implements IUpdateLookupXxxUseCase {
  private readonly logger: Logger;
  private readonly loggingConfig: UseCaseLoggingConfig;

  constructor(
    @Inject(LOOKUP_XXX_READER_TOKEN)
    private readonly lookupXxxReader: ILookupXxxReader,
    @Inject(LOOKUP_XXX_WRITER_TOKEN)
    private readonly lookupXxxWriter: ILookupXxxWriter,
    private readonly authorizationService: LookupXxxAuthorizationAdapter,
    @Inject(APP_LOGGER)
    readonly moduleLogger: Logger,
    @Inject(CLOCK)
    private readonly clock: Clock,
  ) {
    this.loggingConfig = {
      serviceName: LookupServiceConstants.SERVICE_NAME,
      component: 'UpdateLookupXxxUseCase',
      domain: 'lookup',
      entityType: 'lookup-xxx',
    };
    this.logger = componentLogger(moduleLogger, this.loggingConfig.component);
  }
  async execute(params: {
    user: IUserToken;
    code: string;
    props: UpdateLookupXxxProps;
    correlationId: string;
    authorizationReason: string;
  }): Promise<Result<DetailLookupXxxResponse, DomainError>> {
    const operation = 'update_lookup_xxx';
    const startTime = this.clock.nowMs();

    // Create a command-like object for internal use
    const command = {
      user: params.user,
      code: params.code,
      props: params.props,
      correlationId: params.correlationId,
      authorizationReason: params.authorizationReason,
      securityContext: {
        tenant: params.user.tenant,
        userId: params.user.sub,
        roles: params.user.roles,
      },
      timestamp: this.clock.now(),
    };

    // Step 1: Validate command (before creating any log context to avoid PII logging)
    const validation = UseCaseLoggingUtil.validateCommand(
      this.logger,
      command,
      {}, // Empty context to avoid PII logging during validation
    );
    if (!validation.ok) {
      return err(validation.error);
    }

    // Step 2: Create basic log context for audit trail
    const safeLogContext = UseCaseLoggingUtil.createLogContext(
      this.loggingConfig,
      this.clock,
      operation,
      {
        correlationId: command.correlationId,
        user: command.user,
        securityContext: command.securityContext,
        timestamp: command.timestamp,
      },
      {
        lookupXxxCode: command.code,
        operationRisk: UseCaseLoggingUtil.assessOperationRisk(operation),
      },
    );

    // Step 3: Process update operation with audit logging
    const rawProps = command.props; // Keep original for domain processing

    // Extract fields for field-level authorization using shared utility
    const fieldsToUpdate = extractDefinedFields(rawProps || {});

    // Step 4: Update aggregate
    const aggregateResult = await runUseCaseWithSecurity<
      UpdateLookupXxxCommand,
      LookupXxxAggregate,
      LookupXxxSnapshot
      // { LookupXxxs?: LookupXxxReference[] }
    >({
      serviceName: LookupServiceConstants.SERVICE_NAME,
      component: 'UpdateLookupXxxUseCase',
      operation: 'update_lookup_xxx',
      source: 'lookup.application.update-lookup-xxx',
      command,
      logger: this.logger,
      clock: this.clock,
      repo: {
        save: async (
          actor: ActorContext,
          lookupXxx: LookupXxxAggregate,
          expectedVersion?: number,
        ) => {
          const result = await this.lookupXxxWriter.save(
            actor,
            lookupXxx,
            expectedVersion,
          );
          return result.ok ? ok(undefined) : result;
        },
      },
      propsMissingError: LookupXxxErrors.INVALID_LOOKUP_XXX_DATA,

      // Security configuration
      authorizationService: this.authorizationService,
      authorization: {
        type: 'update',
        operation: 'update',
        resourceId: command.code,
        fields: fieldsToUpdate.map(String),
      },
      authContext: {
        userId: command.user.sub,
        tenant: command.user.tenant,
        tenant_userId: command.user.tenant_id,
        roles: command.user.roles,
        operationType: 'update',
      },

      // Load existing snapshot or return LOOKUP_XXX_NOT_FOUND with context
      loadExisting: async (actor, cmd) => {
        const codeR = LookupXxxCode.from(cmd.code);
        if (!codeR.ok) return err(codeR.error);

        const foundR = await this.lookupXxxReader.findById(
          actor,
          cmd.props.lookupType ?? '',
          codeR.value,
        );
        if (!foundR.ok) {
          return err(
            withContext(LookupXxxErrors.LOOKUP_XXX_NOT_FOUND, {
              correlationId: cmd.correlationId,
              userId: cmd.user.sub,
              operation: 'update_lookup_xxx',
              code: cmd.code,
            }),
          );
        }

        if (Option.isNone(foundR.value)) {
          return err(
            withContext(LookupXxxErrors.LOOKUP_XXX_NOT_FOUND, {
              correlationId: cmd.correlationId,
              userId: cmd.user.sub,
              operation: 'update_lookup_xxx',
              code: cmd.code,
            }),
          );
        }

        return ok(foundR.value.value); // snapshot
      },

      // Merge + validate via domain factory
      runDomain: ({ existing, metadata, clock }) => {
        return updateLookupXxxAggregateFromSnapshot(
          existing!,
          rawProps || {},
          metadata,
          clock,
        );
      },
    });

    // Step 4: Transform aggregate to DTO for API response
    if (!aggregateResult.ok) {
      UseCaseLoggingUtil.logOperationError(
        this.logger,
        operation,
        safeLogContext,
        aggregateResult.error,
        'HIGH',
      );
      return aggregateResult;
    }

    const aggregate = aggregateResult.value;

    // Step 6: Get domain state directly from aggregate (clean architecture)
    const domainState = aggregate.toDomainState();
    const dto = LookupXxxDtoAssembler.toDetailResponse(domainState);

    // Log operation success with comprehensive metrics
    const executionTime = this.clock.nowMs() - startTime;
    UseCaseLoggingUtil.logOperationSuccess(
      this.logger,
      operation,
      safeLogContext,
      {
        executionTimeMs: executionTime,
        aggregateVersion: aggregate.version,
        eventCount: aggregate.uncommittedEvents?.length ?? 0,
        businessData: {
          lookupXxxCode: dto.code,
          fieldsUpdated: Object.keys(fieldsToUpdate).length,
        },
      },
    );

    return ok(dto);
  }
}
