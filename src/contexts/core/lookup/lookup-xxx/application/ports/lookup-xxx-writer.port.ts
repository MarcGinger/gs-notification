// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { Result, DomainError } from 'src/shared/errors';
import { ActorContext } from 'src/shared/application/context';
import { SaveReceipt } from 'src/shared/infrastructure/repositories';
import { LookupXxxAggregate } from '../../domain/aggregates';
import { LookupXxxCode } from '../../domain/value-objects';

/**
 * Token for injecting ILookupXxxWriter port implementation
 */
export const LOOKUP_XXX_WRITER_TOKEN = 'ILookupXxxWriter' as const;

/**
 * LookupXxx Writer Port - Interface Segregation Principle Implementation
 *
 * Handles write operations (create, update, delete) for LookupXxx aggregates.
 * This interface focuses solely on data modification operations.
 *
 * ISP Benefits:
 * - Clients that only need to write data don't depend on read methods
 * - Easier to implement write-only scenarios (e.g., event sourcing)
 * - Can be secured separately from read operations
 * - Supports command-only patterns in CQRS architectures
 *
 * @domain Core Context - LookupXxx Writer Port
 * @layer Application Ports
 * @pattern Interface Segregation Principle
 */
export interface ILookupXxxWriter {
  /**
   * Save a LookupXxx aggregate (create or update)
   * @param user - The authenticated user context
   * @param lookupXxx - The LookupXxx aggregate to save
   * @param expectedVersion - Optional version for optimistic locking
   * @returns Result indicating success or domain error
   */
  save(
    actor: ActorContext,
    lookupXxx: LookupXxxAggregate,
    expectedVersion?: number,
  ): Promise<Result<SaveReceipt, DomainError>>;

  /**
   * Delete a LookupXxx by its unique identifier
   * @param user - The authenticated user context
   * @param code - The unique identifier of the LookupXxx to delete
   * @returns Result indicating success or domain error
   */
  delete(
    actor: ActorContext,
    lookupType: string,
    code: LookupXxxCode,
  ): Promise<Result<SaveReceipt, DomainError>>;
}
