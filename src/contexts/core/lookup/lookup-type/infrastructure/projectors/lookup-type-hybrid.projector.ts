// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// LookupType Projector - ESDB to PostgreSQL Projection
// Refactored to use shared projection infrastructure

import {
  Injectable,
  Inject,
  OnModuleInit,
  OnModuleDestroy,
} from '@nestjs/common';
import { DataSource, QueryRunner } from 'typeorm';
import Redis from 'ioredis';
import {
  CatchUpRunner,
  ProjectionEvent,
  RunOptions,
} from 'src/shared/infrastructure/projections/catchup.runner';
import { CheckpointStore } from 'src/shared/infrastructure/projections/checkpoint.store';
import { BaseProjector } from 'src/shared/infrastructure/projections/base.projector';
import {
  CommonProjectorErrorDefinitions,
  createProjectorErrorCatalog,
  TenantExtractor,
} from 'src/shared/infrastructure/projections/projection.utils';
// ✅ Import production-ready shared utilities
import { registerRedisScripts } from 'src/shared/infrastructure/projections/redis-scripts';
import {
  CacheOptimizationUtils,
  CacheMetricsCollector,
} from 'src/shared/infrastructure/projections/cache-optimization';
import { ProjectionOutcome } from 'src/shared/infrastructure/projections/event-pipeline-processor';
import { APP_LOGGER, Log, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import { withContext } from 'src/shared/errors';
import { CacheService } from 'src/shared/application/caching/cache.service';
import { safeParseJSON } from 'src/shared/infrastructure/repositories';
import { LOOKUP_DI_TOKENS } from '../../../lookup.constants';

import { LookupTypeProjectionKeys } from '../../lookup-type-projection-keys';
import { DetailLookupTypeResponse } from '../../application/dtos';
import { LookupTypeFieldValidatorUtil } from '../utilities/lookup-type-field-validator.util';
import {
  LookupTypeRowQueries,
  LookupTypeProjectionUpsertResult,
  LookupTypeRowMappers,
} from '../schemas/lookup-type.schema';

/**
 * LookupType projector error catalog using shared error definitions
 */
const LookupTypeProjectorErrors = createProjectorErrorCatalog(
  'LOOKUP_TYPE_PROJECTOR',
  CommonProjectorErrorDefinitions,
);

/**
 * LookupType row parameters for PostgreSQL projection operations
 *
 * Extends DetailLookupTypeResponse with projection-specific fields needed for event sourcing.
 *
 * Key Additions:
 * - tenant: Multi-tenant support for data isolation
 * - version: Optimistic concurrency control
 * - deletedAt: Soft delete timestamp for audit purposes
 * - lastStreamRevision: Event sourcing revision tracking
 */
interface LookupTypeRowParams extends DetailLookupTypeResponse {
  // Projection-specific fields for PostgreSQL storage
  tenant: string;
  version: number;
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
  lastStreamRevision?: string | null;
}

/**
 * LookupType Projector using Hybrid PostgreSQL + Redis Shared Infrastructure
 *
 * Leverages CatchUpRunner for event subscription and processing
 * Uses RedisCheckpointStore for distributed checkpoint management
 * Implements projection function pattern with production-ready optimizations
 *
 * Hybrid Architecture:
 * - PostgreSQL: Primary persistent storage with ACID transactions
 * - Redis: Version hint optimization and caching layer
 * - Shared utilities: Production-ready patterns and monitoring
 *
 * Key Features:
 * - Uses shared CatchUpRunner for subscription management
 * - Redis-based checkpoint storage for scalability
 * - Version hint deduplication using Redis SET NX EX
 * - Observable outcomes for SLO monitoring
 * - Production-ready error handling patterns
 * - Comprehensive logging and monitoring
 */
@Injectable()
export class LookupTypeProjector
  extends BaseProjector
  implements OnModuleInit, OnModuleDestroy
{
  private readonly metricsCollector = new CacheMetricsCollector();

  // ✅ Production-ready shared utilities
  private cacheOptimization!: CacheOptimizationUtils;

  // Note: Using centralized LookupTypeRowQueries.UPSERT_LOOKUP_TYPE_PROJECTION
  // for consistent SQL query definitions and better maintainability

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    @Inject(CLOCK) private readonly clock: Clock,
    @Inject(LOOKUP_DI_TOKENS.DATA_SOURCE)
    private readonly dataSource: DataSource,
    @Inject(LOOKUP_DI_TOKENS.IO_REDIS)
    private readonly redis: Redis,
    @Inject(LOOKUP_DI_TOKENS.CATCHUP_RUNNER)
    private readonly catchUpRunner: CatchUpRunner,
    @Inject(LOOKUP_DI_TOKENS.CHECKPOINT_STORE)
    checkpointStore: CheckpointStore,
    @Inject(LOOKUP_DI_TOKENS.CACHE_SERVICE)
    private readonly cache: CacheService,
  ) {
    super(
      'lookup-type-projector',
      'lookup-type-projection',
      baseLogger,
      checkpointStore,
    );

    // ✅ Initialize shared utilities for production-ready operations
    this.cacheOptimization = new CacheOptimizationUtils();

    Log.info(
      this.logger,
      'LookupTypeProjector initialized with hybrid PostgreSQL + Redis architecture',
      {
        method: 'constructor',
        subscriptionGroup: this.subscriptionGroup,
        postgresStatus: this.dataSource.isInitialized,
        redisStatus: this.redis.status,
        sharedUtilities: true,
        hybridArchitecture: true,
      },
    );
  }

  /**
   * Start the projector using CatchUpRunner
   */
  onModuleInit(): void {
    Log.info(this.logger, 'Starting LookupType Projector with CatchUpRunner', {
      method: 'onModuleInit',
      subscriptionGroup: this.subscriptionGroup,
    });

    try {
      // ✅ Register EVALSHA scripts for Redis optimization
      registerRedisScripts(this.redis);
      Log.info(this.logger, 'EVALSHA scripts registered successfully', {
        method: 'onModuleInit',
        feature: 'evalsha-optimization',
      });
      const runOptions: RunOptions = {
        prefixes: [LookupTypeProjectionKeys.getEventStoreStreamPrefix()],
        batchSize: 100,
        stopOnCaughtUp: false,
        maxRetries: 3,
        retryDelayMs: 1000,
        checkpointBatchSize: 10,
      };

      // Start the projection in the background without blocking module initialization
      this.catchUpRunner
        .runSafe(
          this.subscriptionGroup,
          this.projectEvent.bind(this) as (
            event: ProjectionEvent,
          ) => Promise<void>,
          runOptions,
        )
        .then((result) => {
          if (!result.ok) {
            this.updateHealthStatusOnError(
              result.error.detail || 'Unknown error',
            );
            Log.error(this.logger, 'Projection failed to start', {
              method: 'onModuleInit',
              error: result.error.detail || 'Unknown error',
            });
          } else {
            Log.info(this.logger, 'Projection completed successfully', {
              method: 'onModuleInit',
              status: 'completed',
            });
          }
        })
        .catch((error) => {
          const e = error as Error;
          this.updateHealthStatusOnError(e.message);
          Log.error(this.logger, 'Projection failed with exception', {
            method: 'onModuleInit',
            error: e.message,
            stack: e.stack,
          });
        });

      this.setRunning(true);
      this.updateHealthStatusOnSuccess();

      Log.info(this.logger, 'LookupType Projector started successfully', {
        method: 'onModuleInit',
        status: 'running',
      });
    } catch (error) {
      const e = error as Error;
      this.updateHealthStatusOnError(e.message);

      Log.error(this.logger, 'Failed to start LookupType Projector', {
        method: 'onModuleInit',
        error: e.message,
        stack: e.stack,
      });
      throw error;
    }
  }

  /**
   * Stop the projector using CatchUpRunner shutdown
   */
  onModuleDestroy(): void {
    Log.info(this.logger, 'Stopping LookupType Projector', {
      method: 'onModuleDestroy',
      subscriptionGroup: this.subscriptionGroup,
    });

    try {
      this.catchUpRunner.stop(this.subscriptionGroup);
      this.setRunning(false);

      Log.info(this.logger, 'LookupType Projector stopped successfully', {
        method: 'onModuleDestroy',
        status: 'stopped',
      });
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error stopping LookupType Projector', {
        method: 'onModuleDestroy',
        error: e.message,
        stack: e.stack,
      });
    }
  }

  /**
   * Project individual event using hybrid PostgreSQL + Redis architecture
   * with production-ready optimizations and observable outcomes
   */
  private async projectEvent(
    event: ProjectionEvent,
  ): Promise<ProjectionOutcome> {
    const tenant = this.extractTenant(event);

    try {
      // ✅ Extract lookup-type parameters using shared field validation
      const params = this.extractLookupTypeParams(event, 'project');

      // ✅ Apply version hint deduplication first (production-ready SET NX EX)
      const alreadyProcessed = await CacheOptimizationUtils.checkVersionHint(
        this.redis,
        tenant,
        'lookup-type',
        params.code,
        params.version,
      );

      if (alreadyProcessed) {
        this.logger.debug(
          'LookupType already processed - using version hint optimization for ' +
            params.code +
            ' version ' +
            params.version,
        );
        const outcome = ProjectionOutcome.SKIPPED_HINT;
        this.logProjectionOutcome(outcome, event, tenant);
        return outcome;
      }

      // ✅ Execute PostgreSQL transaction with shared error handling patterns
      const queryRunner = this.dataSource.createQueryRunner();
      await queryRunner.connect();
      await queryRunner.startTransaction();

      try {
        await this.applyEventToDatabase(queryRunner, event);
        await queryRunner.commitTransaction();

        // ✅ Update cache hint to prevent reprocessing (race-free SET EX)
        await CacheOptimizationUtils.updateVersionHint(
          this.redis,
          tenant,
          'lookup-type',
          params.code,
          params.version,
        );

        // Update health status
        const checkpointPosition = event.position
          ? `${event.position.commit}:${event.position.prepare}`
          : undefined;
        this.updateHealthStatusOnSuccess(checkpointPosition);

        const outcome = ProjectionOutcome.APPLIED;
        this.logProjectionOutcome(outcome, event, tenant);
        return outcome;
      } catch (error) {
        await queryRunner.rollbackTransaction();
        throw error;
      } finally {
        await queryRunner.release();
      }
    } catch (error) {
      const e = error as Error;
      this.updateHealthStatusOnError(e.message);

      Log.error(
        this.logger,
        'Failed to project event with hybrid architecture',
        {
          method: 'projectEvent',
          eventType: event.type,
          streamId: event.streamId,
          revision: event.revision,
          tenant,
          error: e.message,
          stack: e.stack,
        },
      );

      throw new Error(
        withContext(LookupTypeProjectorErrors.DATABASE_OPERATION_FAILED, {
          eventType: event.type,
          streamId: event.streamId,
          originalError: e.message,
        }).detail,
        { cause: e },
      );
    }
  }

  /**
   * Log projection outcomes for SLO monitoring and incident analysis
   */
  private logProjectionOutcome(
    outcome: ProjectionOutcome,
    event: ProjectionEvent,
    tenant: string,
  ): void {
    const outcomeLabels = {
      [ProjectionOutcome.APPLIED]: 'applied',
      [ProjectionOutcome.STALE_OCC]: 'stale_occ',
      [ProjectionOutcome.SKIPPED_DEDUP]: 'skipped_dedup',
      [ProjectionOutcome.SKIPPED_HINT]: 'skipped_hint',
      [ProjectionOutcome.UNKNOWN]: 'unknown',
    };

    const outcomeLabel = outcomeLabels[outcome] || 'unknown';
    const level = outcome === ProjectionOutcome.APPLIED ? 'debug' : 'info';

    Log[level](this.logger, 'Event projection outcome: ' + outcomeLabel, {
      method: 'logProjectionOutcome',
      outcome,
      outcomeLabel,
      eventType: event.type,
      streamId: event.streamId,
      revision: event.revision,
      tenant,
      metrics: this.metricsCollector.getMetrics(),
    });
  }

  /**
   * Extract tenant ID from event using shared utility
   */
  private extractTenant(event: ProjectionEvent): string {
    return TenantExtractor.extractTenant(event);
  }

  /**
   * Apply event to database using existing event mapping logic
   */
  private async applyEventToDatabase(
    queryRunner: QueryRunner,
    event: ProjectionEvent,
  ): Promise<void> {
    switch (event.type) {
      case 'CoreLookupLookupTypeCreated.v1':
        return this.handleLookupTypeCreated(queryRunner, event);
      case 'CoreLookupLookupTypeUpdated.v1':
        return this.handleLookupTypeUpdated(queryRunner, event);
      case 'CoreLookupLookupTypeDeleted.v1':
        return this.handleLookupTypeDeleted(queryRunner, event);
      default:
        Log.warn(this.logger, 'Unknown event type in projection', {
          method: 'applyEventToDatabase',
          eventType: event.type,
          streamId: event.streamId,
        });
        // Don't fail on unknown events - allows for forward compatibility
        return;
    }
  }

  /**
   * Generic handler for all lookupType events with operation-specific customization
   */
  private async handleLookupTypeEvent(
    queryRunner: QueryRunner,
    event: ProjectionEvent,
    operation: string,
    customizer?: (params: LookupTypeRowParams) => void,
  ): Promise<void> {
    try {
      const params = this.extractLookupTypeParams(event, operation);

      // Apply operation-specific customizations
      if (customizer) {
        customizer(params);
      }

      const result = (await queryRunner.query(
        LookupTypeRowQueries.UPSERT_LOOKUP_TYPE_PROJECTION,
        [
          params.lookupType,
          params.code,
          params.name,
          params.description,
          params.enabled,
          params.attributes,
          params.tenant,
          params.version,
          params.createdAt,
          params.updatedAt,
          params.deletedAt,
          params.lastStreamRevision,
        ],
      )) as LookupTypeProjectionUpsertResult[];

      // Log successful operation using centralized mapper
      if (result.length > 0) {
        const mappedResult = LookupTypeRowMappers.mapToProjectionUpsertResult(
          result[0],
        );
        Log.debug(this.logger, `${operation} event projected successfully`, {
          method: 'handleLookupTypeEvent',
          operation,
          eventType: event.type,
          streamId: event.streamId,
          code: mappedResult.code,
          version: mappedResult.version,
        });
      }
    } catch (error) {
      const e = error as Error;
      throw new Error(
        withContext(LookupTypeProjectorErrors.DATABASE_OPERATION_FAILED, {
          operation,
          eventType: event.type,
          streamId: event.streamId,
          originalError: e.message,
        }).detail,
      );
    }
  }

  /**
   * Handle LookupTypeCreated event
   */
  private async handleLookupTypeCreated(
    queryRunner: QueryRunner,
    event: ProjectionEvent,
  ): Promise<void> {
    return this.handleLookupTypeEvent(
      queryRunner,
      event,
      'handleLookupTypeCreated',
    );
  }

  /**
   * Handle LookupTypeUpdated event
   */
  private async handleLookupTypeUpdated(
    queryRunner: QueryRunner,
    event: ProjectionEvent,
  ): Promise<void> {
    return this.handleLookupTypeEvent(
      queryRunner,
      event,
      'handleLookupTypeUpdated',
    );
  }

  /**
   * Handle LookupTypeDeleted event
   */
  private async handleLookupTypeDeleted(
    queryRunner: QueryRunner,
    event: ProjectionEvent,
  ): Promise<void> {
    return this.handleLookupTypeEvent(
      queryRunner,
      event,
      'handleLookupTypeDeleted',
      (params) => {
        params.deletedAt = this.clock.now(); // Mark as deleted
      },
    );
  }

  /**
   * Extract lookupType parameters from event data using LookupTypeFieldValidatorUtil
   *
   * Uses LookupTypeFieldValidatorUtil to create validated LookupTypeSnapshotProps for consistent
   * validation across repository and projector, and TenantExtractor for reliable tenant identification.
   */
  private extractLookupTypeParams(
    event: ProjectionEvent,
    operation: string,
  ): LookupTypeRowParams {
    try {
      const eventData = event.data as Record<string, any>;

      // Extract tenant using shared utility
      const tenant = TenantExtractor.extractTenant(event);

      // Use LookupTypeFieldValidatorUtil to create validated Lookup type snapshot
      const lookupTypeProjectorData =
        LookupTypeFieldValidatorUtil.createLookupTypeProjectorDataFromEventData(
          eventData,
        );

      // Parse JSON string back to object for attributes field using safe parser
      const attributes = safeParseJSON<Record<string, unknown>>(
        lookupTypeProjectorData.attributes,
        'attributes',
      );

      const now = this.clock.now();

      // Add projector-specific fields for sql storage
      return {
        ...lookupTypeProjectorData,
        attributes,
        tenant,
        version:
          typeof eventData.version === 'number'
            ? eventData.version
            : event.revision,
        createdAt: operation === 'handleCreated' ? now : now,
        updatedAt: now,
        deletedAt: null,
        lastStreamRevision: event.revision.toString(),
      };
    } catch (error) {
      const e = error as Error;
      throw new Error(
        withContext(LookupTypeProjectorErrors.INVALID_EVENT_DATA, {
          eventType: event.type,
          streamId: event.streamId,
          operation,
          originalError: e.message,
        }).detail,
      );
    }
  }
}
