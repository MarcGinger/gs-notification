// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// LookupType Projector - ESDB to PostgreSQL Projection (SQL-Only)
// Optimized for moderate traffic and configuration domains with simplified architecture

import {
  Injectable,
  Inject,
  OnModuleInit,
  OnModuleDestroy,
} from '@nestjs/common';
import { DataSource, QueryRunner } from 'typeorm';
import {
  CatchUpRunner,
  ProjectionEvent,
  RunOptions,
} from 'src/shared/infrastructure/projections/catchup.runner';
import { PostgreSQLCheckpointStore } from 'src/shared/infrastructure/projections/postgresql-checkpoint.store';
import { BaseProjector } from 'src/shared/infrastructure/projections/base.projector';
import {
  CommonProjectorErrorDefinitions,
  createProjectorErrorCatalog,
  TenantExtractor,
} from 'src/shared/infrastructure/projections/projection.utils';
import { APP_LOGGER, Log, Logger } from 'src/shared/logging';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import { withContext } from 'src/shared/errors';
import { safeParseJSON } from 'src/shared/infrastructure/repositories';
import { LOOKUP_DI_TOKENS } from '../../../lookup.constants';
import { LookupTypeProjectionKeys } from '../../lookup-type-projection-keys';
import { DetailLookupTypeResponse } from '../../application/dtos';
import { LookupTypeFieldValidatorUtil } from '../utilities/lookup-type-field-validator.util';
import {
  LookupTypeRowQueries,
  LookupTypeProjectionUpsertResult,
  LookupTypeRowMappers,
} from '../schemas/lookup-type.schema';

/**
 * LookupType projector error catalog using shared error definitions
 */
const LookupTypeProjectorErrors = createProjectorErrorCatalog(
  'LOOKUP_TYPE_PROJECTOR',
  CommonProjectorErrorDefinitions,
);

/**
 * LookupType row parameters for PostgreSQL projection operations
 *
 * Extends DetailLookupTypeResponse with projection-specific fields needed for event sourcing.
 *
 * Key Additions:
 * - tenant: Multi-tenant support for data isolation
 * - version: Optimistic concurrency control via SQL
 * - deletedAt: Soft delete timestamp for audit purposes
 * - lastStreamRevision: Event sourcing revision tracking
 */
interface LookupTypeRowParams extends DetailLookupTypeResponse {
  // Projection-specific fields for PostgreSQL storage
  tenant: string;
  version: number;
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date | null;
  lastStreamRevision?: string | null;
}

/**
 * LookupType Projector using SQL-Only Architecture
 *
 * Optimized for moderate traffic scenarios (tens of events/sec or less)
 * and configuration-style domains where simplicity is preferred over
 * maximum performance optimization.
 *
 * SQL-Only Benefits:
 * - Lower operational complexity (single datastore)
 * - Fewer failure modes (no cache outages/evictions)
 * - Strong idempotency with UPSERT + version column
 * - Acceptable replay performance within SLOs
 * - Simpler debugging and monitoring
 *
 * PostgreSQL Features:
 * - ACID transactions for data consistency
 * - Optimistic concurrency control via version column
 * - Efficient UPSERT with ON CONFLICT handling
 * - JSONB support for complex domain objects
 * - Built-in indexing and query optimization
 *
 * Key Features:
 * - Uses shared CatchUpRunner for subscription management
 * - PostgreSQL-based checkpoint storage for reliability
 * - Shared field validation utilities for consistency
 * - Production-ready error handling patterns
 * - Comprehensive logging and monitoring
 */
@Injectable()
export class LookupTypeProjector
  extends BaseProjector
  implements OnModuleInit, OnModuleDestroy
{
  // Note: Using centralized LookupTypeRowQueries.UPSERT_LOOKUP_TYPE_PROJECTION
  // for consistent SQL query definitions and better maintainability

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    @Inject(CLOCK) private readonly clock: Clock,
    @Inject(LOOKUP_DI_TOKENS.CATCHUP_RUNNER)
    private readonly catchUpRunner: CatchUpRunner,
    @Inject(LOOKUP_DI_TOKENS.DATA_SOURCE)
    private readonly dataSource: DataSource,
  ) {
    // Create PostgreSQL checkpoint store for SQL-only architecture
    const checkpointStore = new PostgreSQLCheckpointStore(
      dataSource,
      baseLogger,
      'sql-only:', // Environment prefix for isolation
    );

    super(
      'lookup-type-projector-sql-only',
      'lookup-type-projection-sql-only',
      baseLogger,
      checkpointStore,
    );

    Log.info(
      this.logger,
      'LookupTypeProjector initialized with simplified SQL-only architecture',
      {
        method: 'constructor',
        subscriptionGroup: this.subscriptionGroup,
        postgresStatus: this.dataSource.isInitialized,
        architecture: 'sql-only',
        benefits: [
          'lower-operational-complexity',
          'fewer-failure-modes',
          'strong-idempotency',
          'acceptable-replay-performance',
        ],
      },
    );
  }

  /**
   * Start the projector using CatchUpRunner
   */
  onModuleInit(): void {
    Log.info(
      this.logger,
      'Starting LookupType Projector (SQL-Only) with CatchUpRunner',
      {
        method: 'onModuleInit',
        subscriptionGroup: this.subscriptionGroup,
        architecture: 'sql-only',
      },
    );

    try {
      const runOptions: RunOptions = {
        prefixes: [LookupTypeProjectionKeys.getEventStoreStreamPrefix()],
        batchSize: 100,
        stopOnCaughtUp: false,
        maxRetries: 3,
        retryDelayMs: 1000,
        checkpointBatchSize: 10,
      };

      // Start the projection in the background without blocking module initialization
      this.catchUpRunner
        .runSafe(
          this.subscriptionGroup,
          this.projectEvent.bind(this) as (
            event: ProjectionEvent,
          ) => Promise<void>,
          runOptions,
        )
        .then((result) => {
          if (!result.ok) {
            this.updateHealthStatusOnError(
              result.error.detail || 'Unknown error',
            );
            Log.error(this.logger, 'Projection failed to start', {
              method: 'onModuleInit',
              error: result.error.detail || 'Unknown error',
            });
          } else {
            Log.info(this.logger, 'Projection completed successfully', {
              method: 'onModuleInit',
              status: 'completed',
            });
          }
        })
        .catch((error) => {
          const e = error as Error;
          this.updateHealthStatusOnError(e.message);
          Log.error(this.logger, 'Projection failed with exception', {
            method: 'onModuleInit',
            error: e.message,
            stack: e.stack,
          });
        });

      this.setRunning(true);
      this.updateHealthStatusOnSuccess();

      Log.info(
        this.logger,
        'LookupType Projector (SQL-Only) started successfully',
        {
          method: 'onModuleInit',
          status: 'running',
        },
      );
    } catch (error) {
      const e = error as Error;
      this.updateHealthStatusOnError(e.message);

      Log.error(
        this.logger,
        'Failed to start LookupType Projector (SQL-Only)',
        {
          method: 'onModuleInit',
          error: e.message,
          stack: e.stack,
        },
      );
      throw error;
    }
  }

  /**
   * Stop the projector using CatchUpRunner shutdown
   */
  onModuleDestroy(): void {
    Log.info(this.logger, 'Stopping LookupType Projector (SQL-Only)', {
      method: 'onModuleDestroy',
      subscriptionGroup: this.subscriptionGroup,
    });

    try {
      this.catchUpRunner.stop(this.subscriptionGroup);
      this.setRunning(false);

      Log.info(this.logger, 'LookupType Projector stopped successfully', {
        method: 'onModuleDestroy',
        status: 'stopped',
      });
    } catch (error) {
      const e = error as Error;
      Log.error(this.logger, 'Error stopping LookupType Projector (SQL-Only)', {
        method: 'onModuleDestroy',
        error: e.message,
        stack: e.stack,
      });
    }
  }

  /**
   * Project individual event using SQL-only architecture
   * with ACID transactions and version-based concurrency control
   */
  private async projectEvent(event: ProjectionEvent): Promise<void> {
    const tenant = this.extractTenant(event);

    try {
      // Extract lookup-type parameters using shared field validation
      const params = this.extractLookupTypeParams(event, 'project');

      // Execute PostgreSQL transaction with optimistic concurrency control
      const queryRunner = this.dataSource.createQueryRunner();
      await queryRunner.connect();
      await queryRunner.startTransaction();

      try {
        const result = await this.applyEventToDatabase(
          queryRunner,
          event,
          params,
        );
        await queryRunner.commitTransaction();

        // Log successful projection with version info
        if (result && result.length > 0) {
          Log.debug(
            this.logger,
            'Event projected successfully with version check',
            {
              method: 'projectEvent',
              eventType: event.type,
              streamId: event.streamId,
              revision: event.revision,
              tenant,
              code: result[0].code,
              version: result[0].version,
              outcome: 'applied',
            },
          );
        } else {
          Log.debug(this.logger, 'Event skipped due to stale version', {
            method: 'projectEvent',
            eventType: event.type,
            streamId: event.streamId,
            revision: event.revision,
            tenant,
            outcome: 'skipped-stale-version',
          });
        }

        // Update health status
        const checkpointPosition = event.position
          ? `${event.position.commit}:${event.position.prepare}`
          : undefined;
        this.updateHealthStatusOnSuccess(checkpointPosition);
      } catch (error) {
        await queryRunner.rollbackTransaction();
        throw error;
      } finally {
        await queryRunner.release();
      }
    } catch (error) {
      const e = error as Error;
      this.updateHealthStatusOnError(e.message);

      Log.error(
        this.logger,
        'Failed to project event with SQL-only architecture',
        {
          method: 'projectEvent',
          eventType: event.type,
          streamId: event.streamId,
          revision: event.revision,
          tenant,
          error: e.message,
          stack: e.stack,
        },
      );

      throw new Error(
        withContext(LookupTypeProjectorErrors.DATABASE_OPERATION_FAILED, {
          eventType: event.type,
          streamId: event.streamId,
          originalError: e.message,
        }).detail,
        { cause: e },
      );
    }
  }

  /**
   * Extract tenant ID from event using shared utility
   */
  private extractTenant(event: ProjectionEvent): string {
    return TenantExtractor.extractTenant(event);
  }

  /**
   * Apply event to database using SQL UPSERT with version-based concurrency control
   */
  private async applyEventToDatabase(
    queryRunner: QueryRunner,
    event: ProjectionEvent,
    params: LookupTypeRowParams,
  ): Promise<{ code: string; version: number }[]> {
    switch (event.type) {
      case 'CoreLookupLookupTypeCreated.v1':
        return this.handleLookupTypeCreated(queryRunner, params);
      case 'CoreLookupLookupTypeUpdated.v1':
        return this.handleLookupTypeUpdated(queryRunner, params);
      case 'CoreLookupLookupTypeDeleted.v1':
        return this.handleLookupTypeDeleted(queryRunner, params);
      default:
        Log.warn(this.logger, 'Unknown event type in projection', {
          method: 'applyEventToDatabase',
          eventType: event.type,
          streamId: event.streamId,
        });
        // Don't fail on unknown events - allows for forward compatibility
        return [];
    }
  }

  /**
   * Handle LookupTypeCreated event
   */
  private async handleLookupTypeCreated(
    queryRunner: QueryRunner,
    params: LookupTypeRowParams,
  ): Promise<{ code: string; version: number }[]> {
    return this.executeUpsert(queryRunner, params);
  }

  /**
   * Handle LookupTypeUpdated event
   */
  private async handleLookupTypeUpdated(
    queryRunner: QueryRunner,
    params: LookupTypeRowParams,
  ): Promise<{ code: string; version: number }[]> {
    return this.executeUpsert(queryRunner, params);
  }

  /**
   * Handle LookupTypeDeleted event
   */
  private async handleLookupTypeDeleted(
    queryRunner: QueryRunner,
    params: LookupTypeRowParams,
  ): Promise<{ code: string; version: number }[]> {
    // Mark as deleted with current timestamp
    const deletedParams = {
      ...params,
      deletedAt: this.clock.now(),
    };
    return this.executeUpsert(queryRunner, deletedParams);
  }

  /**
   * Execute SQL UPSERT with optimistic concurrency control using centralized queries
   * Returns affected rows for logging and monitoring
   */
  private async executeUpsert(
    queryRunner: QueryRunner,
    params: LookupTypeRowParams,
  ): Promise<{ code: string; version: number }[]> {
    try {
      const result = (await queryRunner.query(
        LookupTypeRowQueries.UPSERT_LOOKUP_TYPE_PROJECTION,
        [
          params.lookupType,
          params.code,
          params.name,
          params.description,
          params.enabled,
          params.attributes,
          params.tenant,
          params.version,
          params.createdAt,
          params.updatedAt,
          params.deletedAt,
          params.lastStreamRevision,
        ],
      )) as LookupTypeProjectionUpsertResult[];

      // Use centralized mapper for consistent result handling
      return result.map((row) =>
        LookupTypeRowMappers.mapToProjectionUpsertResult(row),
      );
    } catch (error) {
      const e = error as Error;
      throw new Error(
        withContext(LookupTypeProjectorErrors.DATABASE_OPERATION_FAILED, {
          operation: 'executeUpsert',
          code: params.code,
          version: params.version,
          originalError: e.message,
        }).detail,
      );
    }
  }

  /**
   * Extract lookupType parameters from event data using LookupTypeFieldValidatorUtil
   *
   * Uses LookupTypeFieldValidatorUtil to create validated LookupTypeSnapshotProps for consistent
   * validation across repository and projector, and TenantExtractor for reliable tenant identification.
   */
  private extractLookupTypeParams(
    event: ProjectionEvent,
    operation: string,
  ): LookupTypeRowParams {
    try {
      const eventData = event.data as Record<string, any>;

      // Extract tenant using shared utility
      const tenant = TenantExtractor.extractTenant(event);

      // Use LookupTypeFieldValidatorUtil to create validated lookupType snapshot
      const lookupTypeProjectorData =
        LookupTypeFieldValidatorUtil.createLookupTypeProjectorDataFromEventData(
          eventData,
        );

      // Parse JSON string back to object for attributes field using safe parser
      const attributes = safeParseJSON<Record<string, unknown>>(
        lookupTypeProjectorData.attributes,
        'attributes',
      );

      // Add projector-specific fields for SQL storage
      return {
        ...lookupTypeProjectorData,
        attributes,
        tenant,
        deletedAt: null, // Projector handles soft deletes
        lastStreamRevision: event.revision.toString(),
      };
    } catch (error) {
      const e = error as Error;
      throw new Error(
        withContext(LookupTypeProjectorErrors.INVALID_EVENT_DATA, {
          eventType: event.type,
          streamId: event.streamId,
          operation,
          originalError: e.message,
        }).detail,
      );
    }
  }
}
