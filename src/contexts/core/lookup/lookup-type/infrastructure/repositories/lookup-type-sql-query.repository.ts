// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { Injectable, Inject } from '@nestjs/common';
import { DataSource } from 'typeorm';
import { APP_LOGGER, Log, componentLogger, Logger } from 'src/shared/logging';
import { CorrelationUtil } from 'src/shared/utilities/correlation.util';
import { Clock, CLOCK } from 'src/shared/infrastructure/time';
import {
  RepositoryLoggingUtil,
  RepositoryLoggingConfig,
  RepositoryExecutionUtil,
  safeParseJSON,
  handleRepositoryError,
  RepositoryOptions,
} from 'src/shared/infrastructure/repositories';
import { Result, DomainError, err, ok } from 'src/shared/errors';
import { ActorContext } from 'src/shared/application/context';
import { RepositoryErrorFactory } from 'src/shared/domain/errors/repository.error';
import { Option } from 'src/shared/domain/types';
import { LOOKUP_DI_TOKENS } from '../../../lookup.constants';
import {
  DetailLookupTypeResponse,
  LookupTypePageResponse,
  ListLookupTypeFilterRequest,
  ListLookupTypeResponse,
} from '../../application/dtos';
import { PaginationMetaResponse } from 'src/shared/application/dtos';
import { ILookupTypeQuery } from '../../application/ports';
import {
  LookupTypeRow,
  LookupTypeRowQueries,
} from '../schemas/lookup-type.schema';

/**
 * LookupType Query Repository - Interface Segregation Principle Implementation
 *
 * Bounded Context: Core/LookupType
 * Handles complex query operations including pagination, filtering, and search.
 * This repository focuses solely on advanced data retrieval operations using PostgreSQL.
 *
 * ISP Benefits:
 * - Clients that need simple reads don't depend on complex query methods
 * - Can be optimized independently (e.g., using read replicas)
 * - Easier to implement caching strategies for query operations
 * - Supports analytical and reporting use cases
 *
 * PostgreSQL Features Used:
 * - Advanced filtering with type-safe query builders
 * - JSON column querying for complex configuration data
 * - Efficient pagination with LIMIT/OFFSET
 * - Full-text search capabilities
 * - Tenant isolation with row-level security support
 *
 * @domain Core Context - LookupType Query Repository
 * @layer Infrastructure
 * @pattern Repository Pattern + Interface Segregation Principle
 */
@Injectable()
export class LookupTypeQueryRepository implements ILookupTypeQuery {
  private readonly logger: Logger;
  private readonly loggingConfig: RepositoryLoggingConfig;

  constructor(
    @Inject(APP_LOGGER) baseLogger: Logger,
    @Inject(CLOCK) private readonly clock: Clock,
    @Inject(LOOKUP_DI_TOKENS.DATA_SOURCE)
    private readonly dataSource: DataSource,
  ) {
    this.loggingConfig = {
      serviceName: 'LookupTypeConfigService',
      component: 'LookupTypeQueryRepository',
    };
    this.logger = componentLogger(baseLogger, this.loggingConfig.component);
  }
  async findById(
    actor: ActorContext,
    lookupType: string,
    code: string,
    options?: RepositoryOptions,
  ): Promise<Result<Option<DetailLookupTypeResponse>, DomainError>> {
    const operation = 'findById';
    const correlationId =
      options?.correlationId ??
      CorrelationUtil.generateForOperation('lookup-type-query-findById');

    const logContext = this.createLogContext(operation, correlationId, actor, {
      lookupTypeCode: code,
    });

    // Validate actor context with enhanced security logging
    const validation = RepositoryLoggingUtil.validateActorContext(
      this.logger,
      actor,
      logContext,
    );
    if (!validation.ok) return err(validation.error);

    // Guard tenant explicitly
    if (!actor.tenant) {
      return err(
        RepositoryErrorFactory.validationError('tenant', 'Missing tenant id'),
      );
    }

    // Log successful authorization
    RepositoryLoggingUtil.logAuthorizationSuccess(
      this.logger,
      operation,
      logContext,
      {
        operationType: 'lookup-type_query_findById',
        scope: 'single_lookup-type_lookup',
        tenant: actor.tenant,
      },
    );

    try {
      // Use centralized query from schema for consistency
      const query = LookupTypeRowQueries.FIND_LOOKUP_TYPE_BY_CODE;
      const parameters = [actor.tenant, code];

      Log.debug(this.logger, 'Executing lookup-type findById query', {
        ...logContext,
        sql: query,
        parameters: parameters.map((p, i) => `$${i + 1}: ${String(p)}`),
      });

      // Execute query with optional timeout
      const queryPromise = this.dataSource.query(query, parameters);
      const results = (await RepositoryExecutionUtil.executeWithTimeout(
        queryPromise,
        options?.timeout,
        'LookupType findById query timeout',
      )) as LookupTypeRow[];

      if (results.length === 0) {
        Log.debug(this.logger, 'LookupType not found', logContext);
        return ok(Option.none());
      }

      const lookupType = results[0];

      // Transform to DetailLookupTypeResponse DTO
      const detailResponse = this.toDetailResponse(lookupType);

      Log.debug(this.logger, 'LookupType found successfully', {
        ...logContext,
        resultData: {
          lookupTypeCode: detailResponse.code,
          lookupTypeName: detailResponse.name,
        },
      });

      return ok(Option.some(detailResponse));
    } catch (error) {
      // Log operation error using shared utility
      RepositoryLoggingUtil.logOperationError(
        this.logger,
        operation,
        logContext,
        error as Error,
        'MEDIUM',
      );

      // Handle and return the classified error using shared utility
      return handleRepositoryError(error);
    }
  }

  /**
   * Helper to create consistent logging context using shared utilities
   */
  private createLogContext(
    operation: string,
    correlationId: string,
    actor: ActorContext,
    additionalContext?: Record<string, unknown>,
  ): Record<string, unknown> {
    return RepositoryLoggingUtil.createLogContext(
      this.loggingConfig,
      this.clock,
      operation,
      correlationId,
      actor,
      additionalContext,
    );
  }

  /**
   * Find LookupType records with pagination and filtering using raw SQL.
   *
   * Leverages the proven schema and patterns from LookupTypeReaderRepository
   * with type-safe SQL queries and proper JSONB field handling.
   *
   * Features:
   * - Type-safe filtering by code and name using actual database schema
   * - Multi-field sorting with configurable directions
   * - Efficient pagination with total count
   * - Tenant isolation
   * - Comprehensive logging and error handling
   * - Proper JSONB field parsing with safeParseJSON utility
   *
   * @param actor - The actor context containing authentication and request metadata.
   * @param filter - Optional filter criteria for the lookup-type search.
   * @param options - Optional repository options (e.g., pagination, sorting).
   * @returns A promise resolving to a Result containing paginated LookupType responses or a DomainError.
   */
  async findPaginated(
    actor: ActorContext,
    lookupType: string,
    filter?: ListLookupTypeFilterRequest,
    options?: RepositoryOptions,
  ): Promise<Result<LookupTypePageResponse, DomainError>> {
    const operation = 'findPaginated';
    const correlationId =
      options?.correlationId ??
      CorrelationUtil.generateForOperation('lookup-type-query-paginated');

    const logContext = this.createLogContext(operation, correlationId, actor, {
      filterName: filter?.name,
      filterCode: filter?.code,
      page: filter?.page,
      size: filter?.size,
      sortBy: filter?.getSortByRecord?.() || {},
    });

    // Validate actor context with enhanced security logging
    const validation = RepositoryLoggingUtil.validateActorContext(
      this.logger,
      actor,
      logContext,
    );
    if (!validation.ok) return err(validation.error);

    // Guard tenant explicitly
    if (!actor.tenant) {
      return err(
        RepositoryErrorFactory.validationError('tenant', 'Missing tenant id'),
      );
    }

    // Log successful authorization
    RepositoryLoggingUtil.logAuthorizationSuccess(
      this.logger,
      operation,
      logContext,
      {
        operationType: 'lookup-type_query_paginated',
        scope: 'paginated_search',
        tenant: actor.tenant,
      },
    );

    try {
      // Build dynamic WHERE conditions and parameters
      const whereConditions = ['tenant_id = $1'];
      const parameters: unknown[] = [actor.tenant];
      let paramCount = 1;
      // Add name filter
      if (filter?.name) {
        paramCount++;
        if (filter.name.includes('%') || filter.name.includes('*')) {
          // Wildcard search
          const pattern = filter.name.replace(/\*/g, '%');
          whereConditions.push(`name ILIKE $${paramCount}`);
          parameters.push(pattern);
        } else {
          // Exact match
          whereConditions.push(`name = $${paramCount}`);
          parameters.push(filter.name);
        }
      }

      // Add code filter
      if (filter?.code) {
        paramCount++;
        if (filter.code.includes('%') || filter.code.includes('*')) {
          // Wildcard search
          const pattern = filter.code.replace(/\*/g, '%');
          whereConditions.push(`code ILIKE $${paramCount}`);
          parameters.push(pattern);
        } else {
          // Exact match
          whereConditions.push(`code = $${paramCount}`);
          parameters.push(filter.code);
        }
      }

      // Build ORDER BY clause
      const orderBy = this.buildOrderByClause(filter?.getSortByRecord?.());

      // Build pagination
      const page = filter?.page ?? 1;
      const size = Math.min(filter?.size ?? 20, 100); // Cap at 100 items per page
      const offset = (page - 1) * size;

      // First, get total count for pagination metadata using centralized schema query
      const countQuery =
        LookupTypeRowQueries.COUNT_LOOKUP_TYPES_BASE +
        ' WHERE ' +
        whereConditions.join(' AND ');

      Log.debug(this.logger, 'Executing lookup-type count query', {
        ...logContext,
        sql: countQuery,
        parameters,
      });

      const countResult: unknown =
        await RepositoryExecutionUtil.executeWithTimeout(
          this.dataSource.query(countQuery, parameters),
          options?.timeout,
          'Simple count query timeout',
        );
      // Raw SQL COUNT query returns numeric string in total field - handle any type safely
      const isValidCountResult = (
        result: unknown,
      ): result is [{ total: string }] =>
        Array.isArray(result) &&
        result.length > 0 &&
        typeof result[0] === 'object' &&
        result[0] !== null &&
        'total' in result[0];

      const totalItems = parseInt(
        isValidCountResult(countResult) ? countResult[0].total : '0',
        10,
      );

      // Then get the actual data using centralized schema query with consistent column list
      const dataQuery =
        LookupTypeRowQueries.FIND_LOOKUP_TYPES_PAGINATED_BASE +
        ' WHERE ' +
        whereConditions.join(' AND ') +
        ' ' +
        orderBy +
        ` LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}`;

      parameters.push(size, offset);

      Log.debug(this.logger, 'Executing paginated lookup-type query', {
        ...logContext,
        sql: dataQuery,
        parameters: parameters.map((p, i) => `$${i + 1}: ${String(p)}`),
        totalItems,
        page,
        size,
        offset,
      });

      // Execute query with optional timeout
      const queryPromise = this.dataSource.query(dataQuery, parameters);
      const lookupTypes = (await RepositoryExecutionUtil.executeWithTimeout(
        queryPromise,
        options?.timeout,
        'LookupType data query timeout',
      )) as LookupTypeRow[];

      // Transform to DTOs
      const lookupTypeResponses = lookupTypes.map((lookupType) =>
        this.toListResponse(lookupType),
      );

      // Create pagination metadata
      const totalPages = Math.ceil(totalItems / size);
      const hasNextPage = page < totalPages;
      const hasPreviousPage = page > 1;

      const meta = new PaginationMetaResponse({
        page,
        size,
        totalItems,
        totalPages,
        hasNextPage,
        hasPreviousPage,
      });

      const response = LookupTypePageResponse.create(lookupTypeResponses, meta);

      // Log successful query metrics
      RepositoryLoggingUtil.logQueryMetrics(
        this.logger,
        operation,
        logContext,
        {
          resultCount: lookupTypes.length,
          dataQuality: lookupTypes.length > 0 ? 'good' : 'empty',
          sampleData: {
            totalItems,
            page,
            size,
            hasFilters: !!(filter?.name || filter?.code),
            sortFields: Object.keys(filter?.getSortByRecord?.() ?? {}),
          },
        },
      );

      return ok(response);
    } catch (error) {
      // Log operation error using shared utility
      RepositoryLoggingUtil.logOperationError(
        this.logger,
        operation,
        logContext,
        error as Error,
        'HIGH',
      );

      // Handle and return the classified error using shared utility
      return handleRepositoryError(error);
    }
  }

  /**
   * Build ORDER BY clause for SQL query based on sort criteria
   */
  private buildOrderByClause(sortBy?: Record<string, string>): string {
    const defaultSort = { code: 'asc', name: 'asc' };
    const actualSort = sortBy ?? defaultSort;

    const orderClauses: string[] = [];

    for (const [field, direction] of Object.entries(actualSort)) {
      const column = this.getSortableColumn(field);
      if (column) {
        const sortDirection =
          direction?.toLowerCase() === 'desc' ? 'DESC' : 'ASC';
        orderClauses.push(`${column} ${sortDirection}`);
      }
    }

    // Always add code as final sort for consistent pagination if not already included
    if (!actualSort.code && !('id' in actualSort)) {
      orderClauses.push('code ASC');
    }

    return orderClauses.length > 0 ? `ORDER BY ${orderClauses.join(', ')}` : '';
  }

  /**
   * Map filter field names to actual database column names
   */
  private getSortableColumn(field: string): string | null {
    const columnMap: Record<string, string> = {
      createdAt: 'created_at',
      updatedAt: 'updated_at',
      name: 'name',
      code: 'code',
    };

    return columnMap[field] || null;
  }
  /**
   * Transform LookupTypeRow to DetailLookupTypeResponse DTO
   * Uses the same parsing logic as toListResponse but returns DetailLookupTypeResponse
   */
  private toDetailResponse(
    lookupType: LookupTypeRow,
  ): DetailLookupTypeResponse {
    // Parse complex JSONB objects - let undefined values be undefined (no fake defaults)
    const attributes = safeParseJSON<Record<string, unknown>>(
      lookupType.attributes,
      'attributes',
    );

    // Create DetailLookupTypeResponse with explicit field mapping
    const response: DetailLookupTypeResponse = {
      lookupType: lookupType.lookup_type,
      code: lookupType.code,
      name: lookupType.name,
      description: lookupType.description ?? undefined,
      enabled: lookupType.enabled ?? undefined,
      attributes,
    };

    return response;
  }

  /**
   * Transform LookupTypeRow to ListLookupTypeResponse DTO
   * Uses the proven transformation patterns from LookupTypeReaderRepository
   * with proper JSONB field parsing and type-safe conversion
   */
  private toListResponse(lookupType: LookupTypeRow): ListLookupTypeResponse {
    // Parse JSON arrays using specialized utility with type validation
    // Parse complex JSONB objects - let undefined values be undefined (no fake defaults)
    const attributes = safeParseJSON<Record<string, unknown>>(
      lookupType.attributes,
      'attributes',
    );

    // Create properly structured response with explicit field mapping
    // All undefined values are passed through - no fake defaults
    const response: ListLookupTypeResponse = {
      lookupType: lookupType.lookup_type,
      code: lookupType.code,
      name: lookupType.name,
      description: lookupType.description ?? undefined,
      enabled: lookupType.enabled ?? undefined,
      attributes,
    };

    return response;
  }
}
