// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

// Lookup Projector Health Controller
// Provides health check endpoints for the Lookup Projector

import { Controller, Get, Inject } from '@nestjs/common';
import { APP_LOGGER, Log, componentLogger, Logger } from 'src/shared/logging';
import { LookupProjector } from '../../../infrastructure/projectors';
import { LookupProjectionKeys } from '../../../lookup-projection-keys';

@Controller('health/projectors')
export class LookupProjectorHealthController {
  private readonly logger: Logger;

  constructor(
    private readonly lookupProjector: LookupProjector,
    @Inject(APP_LOGGER) baseLogger: Logger,
  ) {
    this.logger = componentLogger(
      baseLogger,
      'LookupProjectorHealthController',
    );
  }

  @Get('lookup')
  async getLookupProjectorHealth() {
    try {
      const health = this.lookupProjector.getHealthStatus();
      const checkpoint = await this.lookupProjector.getCurrentCheckpoint();

      Log.debug(this.logger, 'Lookup projector health check', {
        isHealthy: health.isHealthy,
        isRunning: health.isRunning,
        projectorName: health.projectorName,
        hasCheckpoint: !!checkpoint,
      });

      return {
        isHealthy: health.isHealthy,
        isRunning: health.isRunning,
        projectorName: health.projectorName,
        subscriptionGroup: health.subscriptionGroup,
        eventsProcessed: health.eventsProcessed,
        lastProcessedAt: health.lastProcessedAt?.toISOString() || null,
        lastError: health.lastError,
        checkpointPosition: checkpoint,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      const e = error as Error;

      Log.error(this.logger, 'Lookup projector health check failed', {
        error: e.message,
        stack: e.stack,
      });

      return {
        isHealthy: false,
        isRunning: false,
        projectorName: LookupProjectionKeys.PROJECTOR_NAME,
        subscriptionGroup: LookupProjectionKeys.SUBSCRIPTION_GROUP,
        eventsProcessed: 0,
        lastProcessedAt: null,
        lastError: e.message,
        checkpointPosition: null,
        timestamp: new Date().toISOString(),
      };
    }
  }

  @Get('lookup/metrics')
  async getLookupProjectorMetrics() {
    try {
      const health = this.lookupProjector.getHealthStatus();
      const checkpoint = await this.lookupProjector.getCurrentCheckpoint();

      // This would typically integrate with your metrics system
      // For now, return basic health metrics
      return {
        projector_status: health.isHealthy ? 1 : 0,
        projector_running: health.isRunning ? 1 : 0,
        events_processed: health.eventsProcessed,
        checkpoint_position: checkpoint || '0:0',
        last_processed_at: health.lastProcessedAt?.toISOString() || null,
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      const e = error as Error;

      Log.error(this.logger, 'Lookup projector metrics failed', {
        error: e.message,
      });

      return {
        projector_status: 0,
        projector_running: 0,
        events_processed: 0,
        checkpoint_position: '0:0',
        last_processed_at: null,
        timestamp: new Date().toISOString(),
        error: e.message,
      };
    }
  }
}
