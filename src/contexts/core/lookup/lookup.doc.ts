// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { INestApplication } from '@nestjs/common';
import { SwaggerConfigUtil } from 'src/docs/swagger-config.util';

/**
 * core lookup application/service Documentation
 * This module handles the Swagger documentation for cores
 *
 */
export class LookupApplicationDocumentation {
  static setup(app: INestApplication, port: string | number): void {
    const config = new DocumentBuilder()
      .addBearerAuth(
        { type: 'http', scheme: 'bearer', bearerFormat: 'JWT' },
        'bearer',
      )
      .setTitle(`lookup management`)
      .setDescription(
        `
## bounded context: core
[‚Üê Back to documentation](/api/docs/core)

# üìò Lookup-Type Service ‚Äî Detailed Description

## 1. Purpose and Overview

The **Lookup-Type Service** is a foundational microservice designed to provide **attribute definition and validation capabilities** to any domain within the system that requires structured, rule-based metadata. It defines the **attribute model**, enforces validation rules, and exposes reusable schemas that other domains can implement.

This service is not limited to lookups ‚Äî it becomes a **shared attribute policy provider** across multiple bounded contexts, including but not limited to:

* **Lookup** ‚Äî Dynamic attribute extensions for lookup entities.
* **Person** ‚Äî Additional personal or demographic fields.
* **Company** ‚Äî Organizational metadata (e.g. registration, sector, type).
* **Customer** ‚Äî Customer profile extensions, preferences, and classifications.
* **Supplier** ‚Äî Vendor and service provider attributes.
* **Employer** ‚Äî Employer metadata, registration details, or compliance data.

By centralizing attribute definitions, the Lookup-Type Service ensures that every domain implements attributes **consistently, securely, and with shared validation logic**.

---

## 2. Core Responsibilities

### 2.1 Attribute Definition Management

* Define **attribute types** (&#x60;string&#x60;, &#x60;boolean&#x60;, &#x60;integer&#x60;, &#x60;currency&#x60;, &#x60;date&#x60;, &#x60;datetime&#x60;, &#x60;other&#x60;).
* Manage **validation rules** for each attribute:

  * Required / optional
  * Unique constraint
  * Regex pattern and error messages
  * Reserved / immutable fields
  * Reference fields (for indexed search or foreign key mapping)
* Support **custom domain-specific attribute definitions** under each bounded context.

### 2.2 Lookup-Type Configuration

* Define reusable **attribute schemas** known as &#x60;LookupType&#x60;.
* Each &#x60;LookupType&#x60; describes a **set of attribute rules** that can be inherited or referenced by other services.
* Maintain versioning and enable/disable control for type definitions.

### 2.3 Validation-as-a-Service

The service acts as a **validation authority** for other domains that use dynamic attributes. Other microservices can:

* Query &#x60;LookupType&#x60; and its associated attribute rules.
* Perform client-side or server-side validation using those rules.
* Enforce consistent attribute semantics system-wide.

### 2.4 Multi-Domain Reuse

Any domain that manages entities with flexible attributes (e.g., &#x60;Person&#x60;, &#x60;Customer&#x60;, &#x60;Supplier&#x60;) can **register or reference** attribute schemas from this service. This eliminates redundant schema management and promotes schema governance.

---

## 3. Domain Model

### 3.1 LookupType Aggregate

**Purpose:** Represents the blueprint for a set of attributes.

**Attributes:**

* &#x60;code&#x60; ‚Äî Unique technical identifier for the lookup type (immutable).
* &#x60;name&#x60; ‚Äî Human-readable label.
* &#x60;description&#x60; ‚Äî Optional detailed explanation.
* &#x60;enabled&#x60; ‚Äî Boolean indicating whether the type is active.
* &#x60;attributeRules&#x60; ‚Äî A map of attribute rule definitions.

**Responsibilities:**

* Create, update, and deactivate lookup types.
* Manage collections of &#x60;AttributeRule&#x60; value objects.
* Validate integrity between rules (e.g., no duplicate names, reserved rule immutability).

**Domain Events:**

* &#x60;LookupTypeCreated&#x60;
* &#x60;LookupTypeUpdated&#x60;
* &#x60;LookupTypeEnabled&#x60;
* &#x60;LookupTypeDisabled&#x60;
* &#x60;LookupTypeAttributeRuleAdded&#x60;
* &#x60;LookupTypeAttributeRuleUpdated&#x60;
* &#x60;LookupTypeAttributeRuleRemoved&#x60;

### 3.2 AttributeRule Value Object

**Purpose:** Describes the behavior and constraints of a single attribute field.

**Attributes:**

* &#x60;name&#x60; ‚Äî Unique name of the attribute.
* &#x60;description&#x60; ‚Äî What the attribute represents.
* &#x60;type&#x60; ‚Äî Data type (&#x60;string&#x60;, &#x60;integer&#x60;, &#x60;boolean&#x60;, etc.).
* &#x60;required&#x60; ‚Äî Indicates whether the attribute must always be present.
* &#x60;unique&#x60; ‚Äî Indicates if the value must be unique across the domain.
* &#x60;regex&#x60; ‚Äî Optional validation pattern.
* &#x60;reference&#x60; ‚Äî Indicates if the field can be used as a lookup key or external reference.
* &#x60;reserved&#x60; ‚Äî Protects critical attributes from deletion or modification.

**Validation Behavior:**

* Enforces type safety, uniqueness, and presence.
* Provides error messages for validation failures (&#x60;requiredError&#x60;, &#x60;uniqueError&#x60;, &#x60;regexError&#x60;).

---

## 4. Integration and Implementation Model

### 4.1 API Integration

Other domains use the Lookup-Type Service via REST or internal service calls:

#### Query APIs

* &#x60;GET /api/v1/lookup-types&#x60; ‚Äî List available lookup types.
* &#x60;GET /api/v1/lookup-types/{code}&#x60; ‚Äî Retrieve a specific type definition.

#### Command APIs

* &#x60;POST /api/v1/lookup-types&#x60; ‚Äî Create a new type definition.
* &#x60;PUT /api/v1/lookup-types/{code}&#x60; ‚Äî Update a type definition and attribute rules.

Each domain can cache or project these definitions locally for fast runtime validation.

### 4.2 Domain Integration Pattern

Each bounded context that supports dynamic attributes (e.g. Person, Company) implements an **AttributeRuleAdapter** or **AttributeRuleValidator** component:

1. On entity creation/update, the service queries the Lookup-Type projection for the relevant type definition.
2. AttributeRuleValidator enforces the rules.
3. If validation passes, the entity is persisted.
4. Violations trigger domain-level validation errors.

### 4.3 Event-Driven Synchronization

* &#x60;LookupType&#x60; and &#x60;AttributeRule&#x60; changes are published as **domain events** (via EventStoreDB or message bus).
* Subscribing domains update their local projections to maintain current rule sets.

---

## 5. Architectural Role

### 5.1 Shared Governance Layer

* Provides a **single point of truth** for attribute rules.
* Prevents each service from reinventing attribute schemas.
* Supports auditability ‚Äî changes to attribute definitions are event-sourced and version-controlled.

### 5.2 Enabler for Dynamic Schemas

By decoupling attribute definitions from entity persistence:

* Entities across domains can evolve without database migrations.
* New attributes can be added dynamically by updating the ruleset.
* Front-end forms (e.g. FEML) can render fields based on the active schema.

### 5.3 Multi-Tenant Support

Each &#x60;LookupType&#x60; and &#x60;AttributeRule&#x60; can be **scoped per tenant**, allowing custom attribute definitions for each tenant or organization.

Key identifier pattern:

&#x60;&#x60;&#x60;
core-lookup-type:v1:{tenant}:type:{lookupTypeCode}
core-lookup-type:v1:{tenant}:rule:{attributeName}
&#x60;&#x60;&#x60;

---

## 6. Example Use Cases

### 6.1 Lookup Domain

Defines the schema for lookup entities:

&#x60;&#x60;&#x60;json
{
  &quot;code&quot;: &quot;ACCOUNT_STATUS&quot;,
  &quot;attributeRules&quot;: {
    &quot;category&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;required&quot;: true },
    &quot;terminal&quot;: { &quot;type&quot;: &quot;boolean&quot;, &quot;required&quot;: true }
  }
}
&#x60;&#x60;&#x60;

Each &#x60;Lookup&#x60; instance uses these rules to validate its attributes.

### 6.2 Person Domain

Allows additional attributes beyond fixed identity fields:

&#x60;&#x60;&#x60;json
{
  &quot;code&quot;: &quot;PERSON_PROFILE&quot;,
  &quot;attributeRules&quot;: {
    &quot;maritalStatus&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;employmentType&quot;: { &quot;type&quot;: &quot;string&quot; }
  }
}
&#x60;&#x60;&#x60;

### 6.3 Customer Domain

Manages customer metadata through reusable definitions:

&#x60;&#x60;&#x60;json
{
  &quot;code&quot;: &quot;CUSTOMER_CLASSIFICATION&quot;,
  &quot;attributeRules&quot;: {
    &quot;riskLevel&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;required&quot;: true },
    &quot;creditScore&quot;: { &quot;type&quot;: &quot;integer&quot; }
  }
}
&#x60;&#x60;&#x60;

---

## 7. Benefits

* **Centralized validation and governance** across all domains.
* **Reduced coupling** ‚Äî domains depend on rules, not hard-coded schemas.
* **Dynamic extensibility** ‚Äî new attributes require no schema migration.
* **Auditability** ‚Äî every rule change produces an event for traceability.
* **Improved front-end flexibility** ‚Äî FEML or Angular UIs can render fields dynamically.

---

## 8. Summary

The **Lookup-Type Service** establishes a unified, event-driven framework for defining and enforcing attribute rules across the entire platform. It acts as the **metadata backbone** for domains that require dynamic, extensible, and validated entity attributes.

It transforms attribute governance from a scattered, per-domain concern into a centralized, reusable, and evolvable capability ‚Äî supporting compliance, adaptability, and developer productivity throughout the ecosystem.


### application: lookup

  | Modules |
  |---------------|
  | [***lookup  ‚Üí***](/api/docs/core/lookup/lookup) |
        `,
      )
      .setVersion('1.0.0')
      .addTag('Lookup', `Configuration for core lookup application/service`);

    // Add dynamic server configuration
    SwaggerConfigUtil.addServers(config, port);

    // Create a document with no modules to ensure no API paths are included
    const document = SwaggerModule.createDocument(app, config.build(), {
      include: [], // No modules included - this is a links-only documentation page
      extraModels: [],
      deepScanRoutes: false, // Prevent automatic route discovery
      ignoreGlobalPrefix: true, // Ignore global prefix to avoid path discovery
    });

    // Remove any automatically discovered paths and schemas
    document.paths = {};
    document.components = { schemas: {} };

    SwaggerModule.setup('api/docs/core/lookup', app, document);
  }

  /**
   * Setup all core-related documentation endpoints
   * This method centralizes the setup of all core module documentation
   */
  static setupAll(
    app: INestApplication,
    port: string | number,
  ): Record<string, string> {
    // Setup main core documentation
    LookupApplicationDocumentation.setup(app, port);

    // Setup sub-module documentation

    // Return all endpoint URLs
    return {
      core: LookupApplicationDocumentation.getEndpoint(port),
    };
  }

  static getEndpoint(port: string | number): string {
    return `${SwaggerConfigUtil.getServerUrl(port)}/api/docs/core/lookup`;
  }
}
