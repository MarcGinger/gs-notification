// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { EntityIdBase } from 'src/shared/domain/entities';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { AppConfigSnapshotProps } from '../props';
import { AppConfigDomainState } from '../state';
import { AppConfigErrors } from '../errors/app-config.errors';
import {
  AppConfigAuditChannelId,
  AppConfigCreatedAt,
  AppConfigUpdatedAt,
  AppConfigVersion,
  AppConfigDefaultLocale,
  AppConfigId,
  AppConfigLoggingEnabled,
  AppConfigMaxRetryAttempts,
  AppConfigMetadata,
  AppConfigRetryBackoffSeconds,
  AppConfigWorkspaceId,
} from '../value-objects';

/**
 * Domain Entity: AppConfig
 *
 * Represents the core AppConfig entity in the notification-slack domain.
 * Encapsulates appConfig data, identity, and basic entity behavior.
 *
 * This entity follows DDD principles:
 * - Identity: Id as unique identifier
 * - Immutability: Changes create new instances
 * - Encapsulation: Private state with controlled access
 * - Business validation: Domain rules enforced
 *
 * @domain NotificationSlack Context - AppConfig Entity
 * @layer Domain Entities
 */

/**
 * AppConfig Entity
 *
 * Core domain entity representing a appConfig in the notification-slack.
 * Handles appConfig identity, validation, and state management.
 */
export class AppConfigEntity extends EntityIdBase<
  AppConfigDomainState,
  AppConfigId
> {
  private static clock: { now: () => Date } = { now: () => new Date() };

  public static setClock(c: { now: () => Date }) {
    this.clock = c;
  }

  /**
   * Helper method to create updatedAt VO from date
   */
  private static createUpdatedAt(
    date?: Date,
  ): Result<AppConfigUpdatedAt, DomainError> {
    const targetDate = date || AppConfigEntity.clock.now();
    const result = AppConfigUpdatedAt.from(targetDate);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create version VO from number
   */
  private static createVersion(
    versionNumber?: number,
    currentVersion?: AppConfigVersion,
  ): Result<AppConfigVersion, DomainError> {
    const targetVersion = versionNumber ?? currentVersion?.value ?? 1;
    const result = AppConfigVersion.from(targetVersion);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create updated entity with common logic
   */
  private createUpdatedEntity(
    fieldUpdates: Partial<AppConfigDomainState>,
    updatedAt?: Date,
    version?: number,
  ): Result<AppConfigEntity, DomainError> {
    const updatedAtResult = AppConfigEntity.createUpdatedAt(updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = AppConfigEntity.createVersion(
      version,
      this.props.version,
    );
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const updatedProps: AppConfigDomainState = {
      ...this.props,
      ...fieldUpdates,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return AppConfigEntity.create(updatedProps);
  }

  private constructor(props: AppConfigDomainState) {
    super(props, props.id);
  }

  /**
   * Factory method to create a new appConfig entity
   *
   * @param props - AppConfig properties
   * @returns Result containing AppConfigEntity or DomainError
   */
  public static create(
    props: AppConfigDomainState,
  ): Result<AppConfigEntity, DomainError> {
    // Validate required properties
    const validationResult = AppConfigEntity.validate(props);
    if (validationResult.ok === false) {
      return err(validationResult.error);
    }

    return ok(new AppConfigEntity(props));
  }

  /**
   * Factory method to reconstitute a appConfig entity from persistence
   *
   * @param props - AppConfig properties from database
   * @returns AppConfigEntity instance
   */
  public static reconstitute(props: AppConfigDomainState): AppConfigEntity {
    return new AppConfigEntity(props);
  }

  /**
   * Factory method to reconstitute entity from snapshot
   *
   * @param snapshot - AppConfig snapshot properties
   * @returns Result containing AppConfigEntity or DomainError
   */
  public static fromSnapshot(
    snapshot: AppConfigSnapshotProps,
  ): Result<AppConfigEntity, DomainError> {
    const idResult = AppConfigId.from(snapshot.id);
    if (!idResult.ok) {
      return err(idResult.error);
    }
    const workspaceIdResult = AppConfigWorkspaceId.from(snapshot.workspaceId);
    if (!workspaceIdResult.ok) {
      return err(workspaceIdResult.error);
    }
    const maxRetryAttemptsResult = AppConfigMaxRetryAttempts.from(
      snapshot.maxRetryAttempts,
    );
    if (!maxRetryAttemptsResult.ok) {
      return err(maxRetryAttemptsResult.error);
    }
    const retryBackoffSecondsResult = AppConfigRetryBackoffSeconds.from(
      snapshot.retryBackoffSeconds,
    );
    if (!retryBackoffSecondsResult.ok) {
      return err(retryBackoffSecondsResult.error);
    }
    const defaultLocaleResult = AppConfigDefaultLocale.from(
      snapshot.defaultLocale,
    );
    if (!defaultLocaleResult.ok) {
      return err(defaultLocaleResult.error);
    }
    const loggingEnabledResult = AppConfigLoggingEnabled.from(
      snapshot.loggingEnabled,
    );
    if (!loggingEnabledResult.ok) {
      return err(loggingEnabledResult.error);
    }
    const auditChannelIdResult = AppConfigAuditChannelId.from(
      snapshot.auditChannelId,
    );
    if (!auditChannelIdResult.ok) {
      return err(auditChannelIdResult.error);
    }
    const metadataResult = AppConfigMetadata.from(snapshot.metadata);
    if (!metadataResult.ok) {
      return err(metadataResult.error);
    }
    const createdAtResult = AppConfigCreatedAt.from(snapshot.createdAt);
    if (!createdAtResult.ok) {
      return err(createdAtResult.error);
    }

    const updatedAtResult = AppConfigUpdatedAt.from(snapshot.updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = AppConfigVersion.from(snapshot.version);
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const props: AppConfigDomainState = {
      id: idResult.value,
      workspaceId: workspaceIdResult.value,
      maxRetryAttempts: maxRetryAttemptsResult.value,
      retryBackoffSeconds: retryBackoffSecondsResult.value,
      defaultLocale: defaultLocaleResult.value,
      loggingEnabled: loggingEnabledResult.value,
      auditChannelId: auditChannelIdResult.value,
      metadata: metadataResult.value,
      createdAt: createdAtResult.value,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return AppConfigEntity.create(props);
  }

  /**
   * Validates appConfig entity properties
   *
   * @param props - Properties to validate
   * @returns Validation result
   */
  private static validate(
    props: AppConfigDomainState,
  ): Result<void, DomainError> {
    // Basic validation
    if (!props.id) {
      return err(AppConfigErrors.INVALID_ID_DATA);
    }
    if (!props.workspaceId) {
      return err(AppConfigErrors.INVALID_WORKSPACE_ID_DATA);
    }
    if (!props.maxRetryAttempts) {
      return err(AppConfigErrors.INVALID_MAX_RETRY_ATTEMPTS_DATA);
    }
    if (!props.retryBackoffSeconds) {
      return err(AppConfigErrors.INVALID_RETRY_BACKOFF_SECONDS_DATA);
    }
    if (!props.defaultLocale) {
      return err(AppConfigErrors.INVALID_DEFAULT_LOCALE_DATA);
    }
    if (!props.loggingEnabled) {
      return err(AppConfigErrors.INVALID_LOGGING_ENABLED_DATA);
    }

    return ok(undefined);
  }

  // ======================
  // Getters (Public API)
  // ======================

  public get id(): AppConfigId {
    return this.props.id;
  }

  public get workspaceId(): AppConfigWorkspaceId {
    return this.props.workspaceId;
  }

  public get maxRetryAttempts(): AppConfigMaxRetryAttempts {
    return this.props.maxRetryAttempts;
  }

  public get retryBackoffSeconds(): AppConfigRetryBackoffSeconds {
    return this.props.retryBackoffSeconds;
  }

  public get defaultLocale(): AppConfigDefaultLocale {
    return this.props.defaultLocale;
  }

  public get loggingEnabled(): AppConfigLoggingEnabled {
    return this.props.loggingEnabled;
  }

  public get auditChannelId(): AppConfigAuditChannelId | undefined {
    return this.props.auditChannelId;
  }

  public get metadata(): AppConfigMetadata | undefined {
    return this.props.metadata;
  }

  public get createdAt(): AppConfigCreatedAt {
    return this.props.createdAt;
  }

  public get updatedAt(): AppConfigUpdatedAt {
    return this.props.updatedAt;
  }

  public get version(): AppConfigVersion {
    return this.props.version;
  }

  // ======================
  // Simple Update Methods (No Business Logic)
  // ======================

  /**
   * Creates a new entity with updated workspaceId (pure state transition)
   *
   * @param workspaceId - New workspace_id value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AppConfigEntity, DomainError>
   */
  public withWorkspaceId(
    workspaceId: AppConfigWorkspaceId,
    updatedAt?: Date,
    version?: number,
  ): Result<AppConfigEntity, DomainError> {
    return this.createUpdatedEntity({ workspaceId }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated maxRetryAttempts (pure state transition)
   *
   * @param maxRetryAttempts - New max_retry_attempts value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AppConfigEntity, DomainError>
   */
  public withMaxRetryAttempts(
    maxRetryAttempts: AppConfigMaxRetryAttempts,
    updatedAt?: Date,
    version?: number,
  ): Result<AppConfigEntity, DomainError> {
    return this.createUpdatedEntity({ maxRetryAttempts }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated retryBackoffSeconds (pure state transition)
   *
   * @param retryBackoffSeconds - New retry_backoff_seconds value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AppConfigEntity, DomainError>
   */
  public withRetryBackoffSeconds(
    retryBackoffSeconds: AppConfigRetryBackoffSeconds,
    updatedAt?: Date,
    version?: number,
  ): Result<AppConfigEntity, DomainError> {
    return this.createUpdatedEntity(
      { retryBackoffSeconds },
      updatedAt,
      version,
    );
  }

  /**
   * Creates a new entity with updated defaultLocale (pure state transition)
   *
   * @param defaultLocale - New default_locale value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AppConfigEntity, DomainError>
   */
  public withDefaultLocale(
    defaultLocale: AppConfigDefaultLocale,
    updatedAt?: Date,
    version?: number,
  ): Result<AppConfigEntity, DomainError> {
    return this.createUpdatedEntity({ defaultLocale }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated loggingEnabled (pure state transition)
   *
   * @param loggingEnabled - New logging_enabled value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AppConfigEntity, DomainError>
   */
  public withLoggingEnabled(
    loggingEnabled: AppConfigLoggingEnabled,
    updatedAt?: Date,
    version?: number,
  ): Result<AppConfigEntity, DomainError> {
    return this.createUpdatedEntity({ loggingEnabled }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated auditChannelId (pure state transition)
   *
   * @param auditChannelId - New audit_channel_id value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AppConfigEntity, DomainError>
   */
  public withAuditChannelId(
    auditChannelId: AppConfigAuditChannelId,
    updatedAt?: Date,
    version?: number,
  ): Result<AppConfigEntity, DomainError> {
    return this.createUpdatedEntity({ auditChannelId }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated metadata (pure state transition)
   *
   * @param metadata - New metadata value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<AppConfigEntity, DomainError>
   */
  public withMetadata(
    metadata: AppConfigMetadata,
    updatedAt?: Date,
    version?: number,
  ): Result<AppConfigEntity, DomainError> {
    return this.createUpdatedEntity({ metadata }, updatedAt, version);
  }

  // ======================
  // Query Methods
  // ======================

  /**
   * Checks if two appConfigs are the same entity
   *
   * @param other - Other appConfig to compare
   */
  public sameAs(other: AppConfigEntity): boolean {
    return this.props.id.equals(other.props.id);
  }

  /**
   * Gets a snapshot of current entity state for serialization
   */
  public toSnapshot(): AppConfigSnapshotProps {
    return {
      id: this.props.id.value,
      workspaceId: this.props.workspaceId.value,
      maxRetryAttempts: this.props.maxRetryAttempts.value,
      retryBackoffSeconds: this.props.retryBackoffSeconds.value,
      defaultLocale: this.props.defaultLocale.value,
      loggingEnabled: this.props.loggingEnabled.value,
      auditChannelId: this.props.auditChannelId?.value,
      metadata: this.props.metadata?.value,
      createdAt: this.props.createdAt.value,
      updatedAt: this.props.updatedAt.value,
      version: this.props.version.value,
    };
  }

  /**
   * Gets the current domain state with value objects
   *
   * Provides access to the rich domain state for application layer
   * without requiring infrastructure mappers. Maintains clean architecture.
   *
   * @returns Current domain state with value objects
   */
  public getDomainState(): AppConfigDomainState {
    return this.props;
  }
}
