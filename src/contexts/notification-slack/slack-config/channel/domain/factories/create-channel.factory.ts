// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { DomainError, Result, err, withContext } from 'src/shared/errors';
import { Clock } from 'src/shared/domain/clock';
import { EventMetadata } from 'src/shared/domain/events';
import { ChannelAggregate } from '../aggregates';
import { CreateChannelProps } from '../props';
import { ChannelDomainState } from '../state';
import {
  ChannelCreatedAt,
  ChannelUpdatedAt,
  ChannelVersion,
  ChannelId,
  ChannelName,
  ChannelWorkspaceId,
  ChannelIsPrivate,
  ChannelIsDm,
  ChannelTopic,
  ChannelPurpose,
  ChannelSubscribedEvents,
  ChannelEnabled,
} from '../value-objects';

/**
 * Enhanced channel entity factory with comprehensive validation and security context
 * Moved from application layer to properly separate business concerns
 */
export function createChannelAggregateFromProps(
  props: CreateChannelProps,
  metadata: EventMetadata,
  clock: Clock,
  // validatedEntities?: {
  //  channels?: ChannelReference[];
  // },
): Result<ChannelAggregate, DomainError> {
  // Validate each property by creating value objects
  const idResult = ChannelId.from(props.id);
  if (!idResult.ok) {
    return err(
      withContext(idResult.error, {
        ...idResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_channel',
        id: props.id,
      }),
    );
  }

  const nameResult = ChannelName.from(props.name);
  if (!nameResult.ok) {
    return err(
      withContext(nameResult.error, {
        ...nameResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_channel',
        name: props.name,
      }),
    );
  }

  const workspaceIdResult = ChannelWorkspaceId.from(props.workspaceId);
  if (!workspaceIdResult.ok) {
    return err(
      withContext(workspaceIdResult.error, {
        ...workspaceIdResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_channel',
        workspaceId: props.workspaceId,
      }),
    );
  }

  const isPrivateResult = ChannelIsPrivate.from(props.isPrivate);
  if (!isPrivateResult.ok) {
    return err(
      withContext(isPrivateResult.error, {
        ...isPrivateResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_channel',
        isPrivate: props.isPrivate,
      }),
    );
  }

  const isDmResult = ChannelIsDm.from(props.isDm);
  if (!isDmResult.ok) {
    return err(
      withContext(isDmResult.error, {
        ...isDmResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_channel',
        isDm: props.isDm,
      }),
    );
  }

  const topicResult = ChannelTopic.from(props.topic);
  if (!topicResult.ok) {
    return err(
      withContext(topicResult.error, {
        ...topicResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_channel',
        topic: props.topic,
      }),
    );
  }

  const purposeResult = ChannelPurpose.from(props.purpose);
  if (!purposeResult.ok) {
    return err(
      withContext(purposeResult.error, {
        ...purposeResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_channel',
        purpose: props.purpose,
      }),
    );
  }

  const subscribedEventsResult = ChannelSubscribedEvents.from(
    props.subscribedEvents,
  );
  if (!subscribedEventsResult.ok) {
    return err(
      withContext(subscribedEventsResult.error, {
        ...subscribedEventsResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_channel',
        subscribedEvents: props.subscribedEvents,
      }),
    );
  }

  const enabledResult = ChannelEnabled.from(props.enabled);
  if (!enabledResult.ok) {
    return err(
      withContext(enabledResult.error, {
        ...enabledResult.error.context,
        correlationId: metadata.correlationId,
        userId: metadata.userId,
        operation: 'create_channel',
        enabled: props.enabled,
      }),
    );
  }

  const createdAtResult = ChannelCreatedAt.create(clock.now());
  if (!createdAtResult.ok) {
    return err(createdAtResult.error);
  }

  const updatedAtResult = ChannelUpdatedAt.create(clock.now());
  if (!updatedAtResult.ok) {
    return err(updatedAtResult.error);
  }

  const versionResult = ChannelVersion.create(1); // Initial version is 1
  if (!versionResult.ok) {
    return err(versionResult.error);
  }

  // Create the entity properties with validated value objects
  const entityProps: ChannelDomainState = {
    id: idResult.value,
    name: nameResult.value,
    workspaceId: workspaceIdResult.value,
    isPrivate: isPrivateResult.value,
    isDm: isDmResult.value,
    topic: topicResult.value,
    purpose: purposeResult.value,
    subscribedEvents: subscribedEventsResult.value,
    enabled: enabledResult.value,
    createdAt: createdAtResult.value,
    updatedAt: updatedAtResult.value,
    version: versionResult.value,
  };

  // Create the entity using the constructor
  return ChannelAggregate.create(entityProps, clock, metadata);
}
