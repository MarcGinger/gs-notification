// @generated by gen v1.0.0 hash:regen
// REMOVE THIS COMMENT TO STOP AUTOMATIC UPDATES TO THIS BLOCK

import { EntityIdBase } from 'src/shared/domain/entities';
import { Result, ok, err, DomainError } from 'src/shared/errors';
import { TemplateSnapshotProps } from '../props';
import { TemplateDomainState } from '../state';
import { TemplateErrors } from '../errors/template.errors';
import {
  TemplateCode,
  TemplateContentBlocks,
  TemplateCreatedAt,
  TemplateUpdatedAt,
  TemplateVersion,
  TemplateDescription,
  TemplateEnabled,
  TemplateName,
  TemplateSamplePayload,
  TemplateVariables,
  TemplateWorkspaceId,
} from '../value-objects';

/**
 * Domain Entity: Template
 *
 * Represents the core Template entity in the notification-slack domain.
 * Encapsulates template data, identity, and basic entity behavior.
 *
 * This entity follows DDD principles:
 * - Identity: Code as unique identifier
 * - Immutability: Changes create new instances
 * - Encapsulation: Private state with controlled access
 * - Business validation: Domain rules enforced
 *
 * @domain NotificationSlack Context - Template Entity
 * @layer Domain Entities
 */

/**
 * Template Entity
 *
 * Core domain entity representing a template in the notification-slack.
 * Handles template identity, validation, and state management.
 */
export class TemplateEntity extends EntityIdBase<
  TemplateDomainState,
  TemplateCode
> {
  private static clock: { now: () => Date } = { now: () => new Date() };

  public static setClock(c: { now: () => Date }) {
    this.clock = c;
  }

  /**
   * Helper method to create updatedAt VO from date
   */
  private static createUpdatedAt(
    date?: Date,
  ): Result<TemplateUpdatedAt, DomainError> {
    const targetDate = date || TemplateEntity.clock.now();
    const result = TemplateUpdatedAt.from(targetDate);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create version VO from number
   */
  private static createVersion(
    versionNumber?: number,
    currentVersion?: TemplateVersion,
  ): Result<TemplateVersion, DomainError> {
    const targetVersion = versionNumber ?? currentVersion?.value ?? 1;
    const result = TemplateVersion.from(targetVersion);
    if (!result.ok) {
      return err(result.error);
    }
    return ok(result.value);
  }

  /**
   * Helper method to create updated entity with common logic
   */
  private createUpdatedEntity(
    fieldUpdates: Partial<TemplateDomainState>,
    updatedAt?: Date,
    version?: number,
  ): Result<TemplateEntity, DomainError> {
    const updatedAtResult = TemplateEntity.createUpdatedAt(updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = TemplateEntity.createVersion(
      version,
      this.props.version,
    );
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const updatedProps: TemplateDomainState = {
      ...this.props,
      ...fieldUpdates,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return TemplateEntity.create(updatedProps);
  }

  private constructor(props: TemplateDomainState) {
    super(props, props.code);
  }

  /**
   * Factory method to create a new template entity
   *
   * @param props - Template properties
   * @returns Result containing TemplateEntity or DomainError
   */
  public static create(
    props: TemplateDomainState,
  ): Result<TemplateEntity, DomainError> {
    // Validate required properties
    const validationResult = TemplateEntity.validate(props);
    if (validationResult.ok === false) {
      return err(validationResult.error);
    }

    return ok(new TemplateEntity(props));
  }

  /**
   * Factory method to reconstitute a template entity from persistence
   *
   * @param props - Template properties from database
   * @returns TemplateEntity instance
   */
  public static reconstitute(props: TemplateDomainState): TemplateEntity {
    return new TemplateEntity(props);
  }

  /**
   * Factory method to reconstitute entity from snapshot
   *
   * @param snapshot - Template snapshot properties
   * @returns Result containing TemplateEntity or DomainError
   */
  public static fromSnapshot(
    snapshot: TemplateSnapshotProps,
  ): Result<TemplateEntity, DomainError> {
    const codeResult = TemplateCode.from(snapshot.code);
    if (!codeResult.ok) {
      return err(codeResult.error);
    }
    const workspaceIdResult = TemplateWorkspaceId.from(snapshot.workspaceId);
    if (!workspaceIdResult.ok) {
      return err(workspaceIdResult.error);
    }
    const nameResult = TemplateName.from(snapshot.name);
    if (!nameResult.ok) {
      return err(nameResult.error);
    }
    const descriptionResult = TemplateDescription.from(snapshot.description);
    if (!descriptionResult.ok) {
      return err(descriptionResult.error);
    }
    const contentBlocksResult = TemplateContentBlocks.from(
      snapshot.contentBlocks,
    );
    if (!contentBlocksResult.ok) {
      return err(contentBlocksResult.error);
    }
    const variablesResult = TemplateVariables.from(snapshot.variables);
    if (!variablesResult.ok) {
      return err(variablesResult.error);
    }
    const samplePayloadResult = TemplateSamplePayload.from(
      snapshot.samplePayload,
    );
    if (!samplePayloadResult.ok) {
      return err(samplePayloadResult.error);
    }
    const enabledResult = TemplateEnabled.from(snapshot.enabled);
    if (!enabledResult.ok) {
      return err(enabledResult.error);
    }
    const createdAtResult = TemplateCreatedAt.from(snapshot.createdAt);
    if (!createdAtResult.ok) {
      return err(createdAtResult.error);
    }

    const updatedAtResult = TemplateUpdatedAt.from(snapshot.updatedAt);
    if (!updatedAtResult.ok) {
      return err(updatedAtResult.error);
    }

    const versionResult = TemplateVersion.from(snapshot.version);
    if (!versionResult.ok) {
      return err(versionResult.error);
    }

    const props: TemplateDomainState = {
      code: codeResult.value,
      workspaceId: workspaceIdResult.value,
      name: nameResult.value,
      description: descriptionResult.value,
      contentBlocks: contentBlocksResult.value,
      variables: variablesResult.value,
      samplePayload: samplePayloadResult.value,
      enabled: enabledResult.value,
      createdAt: createdAtResult.value,
      updatedAt: updatedAtResult.value,
      version: versionResult.value,
    };

    return TemplateEntity.create(props);
  }

  /**
   * Validates template entity properties
   *
   * @param props - Properties to validate
   * @returns Validation result
   */
  private static validate(
    props: TemplateDomainState,
  ): Result<void, DomainError> {
    // Basic validation
    if (!props.code) {
      return err(TemplateErrors.INVALID_CODE_DATA);
    }
    if (!props.workspaceId) {
      return err(TemplateErrors.INVALID_WORKSPACE_ID_DATA);
    }
    if (!props.name) {
      return err(TemplateErrors.INVALID_NAME_DATA);
    }
    if (!props.contentBlocks) {
      return err(TemplateErrors.INVALID_CONTENT_BLOCKS_DATA);
    }
    if (!props.enabled) {
      return err(TemplateErrors.INVALID_ENABLED_DATA);
    }

    return ok(undefined);
  }

  // ======================
  // Getters (Public API)
  // ======================

  public get code(): TemplateCode {
    return this.props.code;
  }

  public get workspaceId(): TemplateWorkspaceId {
    return this.props.workspaceId;
  }

  public get name(): TemplateName {
    return this.props.name;
  }

  public get description(): TemplateDescription | undefined {
    return this.props.description;
  }

  public get contentBlocks(): TemplateContentBlocks {
    return this.props.contentBlocks;
  }

  public get variables(): TemplateVariables | undefined {
    return this.props.variables;
  }

  public get samplePayload(): TemplateSamplePayload | undefined {
    return this.props.samplePayload;
  }

  public get enabled(): TemplateEnabled {
    return this.props.enabled;
  }

  public get createdAt(): TemplateCreatedAt {
    return this.props.createdAt;
  }

  public get updatedAt(): TemplateUpdatedAt {
    return this.props.updatedAt;
  }

  public get version(): TemplateVersion {
    return this.props.version;
  }

  // ======================
  // Simple Update Methods (No Business Logic)
  // ======================

  /**
   * Creates a new entity with updated workspaceId (pure state transition)
   *
   * @param workspaceId - New workspace_id value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<TemplateEntity, DomainError>
   */
  public withWorkspaceId(
    workspaceId: TemplateWorkspaceId,
    updatedAt?: Date,
    version?: number,
  ): Result<TemplateEntity, DomainError> {
    return this.createUpdatedEntity({ workspaceId }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated name (pure state transition)
   *
   * @param name - New name value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<TemplateEntity, DomainError>
   */
  public withName(
    name: TemplateName,
    updatedAt?: Date,
    version?: number,
  ): Result<TemplateEntity, DomainError> {
    return this.createUpdatedEntity({ name }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated description (pure state transition)
   *
   * @param description - New description value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<TemplateEntity, DomainError>
   */
  public withDescription(
    description: TemplateDescription,
    updatedAt?: Date,
    version?: number,
  ): Result<TemplateEntity, DomainError> {
    return this.createUpdatedEntity({ description }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated contentBlocks (pure state transition)
   *
   * @param contentBlocks - New content_blocks value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<TemplateEntity, DomainError>
   */
  public withContentBlocks(
    contentBlocks: TemplateContentBlocks,
    updatedAt?: Date,
    version?: number,
  ): Result<TemplateEntity, DomainError> {
    return this.createUpdatedEntity({ contentBlocks }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated variables (pure state transition)
   *
   * @param variables - New variables value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<TemplateEntity, DomainError>
   */
  public withVariables(
    variables: TemplateVariables,
    updatedAt?: Date,
    version?: number,
  ): Result<TemplateEntity, DomainError> {
    return this.createUpdatedEntity({ variables }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated samplePayload (pure state transition)
   *
   * @param samplePayload - New sample_payload value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<TemplateEntity, DomainError>
   */
  public withSamplePayload(
    samplePayload: TemplateSamplePayload,
    updatedAt?: Date,
    version?: number,
  ): Result<TemplateEntity, DomainError> {
    return this.createUpdatedEntity({ samplePayload }, updatedAt, version);
  }

  /**
   * Creates a new entity with updated enabled (pure state transition)
   *
   * @param enabled - New enabled value
   * @param updatedAt - Optional timestamp (uses clock if not provided)
   * @returns Result<TemplateEntity, DomainError>
   */
  public withEnabled(
    enabled: TemplateEnabled,
    updatedAt?: Date,
    version?: number,
  ): Result<TemplateEntity, DomainError> {
    return this.createUpdatedEntity({ enabled }, updatedAt, version);
  }

  // ======================
  // Query Methods
  // ======================

  /**
   * Checks if two templates are the same entity
   *
   * @param other - Other template to compare
   */
  public sameAs(other: TemplateEntity): boolean {
    return this.props.code.equals(other.props.code);
  }

  /**
   * Gets a snapshot of current entity state for serialization
   */
  public toSnapshot(): TemplateSnapshotProps {
    return {
      code: this.props.code.value,
      workspaceId: this.props.workspaceId.value,
      name: this.props.name.value,
      description: this.props.description?.value,
      contentBlocks: this.props.contentBlocks.toArray(),
      variables: this.props.variables?.toArray(),
      samplePayload: this.props.samplePayload?.value,
      enabled: this.props.enabled.value,
      createdAt: this.props.createdAt.value,
      updatedAt: this.props.updatedAt.value,
      version: this.props.version.value,
    };
  }

  /**
   * Gets the current domain state with value objects
   *
   * Provides access to the rich domain state for application layer
   * without requiring infrastructure mappers. Maintains clean architecture.
   *
   * @returns Current domain state with value objects
   */
  public getDomainState(): TemplateDomainState {
    return this.props;
  }
}
